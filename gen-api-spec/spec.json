{
  "components": {
    "parameters": {
      "api_key.name": {
        "description": "^[A-Za-z]+[A-Za-z0-9-_]*$",
        "example": "EMQX-API-KEY-1",
        "in": "path",
        "name": "name",
        "required": true,
        "schema": {
          "type": "string"
        }
      },
      "cluster.node": {
        "description": "node name",
        "example": "emqx2@127.0.0.1",
        "in": "path",
        "name": "node",
        "required": true,
        "schema": {
          "type": "string"
        }
      },
      "emqx_authz_api_mnesia.clientid": {
        "description": "ClientID",
        "example": "client1",
        "in": "path",
        "name": "clientid",
        "required": true,
        "schema": {
          "type": "string"
        }
      },
      "emqx_authz_api_mnesia.username": {
        "description": "Username",
        "example": "user1",
        "in": "path",
        "name": "username",
        "required": true,
        "schema": {
          "type": "string"
        }
      },
      "emqx_mgmt_api_nodes.node_name": {
        "description": "Node name",
        "example": "emqx@127.0.0.1",
        "in": "path",
        "name": "node",
        "required": true,
        "schema": {
          "type": "string"
        }
      },
      "emqx_mgmt_api_stats.aggregate": {
        "description": "Calculation aggregate for all nodes",
        "example": false,
        "in": "query",
        "name": "aggregate",
        "required": false,
        "schema": {
          "type": "boolean"
        }
      },
      "listeners.listener_id": {
        "description": "Listener id",
        "example": "tcp:demo",
        "in": "path",
        "name": "id",
        "required": true,
        "schema": {
          "type": "string"
        }
      },
      "plugins.name": {
        "description": "^[A-Za-z]+[A-Za-z0-9-_.]*$",
        "example": "emqx_plugin_template-5.0-rc.1",
        "in": "path",
        "name": "name",
        "required": true,
        "schema": {
          "type": "string"
        }
      },
      "public.limit": {
        "description": "Results per page(max 1000)",
        "example": 50,
        "in": "query",
        "name": "limit",
        "schema": {
          "default": 100,
          "maximum": 1000,
          "minimum": 1,
          "type": "integer"
        }
      },
      "public.page": {
        "description": "Page number of the results to fetch.",
        "example": 1,
        "in": "query",
        "name": "page",
        "schema": {
          "default": 1,
          "minimum": 1,
          "type": "integer"
        }
      },
      "trace.bytes": {
        "description": "Maximum number of bytes to store in request",
        "in": "query",
        "name": "bytes",
        "required": false,
        "schema": {
          "default": 1000,
          "type": "integer"
        }
      },
      "trace.name": {
        "description": "[a-zA-Z0-9-_]",
        "example": "EMQX-TRACE-1",
        "in": "path",
        "name": "name",
        "required": true,
        "schema": {
          "type": "string"
        }
      },
      "trace.node": {
        "description": "Node name",
        "in": "query",
        "name": "node",
        "required": false,
        "schema": {
          "type": "string"
        }
      },
      "trace.position": {
        "description": "Offset from the current trace position.",
        "in": "query",
        "name": "position",
        "required": false,
        "schema": {
          "default": 0,
          "type": "integer"
        }
      }
    },
    "schemas": {
      "emqx_gateway_api.gateway_listener_overview": {
        "properties": {
          "id": {
            "description": "Listener ID",
            "type": "string"
          },
          "running": {
            "description": "Listener Running status",
            "type": "boolean"
          },
          "type": {
            "description": "Listener Type",
            "enum": [
              "tcp",
              "ssl",
              "udp",
              "dtls"
            ],
            "type": "string"
          }
        },
        "type": "object"
      },
      "emqx_rule_api_schema.ctx_unsub": {
        "required": [
          "event_type"
        ],
        "properties": {
          "event_type": {
            "description": "Event Type",
            "enum": [
              "session_unsubscribed"
            ],
            "type": "string"
          },
          "clientid": {
            "description": "The Client ID",
            "type": "string"
          },
          "username": {
            "description": "The User Name",
            "type": "string"
          },
          "payload": {
            "description": "The Message Payload",
            "type": "string"
          },
          "peerhost": {
            "description": "The IP Address of the Peer Client",
            "type": "string"
          },
          "topic": {
            "description": "Message Topic",
            "type": "string"
          },
          "publish_received_at": {
            "description": "The Time that this Message is Received",
            "type": "integer"
          },
          "qos": {
            "description": "The Message QoS",
            "enum": [
              0,
              1,
              2
            ],
            "type": "string"
          }
        },
        "type": "object"
      },
      "modules.rewrite": {
        "required": [
          "re",
          "dest_topic",
          "source_topic",
          "action"
        ],
        "properties": {
          "action": {
            "description": "Topic rewriting takes effect on the type of operation:</br>  - `subscribe`: Rewrite topic when client do subscribe.</br>  - `publish`: Rewrite topic when client do publish.</br>  - `all`: Both",
            "enum": [
              "subscribe",
              "publish",
              "all"
            ],
            "example": "publish",
            "type": "string"
          },
          "source_topic": {
            "description": "Source topic, specified by the client.",
            "example": "x/#",
            "type": "string"
          },
          "dest_topic": {
            "description": "Destination topic.",
            "example": "z/y/$1",
            "type": "string"
          },
          "re": {
            "description": "Regular expressions",
            "example": "^x/y/(.+)$",
            "type": "string"
          }
        },
        "type": "object"
      },
      "authz.node_status": {
        "properties": {
          "node": {
            "description": "Node name.",
            "example": "emqx@127.0.0.1",
            "type": "string"
          },
          "status": {
            "description": "The status of the resource for each node.",
            "enum": [
              "connected",
              "disconnected",
              "connecting"
            ],
            "type": "string"
          }
        },
        "type": "object"
      },
      "broker.listener_wss_opts": {
        "properties": {
          "cacertfile": {
            "description": "</br>Trusted PEM format CA certificates bundle file.</br>The certificates in this file are used to verify the TLS peer's certificates.</br>Append new certificates to the file if new CAs are to be trusted.</br>There is no need to restart EMQX to have the updated file loaded, because</br>the system regularly checks if file has been updated (and reload).</br>NOTE: invalidating (deleting) a certificate from the file will not affect</br>already established connections.</br>",
            "type": "string"
          },
          "certfile": {
            "description": "</br>PEM format certificates chain file.</br>The certificates in this file should be in reversed order of the certificate</br>issue chain. That is, the host's certificate should be placed in the beginning</br>of the file, followed by the immediate issuer certificate and so on.</br>Although the root CA certificate is optional, it should be placed at the end of</br>the file if it is to be added.</br>",
            "type": "string"
          },
          "keyfile": {
            "description": "</br>PEM format private key file.</br>",
            "type": "string"
          },
          "verify": {
            "default": "verify_none",
            "description": "</br>Enable or disable peer verification.</br>",
            "enum": [
              "verify_peer",
              "verify_none"
            ],
            "type": "string"
          },
          "reuse_sessions": {
            "default": true,
            "description": "</br>Enable TLS session reuse.</br>",
            "type": "boolean"
          },
          "depth": {
            "default": 10,
            "description": "</br>Maximum number of non-self-issued intermediate certificates that can follow the peer certificate in a valid certification path. So, if depth is 0 the PEER must be signed by the trusted ROOT-CA directly; if 1 the path can be PEER, CA, ROOT-CA; if 2 the path can be PEER, CA, CA, ROOT-CA, and so on. The default value is 10.</br>",
            "type": "integer"
          },
          "password": {
            "description": "</br>String containing the user's password.</br>Only used if the private key file is password-protected.</br>",
            "example": "",
            "type": "string"
          },
          "versions": {
            "default": [
              "tlsv1.3",
              "tlsv1.2",
              "tlsv1.1",
              "tlsv1"
            ],
            "description": "</br>All TLS/DTLS versions to be supported.</br>NOTE: PSK ciphers are suppressed by 'tlsv1.3' version config.</br>In case PSK cipher suites are intended, make sure to configured</br><code>['tlsv1.2', 'tlsv1.1']</code> here.</br>",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "ciphers": {
            "default": [
              "TLS_AES_256_GCM_SHA384",
              "TLS_AES_128_GCM_SHA256",
              "TLS_CHACHA20_POLY1305_SHA256",
              "TLS_AES_128_CCM_SHA256",
              "TLS_AES_128_CCM_8_SHA256",
              "ECDHE-ECDSA-AES256-GCM-SHA384",
              "ECDHE-RSA-AES256-GCM-SHA384",
              "ECDHE-ECDSA-AES256-SHA384",
              "ECDHE-RSA-AES256-SHA384",
              "ECDH-ECDSA-AES256-GCM-SHA384",
              "ECDH-RSA-AES256-GCM-SHA384",
              "ECDH-ECDSA-AES256-SHA384",
              "ECDH-RSA-AES256-SHA384",
              "DHE-DSS-AES256-GCM-SHA384",
              "DHE-DSS-AES256-SHA256",
              "AES256-GCM-SHA384",
              "AES256-SHA256",
              "ECDHE-ECDSA-AES128-GCM-SHA256",
              "ECDHE-RSA-AES128-GCM-SHA256",
              "ECDHE-ECDSA-AES128-SHA256",
              "ECDHE-RSA-AES128-SHA256",
              "ECDH-ECDSA-AES128-GCM-SHA256",
              "ECDH-RSA-AES128-GCM-SHA256",
              "ECDH-ECDSA-AES128-SHA256",
              "ECDH-RSA-AES128-SHA256",
              "DHE-DSS-AES128-GCM-SHA256",
              "DHE-DSS-AES128-SHA256",
              "AES128-GCM-SHA256",
              "AES128-SHA256",
              "ECDHE-ECDSA-AES256-SHA",
              "ECDHE-RSA-AES256-SHA",
              "DHE-DSS-AES256-SHA",
              "ECDH-ECDSA-AES256-SHA",
              "ECDH-RSA-AES256-SHA",
              "ECDHE-ECDSA-AES128-SHA",
              "ECDHE-RSA-AES128-SHA",
              "DHE-DSS-AES128-SHA",
              "ECDH-ECDSA-AES128-SHA",
              "ECDH-RSA-AES128-SHA",
              "RSA-PSK-AES256-GCM-SHA384",
              "RSA-PSK-AES256-CBC-SHA384",
              "RSA-PSK-AES128-GCM-SHA256",
              "RSA-PSK-AES128-CBC-SHA256",
              "RSA-PSK-AES256-CBC-SHA",
              "RSA-PSK-AES128-CBC-SHA"
            ],
            "description": "</br>This config holds TLS cipher suite names separated by comma,</br>or as an array of strings. e.g.</br><code>\"TLS_AES_256_GCM_SHA384,TLS_AES_128_GCM_SHA256\"</code> or</br><code>[\"TLS_AES_256_GCM_SHA384\",\"TLS_AES_128_GCM_SHA256\"]</code>.</br></br>Ciphers (and their ordering) define the way in which the</br>client and server encrypts information over the network connection.</br>Selecting a good cipher suite is critical for the</br>application's data security, confidentiality and performance.</br></br>The names should be in OpenSSL string format (not RFC format).</br>All default values and examples provided by EMQX config</br>documentation are all in OpenSSL format.</br></br>NOTE: Certain cipher suites are only compatible with</br>specific TLS <code>versions</code> ('tlsv1.1', 'tlsv1.2' or 'tlsv1.3')</br>incompatible cipher suites will be silently dropped.</br>For instance, if only 'tlsv1.3' is given in the <code>versions</code>,</br>configuring cipher suites for other versions will have no effect.</br></br></br>NOTE: PSK ciphers are suppressed by 'tlsv1.3' version config</br>If PSK cipher suites are intended, 'tlsv1.3' should be disabled from <code>versions</code>.</br>PSK cipher suites: <code>\"RSA-PSK-AES256-GCM-SHA384,RSA-PSK-AES256-CBC-SHA384,</br>RSA-PSK-AES128-GCM-SHA256,RSA-PSK-AES128-CBC-SHA256,</br>RSA-PSK-AES256-CBC-SHA,RSA-PSK-AES128-CBC-SHA,</br>RSA-PSK-DES-CBC3-SHA,RSA-PSK-RC4-SHA\"</code></br>",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "user_lookup_fun": {
            "default": "emqx_tls_psk:lookup",
            "description": "</br>EMQX-internal callback that is used to lookup pre-shared key (PSK) identity.</br>",
            "type": "string"
          },
          "secure_renegotiate": {
            "default": true,
            "description": "</br>SSL parameter renegotiation is a feature that allows a client and a server</br>to renegotiate the parameters of the SSL connection on the fly.</br>RFC 5746 defines a more secure way of doing this. By enabling secure renegotiation,</br>you drop support for the insecure renegotiation, prone to MitM attacks.</br>",
            "type": "boolean"
          },
          "dhfile": {
            "description": "</br>Path to a file containing PEM-encoded Diffie-Hellman parameters</br>to be used by the server if a cipher suite using Diffie-Hellman</br>key exchange is negotiated. If not specified, default parameters</br>are used.</br>NOTE: The <code>dhfile</code> option is not supported by TLS 1.3.</br>",
            "type": "string"
          },
          "fail_if_no_peer_cert": {
            "default": false,
            "description": "</br>Used together with {verify, verify_peer} by an TLS/DTLS server.</br>If set to true, the server fails if the client does not have a</br>certificate to send, that is, sends an empty certificate.</br>If set to false, it fails only if the client sends an invalid</br>certificate (an empty certificate is considered valid).</br>",
            "type": "boolean"
          },
          "honor_cipher_order": {
            "default": true,
            "description": "</br>An important security setting, it forces the cipher to be set based</br> on the server-specified order instead of the client-specified order,</br> hence enforcing the (usually more properly configured) security</br> ordering of the server administrator.</br>",
            "type": "boolean"
          },
          "client_renegotiation": {
            "default": true,
            "description": "</br>In protocols that support client-initiated renegotiation,</br>the cost of resources of such an operation is higher for the server than the client.</br>This can act as a vector for denial of service attacks.</br>The SSL application already takes measures to counter-act such attempts,</br>but client-initiated renegotiation can be strictly disabled by setting this option to false.</br>The default value is true. Note that disabling renegotiation can result in</br>long-lived connections becoming unusable due to limits on</br>the number of messages the underlying cipher suite can encipher.</br>",
            "type": "boolean"
          },
          "handshake_timeout": {
            "default": "15s",
            "description": "</br>Maximum time duration allowed for the handshake to complete</br>",
            "example": "12m",
            "type": "string"
          }
        },
        "type": "object"
      },
      "broker.sysmon_os": {
        "properties": {
          "cpu_check_interval": {
            "default": "60s",
            "description": "The time interval for the periodic CPU check.",
            "example": "12m",
            "type": "string"
          },
          "cpu_high_watermark": {
            "default": "80%",
            "description": "The threshold, as percentage of system CPU load,</br> for how much system cpu can be used before the corresponding alarm is raised.",
            "example": "12%",
            "type": "number"
          },
          "cpu_low_watermark": {
            "default": "60%",
            "description": "The threshold, as percentage of system CPU load,</br> for how much system cpu can be used before the corresponding alarm is cleared.",
            "example": "12%",
            "type": "number"
          },
          "mem_check_interval": {
            "default": "60s",
            "description": "The time interval for the periodic memory check.",
            "oneOf": [
              {
                "example": "12m",
                "type": "string"
              },
              {
                "enum": [
                  "disabled"
                ],
                "type": "string"
              }
            ]
          },
          "sysmem_high_watermark": {
            "default": "70%",
            "description": "The threshold, as percentage of system memory,</br> for how much system memory can be allocated before the corresponding alarm is raised.",
            "example": "12%",
            "type": "number"
          },
          "procmem_high_watermark": {
            "default": "5%",
            "description": "The threshold, as percentage of system memory,</br> for how much system memory can be allocated by one Erlang process before</br> the corresponding alarm is raised.",
            "example": "12%",
            "type": "number"
          }
        },
        "type": "object"
      },
      "rule_engine.builtin_action_republish": {
        "properties": {
          "function": {
            "description": "Republish the message as a new MQTT message",
            "enum": [
              "republish"
            ],
            "type": "string"
          },
          "args": {
            "default": {},
            "$ref": "#/components/schemas/rule_engine.republish_args"
          }
        },
        "type": "object"
      },
      "emqx_authn_schema.metrics": {
        "properties": {
          "nomatch": {
            "description": "The number of times the instance was ignored when the required authentication information was not found in the current instance.",
            "type": "integer"
          },
          "total": {
            "description": "The total number of times the current instance was triggered.",
            "type": "integer"
          },
          "success": {
            "description": "The required authentication information is found in the current instance, and the instance returns authentication success.",
            "type": "integer"
          },
          "failed": {
            "description": "The required authentication information is found in the current instance, and the instance returns authentication failure.",
            "type": "integer"
          },
          "rate": {
            "description": "The total rate at which instances are triggered, times/second.",
            "type": "number"
          },
          "rate_max": {
            "description": "The highest trigger rate the instance has ever reached, times/second.",
            "type": "number"
          },
          "rate_last5m": {
            "description": "The average trigger rate of the instance within 5 minutes, times/second.",
            "type": "number"
          }
        },
        "type": "object"
      },
      "broker.sysmon": {
        "properties": {
          "vm": {
            "$ref": "#/components/schemas/broker.sysmon_vm"
          },
          "os": {
            "$ref": "#/components/schemas/broker.sysmon_os"
          },
          "top": {
            "$ref": "#/components/schemas/broker.sysmon_top"
          }
        },
        "type": "object"
      },
      "dashboard.http": {
        "required": [
          "bind",
          "enable"
        ],
        "properties": {
          "enable": {
            "default": true,
            "description": "Ignore or enable this listener",
            "type": "boolean"
          },
          "bind": {
            "default": 18083,
            "description": "Port without IP(18083) or port with specified IP(127.0.0.1:18083).",
            "example": "0.0.0.0:18083",
            "oneOf": [
              {
                "example": "127.0.0.1:80",
                "type": "string"
              },
              {
                "minimum": 0,
                "type": "integer"
              }
            ]
          },
          "num_acceptors": {
            "default": 4,
            "description": "Socket acceptor pool size for TCP protocols.",
            "type": "integer"
          },
          "max_connections": {
            "default": 512,
            "description": "Maximum number of simultaneous connections.",
            "type": "integer"
          },
          "backlog": {
            "default": 1024,
            "description": "Defines the maximum length that the queue of pending connections can grow to.",
            "type": "integer"
          },
          "send_timeout": {
            "default": "5s",
            "description": "Send timeout for the socket.",
            "example": "12m",
            "type": "string"
          },
          "inet6": {
            "default": false,
            "description": "Enable IPv6 support, default is false, which means IPv4 only.",
            "type": "boolean"
          },
          "ipv6_v6only": {
            "default": false,
            "description": "Disable IPv4-to-IPv6 mapping for the listener.",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "emqx_gateway_api.update_exproto": {
        "required": [
          "handler",
          "server"
        ],
        "properties": {
          "server": {
            "description": "Configurations for starting the <code>ConnectionAdapter</code> service",
            "$ref": "#/components/schemas/gateway.exproto_grpc_server"
          },
          "handler": {
            "description": "Configurations for request to <code>ConnectionHandler</code> service",
            "$ref": "#/components/schemas/gateway.exproto_grpc_handler"
          },
          "mountpoint": {
            "default": "",
            "description": " ",
            "type": "string"
          },
          "enable": {
            "default": true,
            "description": "Whether to enable this gateway",
            "type": "boolean"
          },
          "enable_stats": {
            "default": true,
            "description": "Whether to enable client process statistic",
            "type": "boolean"
          },
          "idle_timeout": {
            "default": "30s",
            "description": "The idle time of the client connection process. It has two purposes:</br>  1. A newly created client process that does not receive any client requests after that time will be closed directly.</br>  2. A running client process that does not receive any client requests after this time will go into hibernation to save resources.",
            "example": "12m",
            "type": "string"
          },
          "clientinfo_override": {
            "description": "ClientInfo override.",
            "$ref": "#/components/schemas/gateway.clientinfo_override"
          }
        },
        "type": "object"
      },
      "emqx_authn_api.request_user_create": {
        "required": [
          "password",
          "user_id"
        ],
        "properties": {
          "user_id": {
            "type": "string"
          },
          "password": {
            "type": "string"
          },
          "is_superuser": {
            "default": false,
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "authn-mysql.authentication": {
        "required": [
          "database",
          "server",
          "query",
          "backend",
          "mechanism"
        ],
        "properties": {
          "mechanism": {
            "description": "Authentication mechanism.",
            "enum": [
              "password_based"
            ],
            "type": "string"
          },
          "backend": {
            "description": "Backend type.",
            "enum": [
              "mysql"
            ],
            "type": "string"
          },
          "password_hash_algorithm": {
            "default": {
              "name": "sha256",
              "salt_position": "prefix"
            },
            "description": "Options for password hash verification.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/authn-hash.other_algorithms"
              },
              {
                "$ref": "#/components/schemas/authn-hash.pbkdf2"
              },
              {
                "$ref": "#/components/schemas/authn-hash.bcrypt"
              }
            ]
          },
          "query": {
            "description": "SQL used to query data for authentication, such as password hash.",
            "type": "string"
          },
          "query_timeout": {
            "default": "5s",
            "description": "Timeout for the SQL query.",
            "example": "32s",
            "type": "string"
          },
          "enable": {
            "default": true,
            "description": "Set to <code>true</code> or <code>false</code> to disable this auth provider.",
            "type": "boolean"
          },
          "server": {
            "description": "</br>The IPv4 or IPv6 address or the hostname to connect to.</br>A host entry has the following form: `Host[:Port]`.</br>The MySQL default port 3306 is used if `[:Port]` is not specified.</br>",
            "example": "127.0.0.1:80",
            "type": "string"
          },
          "database": {
            "description": "Database name.",
            "type": "string"
          },
          "pool_size": {
            "default": 8,
            "description": "Size of the connection pool.",
            "minimum": 1,
            "type": "integer"
          },
          "username": {
            "description": "EMQX's username in the external database.",
            "type": "string"
          },
          "password": {
            "description": "EMQX's password in the external database.",
            "type": "string"
          },
          "auto_reconnect": {
            "default": true,
            "description": "Enable automatic reconnect to the database.",
            "type": "boolean"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/broker.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "emqx_connector_mqtt.post": {
        "required": [
          "server",
          "name",
          "type"
        ],
        "properties": {
          "type": {
            "description": "The Connector Type.",
            "enum": [
              "mqtt"
            ],
            "type": "string"
          },
          "name": {
            "description": "Connector name, used as a human-readable description of the connector.",
            "type": "string"
          },
          "mode": {
            "default": "cluster_shareload",
            "description": "</br>The mode of the MQTT Bridge.</br></br>- cluster_shareload: create an MQTT connection on each node in the emqx cluster.</br>In 'cluster_shareload' mode, the incoming load from the remote broker is shared by</br>using shared subscription.</br>Note that the 'clientid' is suffixed by the node name, this is to avoid</br>clientid conflicts between different nodes. And we can only use shared subscription</br>topic filters for 'remote_topic' of ingress connections.</br>",
            "enum": [
              "cluster_shareload"
            ],
            "type": "string"
          },
          "server": {
            "description": "The host and port of the remote MQTT broker",
            "example": "127.0.0.1:80",
            "type": "string"
          },
          "reconnect_interval": {
            "default": "15s",
            "description": "Reconnect interval. Delay for the MQTT bridge to retry establishing the connection in case of transportation failure. Time interval is a string that contains a number followed by time unit:</br>- `ms` for milliseconds,</br>- `s` for seconds,</br>- `m` for minutes,</br>- `h` for hours;</br></br>or combination of whereof: `1h5m0s`",
            "type": "string"
          },
          "proto_ver": {
            "default": "v4",
            "description": "The MQTT protocol version",
            "enum": [
              "v3",
              "v4",
              "v5"
            ],
            "type": "string"
          },
          "bridge_mode": {
            "default": false,
            "description": "</br>If enable bridge mode.</br>NOTE: This setting is only for MQTT protocol version older than 5.0, and the remote MQTT</br>broker MUST support this feature.</br>    ",
            "type": "boolean"
          },
          "username": {
            "default": "emqx",
            "description": "The username of the MQTT protocol",
            "type": "string"
          },
          "password": {
            "default": "emqx",
            "description": "The password of the MQTT protocol",
            "type": "string"
          },
          "clean_start": {
            "default": true,
            "description": "The clean-start or the clean-session of the MQTT protocol",
            "type": "boolean"
          },
          "keepalive": {
            "default": "300s",
            "description": "MQTT Keepalive. Time interval is a string that contains a number followed by time unit:</br>- `ms` for milliseconds,</br>- `s` for seconds,</br>- `m` for minutes,</br>- `h` for hours;</br></br>or combination of whereof: `1h5m0s`",
            "type": "string"
          },
          "retry_interval": {
            "default": "15s",
            "description": "Message retry interval. Delay for the MQTT bridge to retry sending the QoS1/QoS2 messages in case of ACK not received. Time interval is a string that contains a number followed by time unit:</br>- `ms` for milliseconds,</br>- `s` for seconds,</br>- `m` for minutes,</br>- `h` for hours;</br></br>or combination of whereof: `1h5m0s`",
            "type": "string"
          },
          "max_inflight": {
            "default": 32,
            "description": "Max inflight (sent, but un-acked) messages of the MQTT protocol",
            "minimum": 0,
            "type": "integer"
          },
          "replayq": {
            "$ref": "#/components/schemas/connector-mqtt.replayq"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/broker.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "emqx_gateway_api.update_mqttsn": {
        "required": [
          "gateway_id"
        ],
        "properties": {
          "gateway_id": {
            "default": 1,
            "description": "MQTT-SN Gateway ID.</br>When the <code>broadcast</code> option is enabled, the gateway will broadcast ADVERTISE message with this value",
            "type": "integer"
          },
          "broadcast": {
            "default": false,
            "description": "Whether to periodically broadcast ADVERTISE messages",
            "type": "boolean"
          },
          "enable_qos3": {
            "default": true,
            "description": "Allows connectionless clients to publish messages with a Qos of -1.</br>This feature is defined for very simple client implementations which do not support any other features except this one. There is no connection setup nor tear down, no registration nor subscription. The client just sends its 'PUBLISH' messages to a GW",
            "type": "boolean"
          },
          "subs_resume": {
            "default": false,
            "description": "Whether to initiate all subscribed topic name registration messages to the client after the Session has been taken over by a new channel",
            "type": "boolean"
          },
          "predefined": {
            "default": "",
            "description": "The pre-defined topic IDs and topic names.</br>A 'pre-defined' topic ID is a topic ID whose mapping to a topic name is known in advance by both the client's application and the gateway",
            "items": {
              "$ref": "#/components/schemas/gateway.mqttsn_predefined"
            },
            "type": "array"
          },
          "mountpoint": {
            "default": "",
            "description": " ",
            "type": "string"
          },
          "enable": {
            "default": true,
            "description": "Whether to enable this gateway",
            "type": "boolean"
          },
          "enable_stats": {
            "default": true,
            "description": "Whether to enable client process statistic",
            "type": "boolean"
          },
          "idle_timeout": {
            "default": "30s",
            "description": "The idle time of the client connection process. It has two purposes:</br>  1. A newly created client process that does not receive any client requests after that time will be closed directly.</br>  2. A running client process that does not receive any client requests after this time will go into hibernation to save resources.",
            "example": "12m",
            "type": "string"
          },
          "clientinfo_override": {
            "description": "ClientInfo override.",
            "$ref": "#/components/schemas/gateway.clientinfo_override"
          }
        },
        "type": "object"
      },
      "emqx_gateway_api.stomp": {
        "properties": {
          "name": {
            "description": "Gateway Name",
            "enum": [
              "stomp"
            ],
            "type": "string"
          },
          "frame": {
            "$ref": "#/components/schemas/gateway.stomp_frame"
          },
          "mountpoint": {
            "default": "",
            "description": " ",
            "type": "string"
          },
          "enable": {
            "default": true,
            "description": "Whether to enable this gateway",
            "type": "boolean"
          },
          "enable_stats": {
            "default": true,
            "description": "Whether to enable client process statistic",
            "type": "boolean"
          },
          "idle_timeout": {
            "default": "30s",
            "description": "The idle time of the client connection process. It has two purposes:</br>  1. A newly created client process that does not receive any client requests after that time will be closed directly.</br>  2. A running client process that does not receive any client requests after this time will go into hibernation to save resources.",
            "example": "12m",
            "type": "string"
          },
          "clientinfo_override": {
            "description": "ClientInfo override.",
            "$ref": "#/components/schemas/gateway.clientinfo_override"
          },
          "authentication": {
            "description": "Default authentication configs for all the gateway listeners. For per-listener overrides see <code>authentication</code></br> in listener configs",
            "oneOf": [
              {
                "$ref": "#/components/schemas/authn-scram-builtin_db.authentication"
              },
              {
                "$ref": "#/components/schemas/authn-jwt.jwks"
              },
              {
                "$ref": "#/components/schemas/authn-jwt.public-key"
              },
              {
                "$ref": "#/components/schemas/authn-jwt.hmac-based"
              },
              {
                "$ref": "#/components/schemas/authn-http.post"
              },
              {
                "$ref": "#/components/schemas/authn-http.get"
              },
              {
                "$ref": "#/components/schemas/authn-redis.sentinel"
              },
              {
                "$ref": "#/components/schemas/authn-redis.cluster"
              },
              {
                "$ref": "#/components/schemas/authn-redis.standalone"
              },
              {
                "$ref": "#/components/schemas/authn-mongodb.sharded-cluster"
              },
              {
                "$ref": "#/components/schemas/authn-mongodb.replica-set"
              },
              {
                "$ref": "#/components/schemas/authn-mongodb.standalone"
              },
              {
                "$ref": "#/components/schemas/authn-postgresql.authentication"
              },
              {
                "$ref": "#/components/schemas/authn-mysql.authentication"
              },
              {
                "$ref": "#/components/schemas/authn-builtin_db.authentication"
              }
            ]
          },
          "listeners": {
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/emqx_gateway_api.ssl_listener"
                },
                {
                  "$ref": "#/components/schemas/emqx_gateway_api.tcp_listener"
                }
              ]
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "emqx_authz_api_mnesia.rules_for_username": {
        "required": [
          "username"
        ],
        "properties": {
          "rules": {
            "items": {
              "$ref": "#/components/schemas/emqx_authz_api_mnesia.rule_item"
            },
            "type": "array"
          },
          "username": {
            "description": "Username",
            "example": "user1",
            "type": "string"
          }
        },
        "type": "object"
      },
      "emqx_gateway_api_clients.exproto_client": {
        "properties": {
          "node": {
            "description": "Name of the node to which the client is connected",
            "type": "string"
          },
          "clientid": {
            "description": "Client ID",
            "type": "string"
          },
          "username": {
            "description": "Username of client when connecting",
            "type": "string"
          },
          "mountpoint": {
            "description": "Topic mountpoint",
            "type": "string"
          },
          "proto_name": {
            "description": "Client protocol name",
            "type": "string"
          },
          "proto_ver": {
            "description": "Protocol version used by the client",
            "type": "string"
          },
          "ip_address": {
            "description": "Client's IP address",
            "type": "string"
          },
          "port": {
            "description": "Client's port",
            "type": "integer"
          },
          "is_bridge": {
            "description": "Indicates whether the client is connected via bridge",
            "type": "boolean"
          },
          "connected_at": {
            "description": "Client connection time",
            "oneOf": [
              {
                "description": "epoch-millisecond",
                "example": 1640995200000,
                "type": "integer"
              },
              {
                "example": "2022-01-01T00:00:00.000Z",
                "format": "date-time",
                "type": "string"
              }
            ]
          },
          "disconnected_at": {
            "description": "Client offline time, This field is only valid and returned when connected is false",
            "oneOf": [
              {
                "description": "epoch-millisecond",
                "example": 1640995200000,
                "type": "integer"
              },
              {
                "example": "2022-01-01T00:00:00.000Z",
                "format": "date-time",
                "type": "string"
              }
            ]
          },
          "connected": {
            "description": "Whether the client is connected",
            "type": "boolean"
          },
          "keepalive": {
            "description": "Keepalive time, with the unit of second",
            "type": "integer"
          },
          "clean_start": {
            "description": "Indicate whether the client is using a brand new session",
            "type": "boolean"
          },
          "expiry_interval": {
            "description": "Session expiration interval, with the unit of second",
            "type": "integer"
          },
          "created_at": {
            "description": "Session creation time",
            "oneOf": [
              {
                "description": "epoch-millisecond",
                "example": 1640995200000,
                "type": "integer"
              },
              {
                "example": "2022-01-01T00:00:00.000Z",
                "format": "date-time",
                "type": "string"
              }
            ]
          },
          "subscriptions_cnt": {
            "description": "Number of subscriptions established by this client",
            "type": "integer"
          },
          "subscriptions_max": {
            "description": "Maximum number of subscriptions allowed by this client",
            "type": "integer"
          },
          "inflight_cnt": {
            "description": "Current length of inflight",
            "type": "integer"
          },
          "inflight_max": {
            "description": "Maximum length of inflight",
            "type": "integer"
          },
          "mqueue_len": {
            "description": "Current length of message queue",
            "type": "integer"
          },
          "mqueue_max": {
            "description": "Maximum length of message queue",
            "type": "integer"
          },
          "mqueue_dropped": {
            "description": "Number of messages dropped by the message queue due to exceeding the length",
            "type": "integer"
          },
          "awaiting_rel_cnt": {
            "description": "Number of awaiting acknowledge packet",
            "type": "integer"
          },
          "awaiting_rel_max": {
            "description": "Maximum allowed number of awaiting PUBREC packet",
            "type": "integer"
          },
          "recv_oct": {
            "description": "Number of bytes received",
            "type": "integer"
          },
          "recv_cnt": {
            "description": "Number of socket packets received",
            "type": "integer"
          },
          "recv_pkt": {
            "description": "Number of protocol packets received",
            "type": "integer"
          },
          "recv_msg": {
            "description": "Number of message packets received",
            "type": "integer"
          },
          "send_oct": {
            "description": "Number of bytes sent",
            "type": "integer"
          },
          "send_cnt": {
            "description": "Number of socket packets sent",
            "type": "integer"
          },
          "send_pkt": {
            "description": "Number of protocol packets sent",
            "type": "integer"
          },
          "send_msg": {
            "description": "Number of message packets sent",
            "type": "integer"
          },
          "mailbox_len": {
            "description": "Process mailbox size",
            "type": "integer"
          },
          "heap_size": {
            "description": "Process heap size with the unit of byte",
            "type": "integer"
          },
          "reductions": {
            "description": "Erlang reduction",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "emqx_authz_api_schema.mongo_sharded": {
        "required": [
          "database",
          "servers",
          "mongo_type",
          "collection",
          "type"
        ],
        "properties": {
          "enable": {
            "default": true,
            "description": "Set to <code>true</code> or <code>false</code> to disable this ACL provider",
            "type": "boolean"
          },
          "type": {
            "default": "mongodb",
            "description": "Backend type.",
            "enum": [
              "mongodb"
            ],
            "type": "string"
          },
          "collection": {
            "description": "`MongoDB` collection containing the authorization data.",
            "type": "string"
          },
          "filter": {
            "default": {},
            "description": "</br>Conditional expression that defines the filter condition in the query.</br>Filter supports the following placeholders:</br> - <code>${username}</code>: Will be replaced at runtime with <code>Username</code> used by the client when connecting</br> - <code>${clientid}</code>: Will be replaced at runtime with <code>Client ID</code> used by the client when connecting</br>",
            "example": {},
            "type": "object"
          },
          "mongo_type": {
            "default": "sharded",
            "description": "Sharded cluster.",
            "enum": [
              "sharded"
            ],
            "type": "string"
          },
          "servers": {
            "description": "</br>A Node list for Cluster to connect to. The nodes should be separated with commas, such as: `Node[,Node].`</br>For each Node should be: The IPv4 or IPv6 address or the hostname to connect to.</br>A host entry has the following form: `Host[:Port]`.</br>The MongoDB default port 27017 is used if `[:Port]` is not specified.</br>",
            "items": {
              "example": "any",
              "type": "string"
            },
            "type": "array"
          },
          "w_mode": {
            "default": "unsafe",
            "description": "Write mode.",
            "enum": [
              "unsafe",
              "safe"
            ],
            "type": "string"
          },
          "srv_record": {
            "default": false,
            "description": "Use DNS SRV record.",
            "type": "boolean"
          },
          "pool_size": {
            "default": 8,
            "description": "Size of the connection pool.",
            "minimum": 1,
            "type": "integer"
          },
          "username": {
            "description": "EMQX's username in the external database.",
            "type": "string"
          },
          "password": {
            "description": "EMQX's password in the external database.",
            "type": "string"
          },
          "auth_source": {
            "description": "Database name associated with the user's credentials.",
            "type": "string"
          },
          "database": {
            "description": "Database name.",
            "type": "string"
          },
          "topology": {
            "$ref": "#/components/schemas/emqx_connector_mongo.topology"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/broker.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "emqx_conf_schema.cluster_etcd": {
        "properties": {
          "server": {
            "description": "List of endpoint URLs of the etcd cluster",
            "example": "item1,item2",
            "readOnly": true,
            "type": "string"
          },
          "prefix": {
            "default": "emqxcl",
            "description": "Key prefix used for EMQX service discovery.",
            "readOnly": true,
            "type": "string"
          },
          "node_ttl": {
            "default": "1m",
            "description": "Expiration time of the etcd key associated with the node.</br>It is refreshed automatically, as long as the node is alive.</br>          ",
            "example": "12m",
            "readOnly": true,
            "type": "string"
          },
          "ssl": {
            "description": "Options for the TLS connection to the etcd cluster.",
            "readOnly": true,
            "$ref": "#/components/schemas/broker.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "broker.shared_subscription_group": {
        "properties": {
          "strategy": {
            "default": "random",
            "description": "Dispatch strategy for shared subscription.</br>- `random`: dispatch the message to a random selected subscriber</br>- `round_robin`: select the subscribers in a round-robin manner</br>- `sticky`: always use the last selected subscriber to dispatch,</br>until the subscriber disconnects.</br>- `hash`: select the subscribers by the hash of `clientIds`</br>- `local`: send to a random local subscriber. If local</br>subscriber was not found, send to a random subscriber cluster-wide</br>",
            "enum": [
              "random",
              "round_robin",
              "sticky",
              "local",
              "hash_topic",
              "hash_clientid"
            ],
            "type": "string"
          }
        },
        "type": "object"
      },
      "listeners.wss_required_bind": {
        "required": [
          "bind",
          "id",
          "type"
        ],
        "properties": {
          "type": {
            "description": "Listener type",
            "enum": [
              "wss"
            ],
            "type": "string"
          },
          "running": {
            "description": "Listener status",
            "type": "boolean"
          },
          "id": {
            "description": "Listener id",
            "type": "string"
          },
          "current_connections": {
            "description": "Current connections",
            "minimum": 0,
            "type": "integer"
          },
          "enabled": {
            "default": true,
            "description": "</br>Enable listener.</br>",
            "type": "boolean"
          },
          "bind": {
            "default": 8084,
            "description": "</br>IP address and port for the listening socket.</br>",
            "oneOf": [
              {
                "type": "integer"
              },
              {
                "example": "127.0.0.1:80",
                "type": "string"
              }
            ]
          },
          "acceptors": {
            "default": 16,
            "description": "</br>The size of the listener's receiving pool.</br>",
            "minimum": 1,
            "type": "integer"
          },
          "max_connections": {
            "default": "infinity",
            "description": "</br>The maximum number of concurrent connections allowed by the listener.</br>",
            "oneOf": [
              {
                "minimum": 1,
                "type": "integer"
              },
              {
                "enum": [
                  "infinity"
                ],
                "type": "string"
              }
            ]
          },
          "mountpoint": {
            "default": "",
            "description": "</br>When publishing or subscribing, prefix all topics with a mountpoint string.</br>The prefixed string will be removed from the topic name when the message</br>is delivered to the subscriber. The mountpoint is a way that users can use</br>to implement isolation of message routing between different listeners.</br>For example if a client A subscribes to `t` with `listeners.tcp.\\<name>.mountpoint`</br>set to `some_tenant`, then the client actually subscribes to the topic</br>`some_tenant/t`. Similarly, if another client B (connected to the same listener</br>as the client A) sends a message to topic `t`, the message is routed</br>to all the clients subscribed `some_tenant/t`, so client A will receive the</br>message, with topic name `t`.</br>Set to `\"\"` to disable the feature.</br></br>Variables in mountpoint string:</br>  - <code>${clientid}</code>: clientid</br>  - <code>${username}</code>: username</br>",
            "type": "string"
          },
          "zone": {
            "default": "default",
            "description": "</br>The configuration zone to which the listener belongs.</br>",
            "type": "string"
          },
          "limiter": {
            "default": {
              "connection": "default"
            },
            "description": "</br>Type of the rate limit.</br>",
            "properties": {
              "$ratelimit_name": {
                "example": "retainer",
                "type": "string"
              }
            },
            "type": "object"
          },
          "enable_authn": {
            "default": true,
            "description": "</br>Set <code>true</code> (default) to enable client authentication on this listener.</br>When set to <code>false</code> clients will be allowed to connect without authentication.</br>",
            "type": "boolean"
          },
          "access_rules": {
            "default": [
              "allow all"
            ],
            "description": "</br>The access control rules for this listener.</br>See: https://github.com/emqtt/esockd#allowdeny</br>",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "proxy_protocol": {
            "default": false,
            "description": "</br>Enable the Proxy Protocol V1/2 if the EMQX cluster is deployed behind HAProxy or Nginx.</br>See: https://www.haproxy.com/blog/haproxy/proxy-protocol/</br>",
            "type": "boolean"
          },
          "proxy_protocol_timeout": {
            "default": "3s",
            "description": "</br>Timeout for proxy protocol. EMQX will close the TCP connection if proxy protocol packet is not received within the timeout.</br>",
            "example": "12m",
            "type": "string"
          },
          "tcp_options": {
            "$ref": "#/components/schemas/broker.tcp_opts"
          },
          "ssl_options": {
            "$ref": "#/components/schemas/broker.listener_wss_opts"
          },
          "websocket": {
            "$ref": "#/components/schemas/broker.ws_opts"
          }
        },
        "type": "object"
      },
      "emqx_authz_api_schema.built_in_database": {
        "required": [
          "type"
        ],
        "properties": {
          "enable": {
            "default": true,
            "description": "Set to <code>true</code> or <code>false</code> to disable this ACL provider",
            "type": "boolean"
          },
          "type": {
            "default": "built_in_database",
            "description": "Backend type.",
            "enum": [
              "built_in_database"
            ],
            "type": "string"
          }
        },
        "type": "object"
      },
      "emqx_mgmt_api_stats.node_stats_data": {
        "properties": {
          "channels.count": {
            "description": "sessions.count",
            "example": 0,
            "minimum": 0,
            "type": "integer"
          },
          "channels.max": {
            "description": "session.max",
            "example": 0,
            "minimum": 0,
            "type": "integer"
          },
          "connections.count": {
            "description": "Number of current connections",
            "example": 0,
            "minimum": 0,
            "type": "integer"
          },
          "connections.max": {
            "description": "Historical maximum number of connections",
            "example": 0,
            "minimum": 0,
            "type": "integer"
          },
          "delayed.count": {
            "description": "Number of delayed messages",
            "example": 0,
            "minimum": 0,
            "type": "integer"
          },
          "delayed.max": {
            "description": "Historical maximum number of delayed messages",
            "example": 0,
            "minimum": 0,
            "type": "integer"
          },
          "live_connections.count": {
            "description": "Number of current live connections",
            "example": 0,
            "minimum": 0,
            "type": "integer"
          },
          "live_connections.max": {
            "description": "Historical maximum number of live connections",
            "example": 0,
            "minimum": 0,
            "type": "integer"
          },
          "retained.count": {
            "description": "Number of currently retained messages",
            "example": 0,
            "minimum": 0,
            "type": "integer"
          },
          "retained.max": {
            "description": "Historical maximum number of retained messages",
            "example": 0,
            "minimum": 0,
            "type": "integer"
          },
          "sessions.count": {
            "description": "Number of current sessions",
            "example": 0,
            "minimum": 0,
            "type": "integer"
          },
          "sessions.max": {
            "description": "Historical maximum number of sessions",
            "example": 0,
            "minimum": 0,
            "type": "integer"
          },
          "suboptions.count": {
            "description": "subscriptions.count",
            "example": 0,
            "minimum": 0,
            "type": "integer"
          },
          "suboptions.max": {
            "description": "subscriptions.max",
            "example": 0,
            "minimum": 0,
            "type": "integer"
          },
          "subscribers.count": {
            "description": "Number of current subscribers",
            "example": 0,
            "minimum": 0,
            "type": "integer"
          },
          "subscribers.max": {
            "description": "Historical maximum number of subscribers",
            "example": 0,
            "minimum": 0,
            "type": "integer"
          },
          "subscriptions.count": {
            "description": "Number of current subscriptions, including shared subscriptions",
            "example": 0,
            "minimum": 0,
            "type": "integer"
          },
          "subscriptions.max": {
            "description": "Historical maximum number of subscriptions",
            "example": 0,
            "minimum": 0,
            "type": "integer"
          },
          "subscriptions.shared.count": {
            "description": "Number of current shared subscriptions",
            "example": 0,
            "minimum": 0,
            "type": "integer"
          },
          "subscriptions.shared.max": {
            "description": "Historical maximum number of shared subscriptions",
            "example": 0,
            "minimum": 0,
            "type": "integer"
          },
          "topics.count": {
            "description": "Number of current topics",
            "example": 0,
            "minimum": 0,
            "type": "integer"
          },
          "topics.max": {
            "description": "Historical maximum number of topics",
            "example": 0,
            "minimum": 0,
            "type": "integer"
          }
        },
        "type": "object"
      },
      "emqx_rule_api_schema.rule_info": {
        "required": [
          "sql",
          "id"
        ],
        "properties": {
          "id": {
            "description": "The ID of the rule",
            "example": "293fb66f",
            "type": "string"
          },
          "metrics": {
            "description": "The metrics of the rule",
            "$ref": "#/components/schemas/emqx_rule_api_schema.metrics"
          },
          "node_metrics": {
            "description": "The metrics of the rule for each node",
            "items": {
              "$ref": "#/components/schemas/emqx_rule_api_schema.node_metrics"
            },
            "type": "array"
          },
          "from": {
            "description": "The topics of the rule",
            "example": "t/#",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "created_at": {
            "description": "The created time of the rule",
            "example": "2021-12-01T15:00:43.153+08:00",
            "type": "string"
          },
          "name": {
            "default": "",
            "description": "The name of the rule",
            "example": "foo",
            "type": "string"
          },
          "sql": {
            "description": "</br>SQL query to transform the messages.</br>Example: <code>SELECT * FROM \"test/topic\" WHERE payload.x = 1</code></br>",
            "example": "SELECT * FROM \"test/topic\" WHERE payload.x = 1",
            "type": "string"
          },
          "actions": {
            "default": "",
            "description": "</br>A list of actions of the rule.</br>An action can be a string that refers to the channel ID of an EMQX bridge, or an object</br>that refers to a function.</br>There a some built-in functions like \"republish\" and \"console\", and we also support user</br>provided functions in the format: \"{module}:{function}\".</br>The actions in the list are executed sequentially.</br>This means that if one of the action is executing slowly, all the following actions will not</br>be executed until it returns.</br>If one of the action crashed, all other actions come after it will still be executed, in the</br>original order.</br>If there's any error when running an action, there will be an error message, and the 'failure'</br>counter of the function action or the bridge channel will increase.</br>",
            "example": [
              "webhook:my_webhook",
              {
                "args": {
                  "payload": "${payload}",
                  "topic": "t/1"
                },
                "function": "republish"
              },
              {
                "function": "console"
              }
            ],
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/rule_engine.user_provided_function"
                },
                {
                  "$ref": "#/components/schemas/rule_engine.builtin_action_console"
                },
                {
                  "$ref": "#/components/schemas/rule_engine.builtin_action_republish"
                },
                {
                  "type": "string"
                }
              ]
            },
            "type": "array"
          },
          "enable": {
            "default": true,
            "description": "Enable or disable the rule",
            "type": "boolean"
          },
          "description": {
            "default": "",
            "description": "The description of the rule",
            "example": "Some description",
            "type": "string"
          }
        },
        "type": "object"
      },
      "rule_engine.republish_args": {
        "required": [
          "topic"
        ],
        "properties": {
          "topic": {
            "description": "</br>The target topic of message to be re-published.</br>Template with variables is allowed, see description of the 'republish_args'.</br>",
            "example": "a/1",
            "type": "string"
          },
          "qos": {
            "default": "${qos}",
            "description": "</br>The qos of the message to be re-published.</br>Template with variables is allowed, see description of the 'republish_args'.</br>Defaults to ${qos}. If variable ${qos} is not found from the selected result of the rule,</br>0 is used.</br>",
            "example": "${qos}",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "enum": [
                  0,
                  1,
                  2
                ],
                "type": "string"
              }
            ]
          },
          "retain": {
            "default": "${retain}",
            "description": "</br>The 'retain' flag of the message to be re-published.</br>Template with variables is allowed, see description of the 'republish_args'.</br>Defaults to ${retain}. If variable ${retain} is not found from the selected result</br>of the rule, false is used.</br>",
            "example": "${retain}",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "boolean"
              }
            ]
          },
          "payload": {
            "default": "${payload}",
            "description": "</br>The payload of the message to be re-published.</br>Template with variables is allowed, see description of the 'republish_args'.</br>Defaults to ${payload}. If variable ${payload} is not found from the selected result</br>of the rule, then the string \"undefined\" is used.</br>",
            "example": "${payload}",
            "type": "string"
          }
        },
        "type": "object"
      },
      "authz.node_metrics": {
        "properties": {
          "node": {
            "description": "Node name.",
            "example": "emqx@127.0.0.1",
            "type": "string"
          },
          "metrics": {
            "description": "The metrics of the resource.",
            "$ref": "#/components/schemas/authz.metrics"
          }
        },
        "type": "object"
      },
      "emqx_rule_api_schema.metrics": {
        "properties": {
          "matched": {
            "description": "How much times the FROM clause of the SQL is matched.",
            "minimum": 0,
            "type": "integer"
          },
          "matched.rate": {
            "description": "The rate of matched, times/second",
            "type": "number"
          },
          "matched.rate.max": {
            "description": "The max rate of matched, times/second",
            "type": "number"
          },
          "matched.rate.last5m": {
            "description": "The average rate of matched in last 5 minutes, times/second",
            "type": "number"
          },
          "passed": {
            "description": "How much times the SQL is passed",
            "minimum": 0,
            "type": "integer"
          },
          "failed": {
            "description": "How much times the SQL is failed",
            "minimum": 0,
            "type": "integer"
          },
          "failed.exception": {
            "description": "How much times the SQL is failed due to exceptions. This may because of a crash when calling a SQL function, or trying to do arithmetic operation on undefined variables",
            "minimum": 0,
            "type": "integer"
          },
          "failed.unknown": {
            "description": "How much times the SQL is failed due to an unknown error.",
            "minimum": 0,
            "type": "integer"
          },
          "actions.total": {
            "description": "How much times the actions are called by the rule. This value may several times of 'matched', depending on the number of the actions of the rule.",
            "minimum": 0,
            "type": "integer"
          },
          "actions.success": {
            "description": "How much times the rule success to call the actions.",
            "minimum": 0,
            "type": "integer"
          },
          "actions.failed": {
            "description": "How much times the rule failed to call the actions.",
            "minimum": 0,
            "type": "integer"
          },
          "actions.failed.out_of_service": {
            "description": "How much times the rule failed to call actions due to the action is out of service. For example, a bridge is disabled or stopped.",
            "minimum": 0,
            "type": "integer"
          },
          "actions.failed.unknown": {
            "description": "How much times the rule failed to call actions due to to an unknown error.",
            "minimum": 0,
            "type": "integer"
          }
        },
        "type": "object"
      },
      "bridge.metrics": {
        "properties": {
          "matched": {
            "description": "Count of this bridge is queried",
            "type": "integer"
          },
          "success": {
            "description": "Count of query success",
            "type": "integer"
          },
          "failed": {
            "description": "Count of query failed",
            "type": "integer"
          },
          "rate": {
            "description": "The rate of matched, times/second",
            "type": "number"
          },
          "rate_max": {
            "description": "The max rate of matched, times/second",
            "type": "number"
          },
          "rate_last5m": {
            "description": "The average rate of matched in the last 5 minutes, times/second",
            "type": "number"
          }
        },
        "type": "object"
      },
      "emqx_rule_api_schema.ctx_acked": {
        "required": [
          "event_type"
        ],
        "properties": {
          "event_type": {
            "description": "Event Type",
            "enum": [
              "message_acked"
            ],
            "type": "string"
          },
          "id": {
            "description": "Message ID",
            "type": "string"
          },
          "from_clientid": {
            "description": "The Client ID",
            "type": "string"
          },
          "from_username": {
            "description": "The User Name",
            "type": "string"
          },
          "clientid": {
            "description": "The Client ID",
            "type": "string"
          },
          "username": {
            "description": "The User Name",
            "type": "string"
          },
          "payload": {
            "description": "The Message Payload",
            "type": "string"
          },
          "peerhost": {
            "description": "The IP Address of the Peer Client",
            "type": "string"
          },
          "topic": {
            "description": "Message Topic",
            "type": "string"
          },
          "publish_received_at": {
            "description": "The Time that this Message is Received",
            "type": "integer"
          },
          "qos": {
            "description": "The Message QoS",
            "enum": [
              0,
              1,
              2
            ],
            "type": "string"
          }
        },
        "type": "object"
      },
      "dashboard.error_code": {
        "properties": {
          "code": {
            "description": "Code Name",
            "type": "string"
          },
          "description": {
            "description": "Description",
            "type": "string"
          }
        },
        "type": "object"
      },
      "listeners.wss_not_required_bind": {
        "required": [
          "id",
          "type"
        ],
        "properties": {
          "type": {
            "description": "Listener type",
            "enum": [
              "wss"
            ],
            "type": "string"
          },
          "running": {
            "description": "Listener status",
            "type": "boolean"
          },
          "id": {
            "description": "Listener id",
            "type": "string"
          },
          "current_connections": {
            "description": "Current connections",
            "minimum": 0,
            "type": "integer"
          },
          "bind": {
            "default": 8084,
            "description": "</br>IP address and port for the listening socket.</br>",
            "oneOf": [
              {
                "type": "integer"
              },
              {
                "example": "127.0.0.1:80",
                "type": "string"
              }
            ]
          },
          "enabled": {
            "default": true,
            "description": "</br>Enable listener.</br>",
            "type": "boolean"
          },
          "acceptors": {
            "default": 16,
            "description": "</br>The size of the listener's receiving pool.</br>",
            "minimum": 1,
            "type": "integer"
          },
          "max_connections": {
            "default": "infinity",
            "description": "</br>The maximum number of concurrent connections allowed by the listener.</br>",
            "oneOf": [
              {
                "minimum": 1,
                "type": "integer"
              },
              {
                "enum": [
                  "infinity"
                ],
                "type": "string"
              }
            ]
          },
          "mountpoint": {
            "default": "",
            "description": "</br>When publishing or subscribing, prefix all topics with a mountpoint string.</br>The prefixed string will be removed from the topic name when the message</br>is delivered to the subscriber. The mountpoint is a way that users can use</br>to implement isolation of message routing between different listeners.</br>For example if a client A subscribes to `t` with `listeners.tcp.\\<name>.mountpoint`</br>set to `some_tenant`, then the client actually subscribes to the topic</br>`some_tenant/t`. Similarly, if another client B (connected to the same listener</br>as the client A) sends a message to topic `t`, the message is routed</br>to all the clients subscribed `some_tenant/t`, so client A will receive the</br>message, with topic name `t`.</br>Set to `\"\"` to disable the feature.</br></br>Variables in mountpoint string:</br>  - <code>${clientid}</code>: clientid</br>  - <code>${username}</code>: username</br>",
            "type": "string"
          },
          "zone": {
            "default": "default",
            "description": "</br>The configuration zone to which the listener belongs.</br>",
            "type": "string"
          },
          "limiter": {
            "default": {
              "connection": "default"
            },
            "description": "</br>Type of the rate limit.</br>",
            "properties": {
              "$ratelimit_name": {
                "example": "retainer",
                "type": "string"
              }
            },
            "type": "object"
          },
          "enable_authn": {
            "default": true,
            "description": "</br>Set <code>true</code> (default) to enable client authentication on this listener.</br>When set to <code>false</code> clients will be allowed to connect without authentication.</br>",
            "type": "boolean"
          },
          "access_rules": {
            "default": [
              "allow all"
            ],
            "description": "</br>The access control rules for this listener.</br>See: https://github.com/emqtt/esockd#allowdeny</br>",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "proxy_protocol": {
            "default": false,
            "description": "</br>Enable the Proxy Protocol V1/2 if the EMQX cluster is deployed behind HAProxy or Nginx.</br>See: https://www.haproxy.com/blog/haproxy/proxy-protocol/</br>",
            "type": "boolean"
          },
          "proxy_protocol_timeout": {
            "default": "3s",
            "description": "</br>Timeout for proxy protocol. EMQX will close the TCP connection if proxy protocol packet is not received within the timeout.</br>",
            "example": "12m",
            "type": "string"
          },
          "tcp_options": {
            "$ref": "#/components/schemas/broker.tcp_opts"
          },
          "ssl_options": {
            "$ref": "#/components/schemas/broker.listener_wss_opts"
          },
          "websocket": {
            "$ref": "#/components/schemas/broker.ws_opts"
          }
        },
        "type": "object"
      },
      "emqx_authz_api_schema.postgresql": {
        "required": [
          "database",
          "server",
          "query",
          "type"
        ],
        "properties": {
          "enable": {
            "default": true,
            "description": "Set to <code>true</code> or <code>false</code> to disable this ACL provider",
            "type": "boolean"
          },
          "type": {
            "default": "postgresql",
            "description": "Backend type.",
            "enum": [
              "postgresql"
            ],
            "type": "string"
          },
          "query": {
            "description": "Database query used to retrieve authorization data.",
            "type": "string"
          },
          "server": {
            "description": "</br>The IPv4 or IPv6 address or the hostname to connect to.</br>A host entry has the following form: `Host[:Port]`.</br>The PostgreSQL default port 5432 is used if `[:Port]` is not specified.</br>",
            "example": "127.0.0.1:80",
            "type": "string"
          },
          "database": {
            "description": "Database name.",
            "type": "string"
          },
          "pool_size": {
            "default": 8,
            "description": "Size of the connection pool.",
            "minimum": 1,
            "type": "integer"
          },
          "username": {
            "description": "EMQX's username in the external database.",
            "type": "string"
          },
          "password": {
            "description": "EMQX's password in the external database.",
            "type": "string"
          },
          "auto_reconnect": {
            "default": true,
            "description": "Enable automatic reconnect to the database.",
            "type": "boolean"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/broker.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "emqx_mgmt_api_metrics.aggregated_metrics": {
        "properties": {
          "actions.failure": {
            "description": "Number of failure executions of the rule engine action",
            "minimum": 0,
            "type": "integer"
          },
          "actions.success": {
            "description": "Number of successful executions of the rule engine action",
            "minimum": 0,
            "type": "integer"
          },
          "bytes.received": {
            "description": "Number of bytes received ",
            "minimum": 0,
            "type": "integer"
          },
          "bytes.sent": {
            "description": "Number of bytes sent on this connection",
            "minimum": 0,
            "type": "integer"
          },
          "client.auth.anonymous": {
            "description": "Number of clients who log in anonymously",
            "minimum": 0,
            "type": "integer"
          },
          "client.authenticate": {
            "description": "Number of client authentications",
            "minimum": 0,
            "type": "integer"
          },
          "client.check_authz": {
            "description": "Number of Authorization rule checks",
            "minimum": 0,
            "type": "integer"
          },
          "client.connack": {
            "description": "Number of CONNACK packet sent",
            "minimum": 0,
            "type": "integer"
          },
          "client.connect": {
            "description": "Number of client connections",
            "minimum": 0,
            "type": "integer"
          },
          "client.connected": {
            "description": "Number of successful client connections",
            "minimum": 0,
            "type": "integer"
          },
          "client.disconnected": {
            "description": "Number of client disconnects",
            "minimum": 0,
            "type": "integer"
          },
          "client.subscribe": {
            "description": "Number of client subscriptions",
            "minimum": 0,
            "type": "integer"
          },
          "client.unsubscribe": {
            "description": "Number of client unsubscriptions",
            "minimum": 0,
            "type": "integer"
          },
          "delivery.dropped": {
            "description": "Total number of discarded messages when sending",
            "minimum": 0,
            "type": "integer"
          },
          "delivery.dropped.expired": {
            "description": "Number of messages dropped due to message expiration on sending",
            "minimum": 0,
            "type": "integer"
          },
          "delivery.dropped.no_local": {
            "description": "Number of messages that were dropped due to the No Local subscription option when sending",
            "minimum": 0,
            "type": "integer"
          },
          "delivery.dropped.qos0_msg": {
            "description": "Number of messages with QoS 0 that were dropped because the message queue was full when sending",
            "minimum": 0,
            "type": "integer"
          },
          "delivery.dropped.queue_full": {
            "description": "Number of messages with a non-zero QoS that were dropped because the message queue was full when sending",
            "minimum": 0,
            "type": "integer"
          },
          "delivery.dropped.too_large": {
            "description": "The number of messages that were dropped because the length exceeded the limit when sending",
            "minimum": 0,
            "type": "integer"
          },
          "messages.acked": {
            "description": "Number of received PUBACK and PUBREC packet",
            "minimum": 0,
            "type": "integer"
          },
          "messages.delayed": {
            "description": "Number of delay-published messages",
            "minimum": 0,
            "type": "integer"
          },
          "messages.delivered": {
            "description": "Number of messages forwarded to the subscription process internally",
            "minimum": 0,
            "type": "integer"
          },
          "messages.dropped": {
            "description": "Total number of messages dropped before forwarding to the subscription process",
            "minimum": 0,
            "type": "integer"
          },
          "messages.dropped.await_pubrel_timeout": {
            "description": "Number of messages dropped due to waiting PUBREL timeout",
            "minimum": 0,
            "type": "integer"
          },
          "messages.dropped.no_subscribers": {
            "description": "Number of messages dropped due to no subscribers",
            "minimum": 0,
            "type": "integer"
          },
          "messages.forward": {
            "description": "Number of messages forwarded to other nodes",
            "minimum": 0,
            "type": "integer"
          },
          "messages.publish": {
            "description": "Number of messages published in addition to system messages",
            "minimum": 0,
            "type": "integer"
          },
          "messages.qos0.received": {
            "description": "Number of QoS 0 messages received from clients",
            "minimum": 0,
            "type": "integer"
          },
          "messages.qos0.sent": {
            "description": "Number of QoS 0 messages sent to clients",
            "minimum": 0,
            "type": "integer"
          },
          "messages.qos1.received": {
            "description": "Number of QoS 1 messages received from clients",
            "minimum": 0,
            "type": "integer"
          },
          "messages.qos1.sent": {
            "description": "Number of QoS 1 messages sent to clients",
            "minimum": 0,
            "type": "integer"
          },
          "messages.qos2.received": {
            "description": "Number of QoS 2 messages received from clients",
            "minimum": 0,
            "type": "integer"
          },
          "messages.qos2.sent": {
            "description": "Number of QoS 2 messages sent to clients",
            "minimum": 0,
            "type": "integer"
          },
          "messages.received": {
            "description": "Number of messages received from the client, equal to the sum of messages.qos0.received\fmessages.qos1.received and messages.qos2.received",
            "minimum": 0,
            "type": "integer"
          },
          "messages.retained": {
            "description": "Number of retained messages",
            "minimum": 0,
            "type": "integer"
          },
          "messages.sent": {
            "description": "Number of messages sent to the client, equal to the sum of messages.qos0.sent\fmessages.qos1.sent and messages.qos2.sent",
            "minimum": 0,
            "type": "integer"
          },
          "packets.auth.received": {
            "description": "Number of received AUTH packet",
            "minimum": 0,
            "type": "integer"
          },
          "packets.auth.sent": {
            "description": "Number of sent AUTH packet",
            "minimum": 0,
            "type": "integer"
          },
          "packets.connack.auth_error": {
            "description": "Number of received CONNECT packet with failed authentication",
            "minimum": 0,
            "type": "integer"
          },
          "packets.connack.error": {
            "description": "Number of received CONNECT packet with unsuccessful connections",
            "minimum": 0,
            "type": "integer"
          },
          "packets.connack.sent": {
            "description": "Number of sent CONNACK packet",
            "minimum": 0,
            "type": "integer"
          },
          "packets.connect.received": {
            "description": "Number of received CONNECT packet",
            "minimum": 0,
            "type": "integer"
          },
          "packets.disconnect.received": {
            "description": "Number of received DISCONNECT packet",
            "minimum": 0,
            "type": "integer"
          },
          "packets.disconnect.sent": {
            "description": "Number of sent DISCONNECT packet",
            "minimum": 0,
            "type": "integer"
          },
          "packets.pingreq.received": {
            "description": "Number of received PINGREQ packet",
            "minimum": 0,
            "type": "integer"
          },
          "packets.pingresp.sent": {
            "description": "Number of sent PUBRESP packet",
            "minimum": 0,
            "type": "integer"
          },
          "packets.puback.inuse": {
            "description": "Number of received PUBACK packet with occupied identifiers",
            "minimum": 0,
            "type": "integer"
          },
          "packets.puback.missed": {
            "description": "Number of received packet with identifiers.",
            "minimum": 0,
            "type": "integer"
          },
          "packets.puback.received": {
            "description": "Number of received PUBACK packet",
            "minimum": 0,
            "type": "integer"
          },
          "packets.puback.sent": {
            "description": "Number of sent PUBACK packet",
            "minimum": 0,
            "type": "integer"
          },
          "packets.pubcomp.inuse": {
            "description": "Number of received PUBCOMP packet with occupied identifiers",
            "minimum": 0,
            "type": "integer"
          },
          "packets.pubcomp.missed": {
            "description": "Number of missed PUBCOMP packet",
            "minimum": 0,
            "type": "integer"
          },
          "packets.pubcomp.received": {
            "description": "Number of received PUBCOMP packet",
            "minimum": 0,
            "type": "integer"
          },
          "packets.pubcomp.sent": {
            "description": "Number of sent PUBCOMP packet",
            "minimum": 0,
            "type": "integer"
          },
          "packets.publish.auth_error": {
            "description": "Number of received PUBLISH packets with failed the Authorization check",
            "minimum": 0,
            "type": "integer"
          },
          "packets.publish.dropped": {
            "description": "Number of messages discarded due to the receiving limit",
            "minimum": 0,
            "type": "integer"
          },
          "packets.publish.error": {
            "description": "Number of received PUBLISH packet that cannot be published",
            "minimum": 0,
            "type": "integer"
          },
          "packets.publish.inuse": {
            "description": "Number of received PUBLISH packet with occupied identifiers",
            "minimum": 0,
            "type": "integer"
          },
          "packets.publish.received": {
            "description": "Number of received PUBLISH packet",
            "minimum": 0,
            "type": "integer"
          },
          "packets.publish.sent": {
            "description": "Number of sent PUBLISH packet",
            "minimum": 0,
            "type": "integer"
          },
          "packets.pubrec.inuse": {
            "description": "Number of received PUBREC packet with occupied identifiers",
            "minimum": 0,
            "type": "integer"
          },
          "packets.pubrec.missed": {
            "description": "Number of received PUBREC packet with unknown identifiers",
            "minimum": 0,
            "type": "integer"
          },
          "packets.pubrec.received": {
            "description": "Number of received PUBREC packet",
            "minimum": 0,
            "type": "integer"
          },
          "packets.pubrec.sent": {
            "description": "Number of sent PUBREC packet",
            "minimum": 0,
            "type": "integer"
          },
          "packets.pubrel.missed": {
            "description": "Number of received PUBREC packet with unknown identifiers",
            "minimum": 0,
            "type": "integer"
          },
          "packets.pubrel.received": {
            "description": "Number of received PUBREL packet",
            "minimum": 0,
            "type": "integer"
          },
          "packets.pubrel.sent": {
            "description": "Number of sent PUBREL packet",
            "minimum": 0,
            "type": "integer"
          },
          "packets.received": {
            "description": "Number of received packet",
            "minimum": 0,
            "type": "integer"
          },
          "packets.sent": {
            "description": "Number of sent packet",
            "minimum": 0,
            "type": "integer"
          },
          "packets.suback.sent": {
            "description": "Number of sent SUBACK packet",
            "minimum": 0,
            "type": "integer"
          },
          "packets.subscribe.auth_error": {
            "description": "Number of received SUBACK packet with failed Authorization check",
            "minimum": 0,
            "type": "integer"
          },
          "packets.subscribe.error": {
            "description": "Number of received SUBSCRIBE packet with failed subscriptions",
            "minimum": 0,
            "type": "integer"
          },
          "packets.subscribe.received": {
            "description": "Number of received SUBSCRIBE packet",
            "minimum": 0,
            "type": "integer"
          },
          "packets.unsuback.sent": {
            "description": "Number of sent UNSUBACK packet",
            "minimum": 0,
            "type": "integer"
          },
          "packets.unsubscribe.error": {
            "description": "Number of received UNSUBSCRIBE packet with failed unsubscriptions",
            "minimum": 0,
            "type": "integer"
          },
          "packets.unsubscribe.received": {
            "description": "Number of received UNSUBSCRIBE packet",
            "minimum": 0,
            "type": "integer"
          },
          "rules.matched": {
            "description": "Number of rule matched",
            "minimum": 0,
            "type": "integer"
          },
          "session.created": {
            "description": "Number of sessions created",
            "minimum": 0,
            "type": "integer"
          },
          "session.discarded": {
            "description": "Number of sessions dropped because Clean Session or Clean Start is true",
            "minimum": 0,
            "type": "integer"
          },
          "session.resumed": {
            "description": "Number of sessions resumed because Clean Session or Clean Start is false",
            "minimum": 0,
            "type": "integer"
          },
          "session.takenover": {
            "description": "Number of sessions takenover because Clean Session or Clean Start is false",
            "minimum": 0,
            "type": "integer"
          },
          "session.terminated": {
            "description": "Number of terminated sessions",
            "minimum": 0,
            "type": "integer"
          }
        },
        "type": "object"
      },
      "auto_subscribe.auto_subscribe": {
        "properties": {
          "topics": {
            "default": "",
            "description": "After the device logs in successfully, the subscription is automatically completed for the device through the pre-defined subscription representation. Supports the use of placeholders.",
            "items": {
              "$ref": "#/components/schemas/auto_subscribe.topic"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "connector-mqtt.connector": {
        "required": [
          "server"
        ],
        "properties": {
          "mode": {
            "default": "cluster_shareload",
            "description": "</br>The mode of the MQTT Bridge.</br></br>- cluster_shareload: create an MQTT connection on each node in the emqx cluster.</br>In 'cluster_shareload' mode, the incoming load from the remote broker is shared by</br>using shared subscription.</br>Note that the 'clientid' is suffixed by the node name, this is to avoid</br>clientid conflicts between different nodes. And we can only use shared subscription</br>topic filters for 'remote_topic' of ingress connections.</br>",
            "enum": [
              "cluster_shareload"
            ],
            "type": "string"
          },
          "server": {
            "description": "The host and port of the remote MQTT broker",
            "example": "127.0.0.1:80",
            "type": "string"
          },
          "reconnect_interval": {
            "default": "15s",
            "description": "Reconnect interval. Delay for the MQTT bridge to retry establishing the connection in case of transportation failure. Time interval is a string that contains a number followed by time unit:</br>- `ms` for milliseconds,</br>- `s` for seconds,</br>- `m` for minutes,</br>- `h` for hours;</br></br>or combination of whereof: `1h5m0s`",
            "type": "string"
          },
          "proto_ver": {
            "default": "v4",
            "description": "The MQTT protocol version",
            "enum": [
              "v3",
              "v4",
              "v5"
            ],
            "type": "string"
          },
          "bridge_mode": {
            "default": false,
            "description": "</br>If enable bridge mode.</br>NOTE: This setting is only for MQTT protocol version older than 5.0, and the remote MQTT</br>broker MUST support this feature.</br>    ",
            "type": "boolean"
          },
          "username": {
            "default": "emqx",
            "description": "The username of the MQTT protocol",
            "type": "string"
          },
          "password": {
            "default": "emqx",
            "description": "The password of the MQTT protocol",
            "type": "string"
          },
          "clean_start": {
            "default": true,
            "description": "The clean-start or the clean-session of the MQTT protocol",
            "type": "boolean"
          },
          "keepalive": {
            "default": "300s",
            "description": "MQTT Keepalive. Time interval is a string that contains a number followed by time unit:</br>- `ms` for milliseconds,</br>- `s` for seconds,</br>- `m` for minutes,</br>- `h` for hours;</br></br>or combination of whereof: `1h5m0s`",
            "type": "string"
          },
          "retry_interval": {
            "default": "15s",
            "description": "Message retry interval. Delay for the MQTT bridge to retry sending the QoS1/QoS2 messages in case of ACK not received. Time interval is a string that contains a number followed by time unit:</br>- `ms` for milliseconds,</br>- `s` for seconds,</br>- `m` for minutes,</br>- `h` for hours;</br></br>or combination of whereof: `1h5m0s`",
            "type": "string"
          },
          "max_inflight": {
            "default": 32,
            "description": "Max inflight (sent, but un-acked) messages of the MQTT protocol",
            "minimum": 0,
            "type": "integer"
          },
          "replayq": {
            "$ref": "#/components/schemas/connector-mqtt.replayq"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/broker.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "emqx_authz_api_schema.redis_cluster": {
        "required": [
          "database",
          "redis_type",
          "servers",
          "cmd",
          "type"
        ],
        "properties": {
          "enable": {
            "default": true,
            "description": "Set to <code>true</code> or <code>false</code> to disable this ACL provider",
            "type": "boolean"
          },
          "type": {
            "default": "redis",
            "description": "Backend type.",
            "enum": [
              "redis"
            ],
            "type": "string"
          },
          "cmd": {
            "description": "Database query used to retrieve authorization data.",
            "example": "HGETALL mqtt_authz",
            "type": "string"
          },
          "servers": {
            "description": "</br>A Node list for Cluster to connect to. The nodes should be separated with commas, such as: `Node[,Node].`</br>For each Node should be: The IPv4 or IPv6 address or the hostname to connect to.</br>A host entry has the following form: `Host[:Port]`.</br>The MongoDB default port 27017 is used if `[:Port]` is not specified.</br>",
            "items": {
              "example": "any",
              "type": "string"
            },
            "type": "array"
          },
          "redis_type": {
            "description": "Cluster mode",
            "enum": [
              "cluster"
            ],
            "type": "string"
          },
          "pool_size": {
            "default": 8,
            "description": "Size of the connection pool.",
            "minimum": 1,
            "type": "integer"
          },
          "password": {
            "description": "EMQX's password in the external database.",
            "type": "string"
          },
          "database": {
            "default": 0,
            "description": "Redis database ID.",
            "type": "integer"
          },
          "auto_reconnect": {
            "default": true,
            "description": "Enable automatic reconnect to the database.",
            "type": "boolean"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/broker.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "connector-http.request": {
        "properties": {
          "method": {
            "description": "HTTP method.",
            "enum": [
              "post",
              "put",
              "get",
              "delete"
            ],
            "type": "string"
          },
          "path": {
            "description": "URL path.",
            "type": "string"
          },
          "body": {
            "description": "HTTP request body.",
            "type": "string"
          },
          "headers": {
            "description": "List of HTTP headers.",
            "example": {},
            "type": "object"
          },
          "request_timeout": {
            "description": "HTTP request timeout.",
            "example": "32s",
            "type": "string"
          }
        },
        "type": "object"
      },
      "broker.mqtt_ssl_listener": {
        "required": [
          "bind"
        ],
        "properties": {
          "enabled": {
            "default": true,
            "description": "</br>Enable listener.</br>",
            "type": "boolean"
          },
          "bind": {
            "default": 8883,
            "description": "</br>IP address and port for the listening socket.</br>",
            "oneOf": [
              {
                "type": "integer"
              },
              {
                "example": "127.0.0.1:80",
                "type": "string"
              }
            ]
          },
          "acceptors": {
            "default": 16,
            "description": "</br>The size of the listener's receiving pool.</br>",
            "minimum": 1,
            "type": "integer"
          },
          "max_connections": {
            "default": "infinity",
            "description": "</br>The maximum number of concurrent connections allowed by the listener.</br>",
            "oneOf": [
              {
                "minimum": 1,
                "type": "integer"
              },
              {
                "enum": [
                  "infinity"
                ],
                "type": "string"
              }
            ]
          },
          "mountpoint": {
            "default": "",
            "description": "</br>When publishing or subscribing, prefix all topics with a mountpoint string.</br>The prefixed string will be removed from the topic name when the message</br>is delivered to the subscriber. The mountpoint is a way that users can use</br>to implement isolation of message routing between different listeners.</br>For example if a client A subscribes to `t` with `listeners.tcp.\\<name>.mountpoint`</br>set to `some_tenant`, then the client actually subscribes to the topic</br>`some_tenant/t`. Similarly, if another client B (connected to the same listener</br>as the client A) sends a message to topic `t`, the message is routed</br>to all the clients subscribed `some_tenant/t`, so client A will receive the</br>message, with topic name `t`.</br>Set to `\"\"` to disable the feature.</br></br>Variables in mountpoint string:</br>  - <code>${clientid}</code>: clientid</br>  - <code>${username}</code>: username</br>",
            "type": "string"
          },
          "zone": {
            "default": "default",
            "description": "</br>The configuration zone to which the listener belongs.</br>",
            "type": "string"
          },
          "limiter": {
            "default": {
              "connection": "default"
            },
            "description": "</br>Type of the rate limit.</br>",
            "properties": {
              "$ratelimit_name": {
                "example": "retainer",
                "type": "string"
              }
            },
            "type": "object"
          },
          "enable_authn": {
            "default": true,
            "description": "</br>Set <code>true</code> (default) to enable client authentication on this listener.</br>When set to <code>false</code> clients will be allowed to connect without authentication.</br>",
            "type": "boolean"
          },
          "access_rules": {
            "default": [
              "allow all"
            ],
            "description": "</br>The access control rules for this listener.</br>See: https://github.com/emqtt/esockd#allowdeny</br>",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "proxy_protocol": {
            "default": false,
            "description": "</br>Enable the Proxy Protocol V1/2 if the EMQX cluster is deployed behind HAProxy or Nginx.</br>See: https://www.haproxy.com/blog/haproxy/proxy-protocol/</br>",
            "type": "boolean"
          },
          "proxy_protocol_timeout": {
            "default": "3s",
            "description": "</br>Timeout for proxy protocol. EMQX will close the TCP connection if proxy protocol packet is not received within the timeout.</br>",
            "example": "12m",
            "type": "string"
          },
          "authentication": {
            "description": "</br>Per-listener authentication override.</br>Authentication can be one single authenticator instance or a chain of authenticators as an array.</br>When authenticating a login (username, client ID, etc.) the authenticators are checked in the configured order.</br></br>",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/authn-scram-builtin_db.authentication"
                },
                {
                  "$ref": "#/components/schemas/authn-jwt.jwks"
                },
                {
                  "$ref": "#/components/schemas/authn-jwt.public-key"
                },
                {
                  "$ref": "#/components/schemas/authn-jwt.hmac-based"
                },
                {
                  "$ref": "#/components/schemas/authn-http.post"
                },
                {
                  "$ref": "#/components/schemas/authn-http.get"
                },
                {
                  "$ref": "#/components/schemas/authn-redis.sentinel"
                },
                {
                  "$ref": "#/components/schemas/authn-redis.cluster"
                },
                {
                  "$ref": "#/components/schemas/authn-redis.standalone"
                },
                {
                  "$ref": "#/components/schemas/authn-mongodb.sharded-cluster"
                },
                {
                  "$ref": "#/components/schemas/authn-mongodb.replica-set"
                },
                {
                  "$ref": "#/components/schemas/authn-mongodb.standalone"
                },
                {
                  "$ref": "#/components/schemas/authn-postgresql.authentication"
                },
                {
                  "$ref": "#/components/schemas/authn-mysql.authentication"
                },
                {
                  "$ref": "#/components/schemas/authn-builtin_db.authentication"
                }
              ]
            },
            "type": "array"
          },
          "tcp_options": {
            "$ref": "#/components/schemas/broker.tcp_opts"
          },
          "ssl_options": {
            "$ref": "#/components/schemas/broker.listener_ssl_opts"
          }
        },
        "type": "object"
      },
      "emqx_mgmt_api_banned.ban": {
        "required": [
          "who",
          "as"
        ],
        "properties": {
          "as": {
            "description": "Banned type clientid, username, peerhost",
            "enum": [
              "clientid",
              "username",
              "peerhost"
            ],
            "example": "username",
            "type": "string"
          },
          "who": {
            "description": "Client info as banned type",
            "example": "Banned name",
            "type": "string"
          },
          "by": {
            "description": "Commander",
            "example": "mgmt_api",
            "type": "string"
          },
          "reason": {
            "description": "Banned reason",
            "example": "Too many requests",
            "type": "string"
          },
          "at": {
            "description": "Create banned time, rfc3339, now if not specified",
            "example": "2021-10-25T21:48:47+08:00",
            "oneOf": [
              {
                "description": "epoch-second",
                "example": 1640995200,
                "type": "integer"
              },
              {
                "example": "2022-01-01T00:00:00.000Z",
                "format": "date-time",
                "type": "string"
              }
            ]
          },
          "until": {
            "description": "Cancel banned time, rfc3339, now + 5 minute if not specified",
            "example": "2021-10-25T21:53:47+08:00",
            "oneOf": [
              {
                "description": "epoch-second",
                "example": 1640995200,
                "type": "integer"
              },
              {
                "example": "2022-01-01T00:00:00.000Z",
                "format": "date-time",
                "type": "string"
              }
            ]
          }
        },
        "type": "object"
      },
      "bridge.node_status": {
        "properties": {
          "node": {
            "description": "The node name.",
            "example": "emqx@127.0.0.1",
            "type": "string"
          },
          "status": {
            "enum": [
              "connected",
              "disconnected",
              "connecting"
            ],
            "type": "string"
          }
        },
        "type": "object"
      },
      "authz.node_error": {
        "properties": {
          "node": {
            "description": "Node name.",
            "example": "emqx@127.0.0.1",
            "type": "string"
          },
          "error": {
            "description": "The error of node.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "broker.cache": {
        "required": [
          "enable"
        ],
        "properties": {
          "enable": {
            "default": true,
            "description": "</br>Enable or disable the authorization cache.</br>",
            "type": "boolean"
          },
          "max_size": {
            "default": 32,
            "description": "</br>Maximum number of cached items.</br>",
            "maximum": 1048576,
            "minimum": 1,
            "type": "integer"
          },
          "ttl": {
            "default": "1m",
            "description": "</br>Time to live for the cached data.</br>",
            "example": "12m",
            "type": "string"
          }
        },
        "type": "object"
      },
      "api_key.app": {
        "properties": {
          "name": {
            "description": "Unique and format by [a-zA-Z0-9-_]",
            "example": "EMQX-API-KEY-1",
            "type": "string"
          },
          "api_key": {
            "description": "TODO:uses HMAC-SHA256 for signing.",
            "example": "a4697a5c75a769f6",
            "type": "string"
          },
          "api_secret": {
            "description": "An API secret is a simple encrypted string that identifiesan application without any principal.They are useful for accessing public data anonymously,and are used to associate API requests.",
            "example": "MzAyMjk3ODMwMDk0NjIzOTUxNjcwNzQ0NzQ3MTE2NDYyMDI",
            "type": "string"
          },
          "expired_at": {
            "default": "infinity",
            "description": "No longer valid datetime",
            "example": "2021-12-05T02:01:34.186Z",
            "oneOf": [
              {
                "oneOf": [
                  {
                    "description": "epoch-second",
                    "example": 1640995200,
                    "type": "integer"
                  },
                  {
                    "example": "2022-01-01T00:00:00.000Z",
                    "format": "date-time",
                    "type": "string"
                  }
                ]
              },
              {
                "enum": [
                  "infinity"
                ],
                "type": "string"
              }
            ]
          },
          "created_at": {
            "description": "ApiKey create datetime",
            "example": "2021-12-01T00:00:00.000Z",
            "oneOf": [
              {
                "description": "epoch-second",
                "example": 1640995200,
                "type": "integer"
              },
              {
                "example": "2022-01-01T00:00:00.000Z",
                "format": "date-time",
                "type": "string"
              }
            ]
          },
          "desc": {
            "example": "Note",
            "type": "string"
          },
          "enable": {
            "description": "Enable/Disable",
            "type": "boolean"
          },
          "expired": {
            "description": "Expired",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "emqx_bridge_mqtt_schema.post_egress": {
        "required": [
          "payload",
          "retain",
          "remote_qos",
          "remote_topic",
          "connector",
          "direction",
          "name",
          "type"
        ],
        "properties": {
          "type": {
            "description": "The bridge type.",
            "enum": [
              "mqtt"
            ],
            "type": "string"
          },
          "name": {
            "description": "Bridge name, used as a human-readable description of the bridge.",
            "type": "string"
          },
          "direction": {
            "default": "egress",
            "description": "The direction of the bridge. Can be one of 'ingress' or 'egress'.</br>The egress config defines how this bridge forwards messages from the local broker to the remote</br>broker.</br>Template with variables is allowed in 'remote_topic', 'qos', 'retain', 'payload'.</br>NOTE: if this bridge is used as the action of a rule (emqx rule engine), and also local_topic</br>is configured, then both the data got from the rule and the MQTT messages that matches</br>local_topic will be forwarded.</br>",
            "enum": [
              "egress"
            ],
            "type": "string"
          },
          "connector": {
            "description": "</br>The ID or the configs of the connector to be used for this bridge. Connector IDs must be of format:</br><code>{type}:{name}</code>.</br>In config files, you can find the corresponding config entry for a connector by such path:</br>'connectors.{type}.{name}'.</br>",
            "example": "mqtt:my_mqtt_connector",
            "oneOf": [
              {
                "$ref": "#/components/schemas/connector-mqtt.connector"
              },
              {
                "type": "string"
              }
            ]
          },
          "local_topic": {
            "description": "The local topic to be forwarded to the remote broker",
            "type": "string"
          },
          "remote_topic": {
            "description": "</br>Forward to which topic of the remote broker.</br>Template with variables is allowed.</br>",
            "type": "string"
          },
          "remote_qos": {
            "description": "</br>The QoS of the MQTT message to be sent.</br>Template with variables is allowed.</br>",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "enum": [
                  0,
                  1,
                  2
                ],
                "type": "string"
              }
            ]
          },
          "retain": {
            "description": "</br>The 'retain' flag of the MQTT message to be sent.</br>Template with variables is allowed.</br>",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "boolean"
              }
            ]
          },
          "payload": {
            "description": "</br>The payload of the MQTT message to be sent.</br>Template with variables is allowed.</br>",
            "type": "string"
          }
        },
        "type": "object"
      },
      "broker.deflate_opts": {
        "properties": {
          "level": {
            "description": "</br>Compression level.</br>",
            "enum": [
              "none",
              "default",
              "best_compression",
              "best_speed"
            ],
            "type": "string"
          },
          "mem_level": {
            "default": 8,
            "description": "</br>Specifies the size of the compression state.</br>Lower values decrease memory usage per connection.</br>",
            "maximum": 9,
            "minimum": 1,
            "type": "integer"
          },
          "strategy": {
            "default": "default",
            "description": "</br>Specifies the compression strategy.</br>",
            "enum": [
              "default",
              "filtered",
              "huffman_only",
              "rle"
            ],
            "type": "string"
          },
          "server_context_takeover": {
            "default": "takeover",
            "description": "</br>Takeover means the compression state is retained between server messages.</br>",
            "enum": [
              "takeover",
              "no_takeover"
            ],
            "type": "string"
          },
          "client_context_takeover": {
            "default": "takeover",
            "description": "</br>Takeover means the compression state is retained between client messages.</br>",
            "enum": [
              "takeover",
              "no_takeover"
            ],
            "type": "string"
          },
          "server_max_window_bits": {
            "default": 15,
            "description": "</br>Specifies the size of the compression context for the server.</br>",
            "maximum": 15,
            "minimum": 8,
            "type": "integer"
          },
          "client_max_window_bits": {
            "default": 15,
            "description": "</br>Specifies the size of the compression context for the client.</br>",
            "maximum": 15,
            "minimum": 8,
            "type": "integer"
          }
        },
        "type": "object"
      },
      "broker.tcp_opts": {
        "properties": {
          "active_n": {
            "default": 100,
            "description": "</br>Specify the {active, N} option for this Socket.</br>See: https://erlang.org/doc/man/inet.html#setopts-2</br>",
            "type": "integer"
          },
          "backlog": {
            "default": 1024,
            "description": "</br>TCP backlog defines the maximum length that the queue of</br> pending connections can grow to.</br>",
            "minimum": 1,
            "type": "integer"
          },
          "send_timeout": {
            "default": "15s",
            "description": "</br>The TCP send timeout for the connections.</br>",
            "example": "12m",
            "type": "string"
          },
          "send_timeout_close": {
            "default": true,
            "description": "</br>Close the connection if send timeout.</br>",
            "type": "boolean"
          },
          "recbuf": {
            "description": "</br>The TCP receive buffer (OS kernel) for the connections.</br>",
            "example": "2KB",
            "type": "string"
          },
          "sndbuf": {
            "description": "</br>The TCP send buffer (OS kernel) for the connections.</br>",
            "example": "4KB",
            "type": "string"
          },
          "buffer": {
            "default": "4KB",
            "description": "</br>The size of the user-space buffer used by the driver.</br>",
            "example": "4KB",
            "type": "string"
          },
          "high_watermark": {
            "default": "1MB",
            "description": "</br>The socket is set to a busy state when the amount of data queued internally</br>  by the VM socket implementation reaches this limit.</br>",
            "example": "32MB",
            "type": "string"
          },
          "nodelay": {
            "default": true,
            "description": "</br>The TCP_NODELAY flag for the connections.</br>",
            "type": "boolean"
          },
          "reuseaddr": {
            "default": true,
            "description": "</br>The SO_REUSEADDR flag for the connections.</br>",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "emqx_topic_metrics_api.reset": {
        "required": [
          "action"
        ],
        "properties": {
          "topic": {
            "example": "testtopic/1",
            "type": "string"
          },
          "action": {
            "description": "Action. Only support reset",
            "example": "reset",
            "type": "string"
          }
        },
        "type": "object"
      },
      "emqx_gateway_api.update_stomp": {
        "properties": {
          "frame": {
            "$ref": "#/components/schemas/gateway.stomp_frame"
          },
          "mountpoint": {
            "default": "",
            "description": " ",
            "type": "string"
          },
          "enable": {
            "default": true,
            "description": "Whether to enable this gateway",
            "type": "boolean"
          },
          "enable_stats": {
            "default": true,
            "description": "Whether to enable client process statistic",
            "type": "boolean"
          },
          "idle_timeout": {
            "default": "30s",
            "description": "The idle time of the client connection process. It has two purposes:</br>  1. A newly created client process that does not receive any client requests after that time will be closed directly.</br>  2. A running client process that does not receive any client requests after this time will go into hibernation to save resources.",
            "example": "12m",
            "type": "string"
          },
          "clientinfo_override": {
            "description": "ClientInfo override.",
            "$ref": "#/components/schemas/gateway.clientinfo_override"
          }
        },
        "type": "object"
      },
      "emqx_conf_schema.log_burst_limit": {
        "properties": {
          "enable": {
            "default": true,
            "description": "Enable log burst control feature.",
            "type": "boolean"
          },
          "max_count": {
            "default": 10000,
            "description": "Maximum number of log events to handle within a `window_time` interval. After the limit is reached, successive events are dropped until the end of the `window_time`.",
            "minimum": 1,
            "type": "integer"
          },
          "window_time": {
            "default": "1s",
            "description": "See <code>max_count</code>.",
            "example": "12m",
            "type": "string"
          }
        },
        "type": "object"
      },
      "plugins.position": {
        "properties": {
          "position": {
            "description": "</br>             Enable auto-boot at position in the boot list, where Position could be</br>             'front', 'rear', or 'before:other-vsn', 'after:other-vsn'</br>             to specify a relative position.</br>            ",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "enum": [
                  "rear"
                ],
                "type": "string"
              },
              {
                "enum": [
                  "front"
                ],
                "type": "string"
              }
            ]
          }
        },
        "type": "object"
      },
      "bridge.node_metrics": {
        "properties": {
          "node": {
            "description": "The node name.",
            "example": "emqx@127.0.0.1",
            "type": "string"
          },
          "metrics": {
            "$ref": "#/components/schemas/bridge.metrics"
          }
        },
        "type": "object"
      },
      "emqx_conf_schema.cluster": {
        "properties": {
          "name": {
            "default": "emqxcl",
            "description": "Human-friendly name of the EMQX cluster.",
            "readOnly": true,
            "type": "string"
          },
          "discovery_strategy": {
            "default": "manual",
            "description": "Service discovery method for the cluster nodes.",
            "enum": [
              "manual",
              "static",
              "mcast",
              "dns",
              "etcd",
              "k8s"
            ],
            "readOnly": true,
            "type": "string"
          },
          "core_nodes": {
            "default": "",
            "description": "</br>List of core nodes that the replicant will connect to.</br>Note: this parameter only takes effect when the <code>backend</code> is set</br>to <code>rlog</code> and the <code>role</code> is set to <code>replicant</code>.</br>This value needs to be defined for manual or static cluster discovery mechanisms.</br>If an automatic cluster discovery mechanism is being used (such as <code>etcd</code>),</br>there is no need to set this value.</br>",
            "example": "item1,item2",
            "readOnly": true,
            "type": "string"
          },
          "autoclean": {
            "default": "5m",
            "description": "Remove disconnected nodes from the cluster after this interval.",
            "example": "12m",
            "readOnly": true,
            "type": "string"
          },
          "autoheal": {
            "default": true,
            "description": "If <code>true</code>, the node will try to heal network partitions automatically.",
            "readOnly": true,
            "type": "boolean"
          },
          "proto_dist": {
            "default": "inet_tcp",
            "description": "The Erlang distribution protocol for the cluster.",
            "enum": [
              "inet_tcp",
              "inet6_tcp",
              "inet_tls"
            ],
            "readOnly": true,
            "type": "string"
          },
          "static": {
            "$ref": "#/components/schemas/emqx_conf_schema.cluster_static"
          },
          "mcast": {
            "$ref": "#/components/schemas/emqx_conf_schema.cluster_mcast"
          },
          "dns": {
            "$ref": "#/components/schemas/emqx_conf_schema.cluster_dns"
          },
          "etcd": {
            "$ref": "#/components/schemas/emqx_conf_schema.cluster_etcd"
          },
          "k8s": {
            "$ref": "#/components/schemas/emqx_conf_schema.cluster_k8s"
          }
        },
        "type": "object"
      },
      "plugins.running_status": {
        "properties": {
          "node": {
            "example": "emqx@127.0.0.1",
            "type": "string"
          },
          "status": {
            "description": "Install plugin status at runtime</br>1. running: plugin is running.</br>2. stopped: plugin is stopped.</br>",
            "enum": [
              "running",
              "stopped"
            ],
            "type": "string"
          }
        },
        "type": "object"
      },
      "emqx_gateway_api.update_coap": {
        "properties": {
          "heartbeat": {
            "default": "30s",
            "description": "The gateway server required minimum heartbeat interval.</br>When connection mode is enabled, this parameter is used to set the minimum heartbeat interval for the connection to be alive",
            "example": "12m",
            "type": "string"
          },
          "connection_required": {
            "default": false,
            "description": "Enable or disable connection mode.</br>Connection mode is a feature of non-standard protocols. When connection mode is enabled, it is necessary to maintain the creation, authentication and alive of connection resources",
            "type": "boolean"
          },
          "notify_type": {
            "default": "qos",
            "description": "The Notification Message will be delivered to the CoAP client if a new message received on an observed topic.</br>The type of delivered coap message can be set to:</br>  - non: Non-confirmable;</br>  - con: Confirmable;</br>  - qos: Mapping from QoS type of received message, QoS0 -> non, QoS1,2 -> con</br>",
            "enum": [
              "non",
              "con",
              "qos"
            ],
            "type": "string"
          },
          "subscribe_qos": {
            "default": "coap",
            "description": "The Default QoS Level indicator for subscribe request.</br>This option specifies the QoS level for the CoAP Client when establishing a subscription membership, if the subscribe request is not carried `qos` option. The indicator can be set to:</br>  - qos0, qos1, qos2: Fixed default QoS level</br>  - coap: Dynamic QoS level by the message type of subscribe request</br>    * qos0: If the subscribe request is non-confirmable</br>    * qos1: If the subscribe request is confirmable</br>",
            "enum": [
              "qos0",
              "qos1",
              "qos2",
              "coap"
            ],
            "type": "string"
          },
          "publish_qos": {
            "default": "coap",
            "description": "The Default QoS Level indicator for publish request.</br>This option specifies the QoS level for the CoAP Client when publishing a message to EMQX PUB/SUB system, if the publish request is not carried `qos` option. The indicator can be set to:</br>  - qos0, qos1, qos2: Fixed default QoS level</br>  - coap: Dynamic QoS level by the message type of publish request</br>    * qos0: If the publish request is non-confirmable</br>    * qos1: If the publish request is confirmable",
            "enum": [
              "qos0",
              "qos1",
              "qos2",
              "coap"
            ],
            "type": "string"
          },
          "mountpoint": {
            "default": "",
            "description": " ",
            "type": "string"
          },
          "enable": {
            "default": true,
            "description": "Whether to enable this gateway",
            "type": "boolean"
          },
          "enable_stats": {
            "default": true,
            "description": "Whether to enable client process statistic",
            "type": "boolean"
          },
          "idle_timeout": {
            "default": "30s",
            "description": "The idle time of the client connection process. It has two purposes:</br>  1. A newly created client process that does not receive any client requests after that time will be closed directly.</br>  2. A running client process that does not receive any client requests after this time will go into hibernation to save resources.",
            "example": "12m",
            "type": "string"
          },
          "clientinfo_override": {
            "description": "ClientInfo override.",
            "$ref": "#/components/schemas/gateway.clientinfo_override"
          }
        },
        "type": "object"
      },
      "emqx_mgmt_api_publish.publish_message": {
        "required": [
          "payload",
          "topic"
        ],
        "properties": {
          "payload_encoding": {
            "default": "plain",
            "description": "MQTT Payload Encoding, base64 or plain",
            "enum": [
              "plain",
              "base64"
            ],
            "type": "string"
          },
          "topic": {
            "description": "Topic Name",
            "example": "api/example/topic",
            "type": "string"
          },
          "qos": {
            "default": 0,
            "description": "MQTT QoS",
            "enum": [
              0,
              1,
              2
            ],
            "type": "string"
          },
          "clientid": {
            "description": "From client ID",
            "example": "api_example_client",
            "type": "string"
          },
          "payload": {
            "description": "MQTT Payload",
            "example": "hello emqx api",
            "type": "string"
          },
          "retain": {
            "default": false,
            "description": "MQTT Retain Message",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "emqx_mgmt_api_clients.subscribe": {
        "properties": {
          "topic": {
            "description": "Topic",
            "type": "string"
          },
          "qos": {
            "description": "QoS",
            "enum": [
              0,
              1,
              2
            ],
            "type": "string"
          },
          "nl": {
            "default": 0,
            "description": "No Local",
            "type": "integer"
          },
          "rap": {
            "default": 0,
            "description": "Retain as Published",
            "type": "integer"
          },
          "rh": {
            "default": 0,
            "description": "Retain Handling",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "emqx_authn_api.response_users": {
        "properties": {
          "data": {
            "items": {
              "$ref": "#/components/schemas/emqx_authn_api.response_user"
            },
            "type": "array"
          },
          "meta": {
            "$ref": "#/components/schemas/public.meta"
          }
        },
        "type": "object"
      },
      "emqx_gateway_api.tcp_listener": {
        "properties": {
          "id": {
            "description": "Listener ID",
            "type": "string"
          },
          "type": {
            "description": "Listener Type",
            "enum": [
              "tcp"
            ],
            "type": "string"
          },
          "name": {
            "description": "Listener Name",
            "type": "string"
          },
          "running": {
            "description": "Listener Running status",
            "type": "boolean"
          },
          "acceptors": {
            "default": 16,
            "description": "Size of the acceptor pool.",
            "type": "integer"
          },
          "tcp_options": {
            "description": "Setting the TCP socket options.",
            "$ref": "#/components/schemas/broker.tcp_opts"
          },
          "proxy_protocol": {
            "default": false,
            "description": "Enable the Proxy Protocol V1/2 if the EMQX cluster is deployed behind HAProxy or Nginx.</br>See: https://www.haproxy.com/blog/haproxy/proxy-protocol/",
            "type": "boolean"
          },
          "proxy_protocol_timeout": {
            "default": "15s",
            "description": "Timeout for proxy protocol.</br>EMQX will close the TCP connection if proxy protocol packet is not received within the timeout.",
            "example": "12m",
            "type": "string"
          },
          "enable": {
            "default": true,
            "description": "Enable the listener.",
            "type": "boolean"
          },
          "bind": {
            "description": "The IP address and port that the listener will bind.",
            "oneOf": [
              {
                "type": "integer"
              },
              {
                "example": "127.0.0.1:80",
                "type": "string"
              }
            ]
          },
          "max_connections": {
            "default": 1024,
            "description": "Maximum number of concurrent connections.",
            "type": "integer"
          },
          "max_conn_rate": {
            "default": 1000,
            "description": "Maximum connections per second.",
            "type": "integer"
          },
          "authentication": {
            "description": "Default authentication configs for all the gateway listeners. For per-listener overrides see <code>authentication</code></br> in listener configs",
            "oneOf": [
              {
                "$ref": "#/components/schemas/authn-scram-builtin_db.authentication"
              },
              {
                "$ref": "#/components/schemas/authn-jwt.jwks"
              },
              {
                "$ref": "#/components/schemas/authn-jwt.public-key"
              },
              {
                "$ref": "#/components/schemas/authn-jwt.hmac-based"
              },
              {
                "$ref": "#/components/schemas/authn-http.post"
              },
              {
                "$ref": "#/components/schemas/authn-http.get"
              },
              {
                "$ref": "#/components/schemas/authn-redis.sentinel"
              },
              {
                "$ref": "#/components/schemas/authn-redis.cluster"
              },
              {
                "$ref": "#/components/schemas/authn-redis.standalone"
              },
              {
                "$ref": "#/components/schemas/authn-mongodb.sharded-cluster"
              },
              {
                "$ref": "#/components/schemas/authn-mongodb.replica-set"
              },
              {
                "$ref": "#/components/schemas/authn-mongodb.standalone"
              },
              {
                "$ref": "#/components/schemas/authn-postgresql.authentication"
              },
              {
                "$ref": "#/components/schemas/authn-mysql.authentication"
              },
              {
                "$ref": "#/components/schemas/authn-builtin_db.authentication"
              }
            ]
          },
          "enable_authn": {
            "default": true,
            "description": "Set <code>true</code> (default) to enable client authentication on this listener. </br>When set to <code>false</code> clients will be allowed to connect without authentication.",
            "type": "boolean"
          },
          "mountpoint": {
            "description": "When publishing or subscribing, prefix all topics with a mountpoint string.</br>The prefixed string will be removed from the topic name when the message is delivered to the subscriber. The mountpoint is a way that users can use to implement isolation of message routing between different listeners.</br>For example if a client A subscribes to `t` with `listeners.tcp.\\<name>.mountpoint` set to `some_tenant`, then the client actually subscribes to the topic `some_tenant/t`. Similarly, if another client B (connected to the same listener as the client A) sends a message to topic `t`, the message is routed to all the clients subscribed `some_tenant/t`, so client A will receive the message, with topic name `t`. Set to `\"\"` to disable the feature.</br>Variables in mountpoint string:</br>  - <code>${clientid}</code>: clientid</br>  - <code>${username}</code>: username</br>",
            "type": "string"
          },
          "access_rules": {
            "default": "",
            "description": "The access control rules for this listener.</br>See: https://github.com/emqtt/esockd#allowdeny",
            "items": {
              "type": "string"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "emqx_conf_schema.log": {
        "properties": {
          "console_handler": {
            "description": "Log handler that prints log events to the EMQX console.",
            "$ref": "#/components/schemas/emqx_conf_schema.console_handler"
          },
          "file_handlers": {
            "description": "File-based log handlers.",
            "properties": {
              "$name": {
                "$ref": "#/components/schemas/emqx_conf_schema.log_file_handler"
              }
            },
            "type": "object"
          }
        },
        "type": "object"
      },
      "emqx_authz_api_schema.http_get": {
        "required": [
          "url",
          "type",
          "method"
        ],
        "properties": {
          "method": {
            "default": "get",
            "description": "HTTP method.",
            "enum": [
              "get"
            ],
            "type": "string"
          },
          "headers": {
            "default": {
              "accept": "application/json",
              "cache-control": "no-cache",
              "connection": "keep-alive",
              "keep-alive": "timeout=30, max=1000"
            },
            "description": "List of HTTP headers (without <code>content-type</code>).",
            "example": {},
            "type": "object"
          },
          "enable": {
            "default": true,
            "description": "Set to <code>true</code> or <code>false</code> to disable this ACL provider",
            "type": "boolean"
          },
          "type": {
            "default": "http",
            "description": "Backend type.",
            "enum": [
              "http"
            ],
            "type": "string"
          },
          "url": {
            "description": "URL of the auth server.",
            "type": "string"
          },
          "body": {
            "description": "HTTP request body.",
            "example": {},
            "type": "object"
          },
          "request_timeout": {
            "default": "30s",
            "description": "Request timeout.",
            "type": "string"
          },
          "connect_timeout": {
            "default": "15s",
            "description": "The timeout when connecting to the HTTP server.",
            "example": "32s",
            "type": "string"
          },
          "enable_pipelining": {
            "default": 100,
            "description": "Whether to send HTTP requests continuously, when set to 0, it means that after each HTTP request is sent, you need to wait for the server to return and then continue to send the next request.",
            "minimum": 1,
            "type": "integer"
          },
          "max_retries": {
            "default": 5,
            "description": "Max retry times if error on sending request.",
            "minimum": 0,
            "type": "integer"
          },
          "pool_size": {
            "default": 8,
            "description": "The pool size.",
            "minimum": 1,
            "type": "integer"
          },
          "request": {
            "description": "</br>If the request is provided, the caller can send HTTP requests via</br><code>emqx_resource:query(ResourceId, {send_message, BridgeId, Message})</code></br>",
            "$ref": "#/components/schemas/connector-http.request"
          },
          "retry_interval": {
            "default": "1s",
            "description": "Interval between retries.",
            "example": "12m",
            "type": "string"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/broker.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "emqx_mgmt_api_clients.unsubscribe": {
        "properties": {
          "topic": {
            "description": "Topic",
            "type": "string"
          }
        },
        "type": "object"
      },
      "emqx_mgmt_api_metrics.node_metrics": {
        "properties": {
          "node": {
            "description": "Node name",
            "type": "string"
          },
          "actions.failure": {
            "description": "Number of failure executions of the rule engine action",
            "minimum": 0,
            "type": "integer"
          },
          "actions.success": {
            "description": "Number of successful executions of the rule engine action",
            "minimum": 0,
            "type": "integer"
          },
          "bytes.received": {
            "description": "Number of bytes received ",
            "minimum": 0,
            "type": "integer"
          },
          "bytes.sent": {
            "description": "Number of bytes sent on this connection",
            "minimum": 0,
            "type": "integer"
          },
          "client.auth.anonymous": {
            "description": "Number of clients who log in anonymously",
            "minimum": 0,
            "type": "integer"
          },
          "client.authenticate": {
            "description": "Number of client authentications",
            "minimum": 0,
            "type": "integer"
          },
          "client.check_authz": {
            "description": "Number of Authorization rule checks",
            "minimum": 0,
            "type": "integer"
          },
          "client.connack": {
            "description": "Number of CONNACK packet sent",
            "minimum": 0,
            "type": "integer"
          },
          "client.connect": {
            "description": "Number of client connections",
            "minimum": 0,
            "type": "integer"
          },
          "client.connected": {
            "description": "Number of successful client connections",
            "minimum": 0,
            "type": "integer"
          },
          "client.disconnected": {
            "description": "Number of client disconnects",
            "minimum": 0,
            "type": "integer"
          },
          "client.subscribe": {
            "description": "Number of client subscriptions",
            "minimum": 0,
            "type": "integer"
          },
          "client.unsubscribe": {
            "description": "Number of client unsubscriptions",
            "minimum": 0,
            "type": "integer"
          },
          "delivery.dropped": {
            "description": "Total number of discarded messages when sending",
            "minimum": 0,
            "type": "integer"
          },
          "delivery.dropped.expired": {
            "description": "Number of messages dropped due to message expiration on sending",
            "minimum": 0,
            "type": "integer"
          },
          "delivery.dropped.no_local": {
            "description": "Number of messages that were dropped due to the No Local subscription option when sending",
            "minimum": 0,
            "type": "integer"
          },
          "delivery.dropped.qos0_msg": {
            "description": "Number of messages with QoS 0 that were dropped because the message queue was full when sending",
            "minimum": 0,
            "type": "integer"
          },
          "delivery.dropped.queue_full": {
            "description": "Number of messages with a non-zero QoS that were dropped because the message queue was full when sending",
            "minimum": 0,
            "type": "integer"
          },
          "delivery.dropped.too_large": {
            "description": "The number of messages that were dropped because the length exceeded the limit when sending",
            "minimum": 0,
            "type": "integer"
          },
          "messages.acked": {
            "description": "Number of received PUBACK and PUBREC packet",
            "minimum": 0,
            "type": "integer"
          },
          "messages.delayed": {
            "description": "Number of delay-published messages",
            "minimum": 0,
            "type": "integer"
          },
          "messages.delivered": {
            "description": "Number of messages forwarded to the subscription process internally",
            "minimum": 0,
            "type": "integer"
          },
          "messages.dropped": {
            "description": "Total number of messages dropped before forwarding to the subscription process",
            "minimum": 0,
            "type": "integer"
          },
          "messages.dropped.await_pubrel_timeout": {
            "description": "Number of messages dropped due to waiting PUBREL timeout",
            "minimum": 0,
            "type": "integer"
          },
          "messages.dropped.no_subscribers": {
            "description": "Number of messages dropped due to no subscribers",
            "minimum": 0,
            "type": "integer"
          },
          "messages.forward": {
            "description": "Number of messages forwarded to other nodes",
            "minimum": 0,
            "type": "integer"
          },
          "messages.publish": {
            "description": "Number of messages published in addition to system messages",
            "minimum": 0,
            "type": "integer"
          },
          "messages.qos0.received": {
            "description": "Number of QoS 0 messages received from clients",
            "minimum": 0,
            "type": "integer"
          },
          "messages.qos0.sent": {
            "description": "Number of QoS 0 messages sent to clients",
            "minimum": 0,
            "type": "integer"
          },
          "messages.qos1.received": {
            "description": "Number of QoS 1 messages received from clients",
            "minimum": 0,
            "type": "integer"
          },
          "messages.qos1.sent": {
            "description": "Number of QoS 1 messages sent to clients",
            "minimum": 0,
            "type": "integer"
          },
          "messages.qos2.received": {
            "description": "Number of QoS 2 messages received from clients",
            "minimum": 0,
            "type": "integer"
          },
          "messages.qos2.sent": {
            "description": "Number of QoS 2 messages sent to clients",
            "minimum": 0,
            "type": "integer"
          },
          "messages.received": {
            "description": "Number of messages received from the client, equal to the sum of messages.qos0.received\fmessages.qos1.received and messages.qos2.received",
            "minimum": 0,
            "type": "integer"
          },
          "messages.retained": {
            "description": "Number of retained messages",
            "minimum": 0,
            "type": "integer"
          },
          "messages.sent": {
            "description": "Number of messages sent to the client, equal to the sum of messages.qos0.sent\fmessages.qos1.sent and messages.qos2.sent",
            "minimum": 0,
            "type": "integer"
          },
          "packets.auth.received": {
            "description": "Number of received AUTH packet",
            "minimum": 0,
            "type": "integer"
          },
          "packets.auth.sent": {
            "description": "Number of sent AUTH packet",
            "minimum": 0,
            "type": "integer"
          },
          "packets.connack.auth_error": {
            "description": "Number of received CONNECT packet with failed authentication",
            "minimum": 0,
            "type": "integer"
          },
          "packets.connack.error": {
            "description": "Number of received CONNECT packet with unsuccessful connections",
            "minimum": 0,
            "type": "integer"
          },
          "packets.connack.sent": {
            "description": "Number of sent CONNACK packet",
            "minimum": 0,
            "type": "integer"
          },
          "packets.connect.received": {
            "description": "Number of received CONNECT packet",
            "minimum": 0,
            "type": "integer"
          },
          "packets.disconnect.received": {
            "description": "Number of received DISCONNECT packet",
            "minimum": 0,
            "type": "integer"
          },
          "packets.disconnect.sent": {
            "description": "Number of sent DISCONNECT packet",
            "minimum": 0,
            "type": "integer"
          },
          "packets.pingreq.received": {
            "description": "Number of received PINGREQ packet",
            "minimum": 0,
            "type": "integer"
          },
          "packets.pingresp.sent": {
            "description": "Number of sent PUBRESP packet",
            "minimum": 0,
            "type": "integer"
          },
          "packets.puback.inuse": {
            "description": "Number of received PUBACK packet with occupied identifiers",
            "minimum": 0,
            "type": "integer"
          },
          "packets.puback.missed": {
            "description": "Number of received packet with identifiers.",
            "minimum": 0,
            "type": "integer"
          },
          "packets.puback.received": {
            "description": "Number of received PUBACK packet",
            "minimum": 0,
            "type": "integer"
          },
          "packets.puback.sent": {
            "description": "Number of sent PUBACK packet",
            "minimum": 0,
            "type": "integer"
          },
          "packets.pubcomp.inuse": {
            "description": "Number of received PUBCOMP packet with occupied identifiers",
            "minimum": 0,
            "type": "integer"
          },
          "packets.pubcomp.missed": {
            "description": "Number of missed PUBCOMP packet",
            "minimum": 0,
            "type": "integer"
          },
          "packets.pubcomp.received": {
            "description": "Number of received PUBCOMP packet",
            "minimum": 0,
            "type": "integer"
          },
          "packets.pubcomp.sent": {
            "description": "Number of sent PUBCOMP packet",
            "minimum": 0,
            "type": "integer"
          },
          "packets.publish.auth_error": {
            "description": "Number of received PUBLISH packets with failed the Authorization check",
            "minimum": 0,
            "type": "integer"
          },
          "packets.publish.dropped": {
            "description": "Number of messages discarded due to the receiving limit",
            "minimum": 0,
            "type": "integer"
          },
          "packets.publish.error": {
            "description": "Number of received PUBLISH packet that cannot be published",
            "minimum": 0,
            "type": "integer"
          },
          "packets.publish.inuse": {
            "description": "Number of received PUBLISH packet with occupied identifiers",
            "minimum": 0,
            "type": "integer"
          },
          "packets.publish.received": {
            "description": "Number of received PUBLISH packet",
            "minimum": 0,
            "type": "integer"
          },
          "packets.publish.sent": {
            "description": "Number of sent PUBLISH packet",
            "minimum": 0,
            "type": "integer"
          },
          "packets.pubrec.inuse": {
            "description": "Number of received PUBREC packet with occupied identifiers",
            "minimum": 0,
            "type": "integer"
          },
          "packets.pubrec.missed": {
            "description": "Number of received PUBREC packet with unknown identifiers",
            "minimum": 0,
            "type": "integer"
          },
          "packets.pubrec.received": {
            "description": "Number of received PUBREC packet",
            "minimum": 0,
            "type": "integer"
          },
          "packets.pubrec.sent": {
            "description": "Number of sent PUBREC packet",
            "minimum": 0,
            "type": "integer"
          },
          "packets.pubrel.missed": {
            "description": "Number of received PUBREC packet with unknown identifiers",
            "minimum": 0,
            "type": "integer"
          },
          "packets.pubrel.received": {
            "description": "Number of received PUBREL packet",
            "minimum": 0,
            "type": "integer"
          },
          "packets.pubrel.sent": {
            "description": "Number of sent PUBREL packet",
            "minimum": 0,
            "type": "integer"
          },
          "packets.received": {
            "description": "Number of received packet",
            "minimum": 0,
            "type": "integer"
          },
          "packets.sent": {
            "description": "Number of sent packet",
            "minimum": 0,
            "type": "integer"
          },
          "packets.suback.sent": {
            "description": "Number of sent SUBACK packet",
            "minimum": 0,
            "type": "integer"
          },
          "packets.subscribe.auth_error": {
            "description": "Number of received SUBACK packet with failed Authorization check",
            "minimum": 0,
            "type": "integer"
          },
          "packets.subscribe.error": {
            "description": "Number of received SUBSCRIBE packet with failed subscriptions",
            "minimum": 0,
            "type": "integer"
          },
          "packets.subscribe.received": {
            "description": "Number of received SUBSCRIBE packet",
            "minimum": 0,
            "type": "integer"
          },
          "packets.unsuback.sent": {
            "description": "Number of sent UNSUBACK packet",
            "minimum": 0,
            "type": "integer"
          },
          "packets.unsubscribe.error": {
            "description": "Number of received UNSUBSCRIBE packet with failed unsubscriptions",
            "minimum": 0,
            "type": "integer"
          },
          "packets.unsubscribe.received": {
            "description": "Number of received UNSUBSCRIBE packet",
            "minimum": 0,
            "type": "integer"
          },
          "rules.matched": {
            "description": "Number of rule matched",
            "minimum": 0,
            "type": "integer"
          },
          "session.created": {
            "description": "Number of sessions created",
            "minimum": 0,
            "type": "integer"
          },
          "session.discarded": {
            "description": "Number of sessions dropped because Clean Session or Clean Start is true",
            "minimum": 0,
            "type": "integer"
          },
          "session.resumed": {
            "description": "Number of sessions resumed because Clean Session or Clean Start is false",
            "minimum": 0,
            "type": "integer"
          },
          "session.takenover": {
            "description": "Number of sessions takenover because Clean Session or Clean Start is false",
            "minimum": 0,
            "type": "integer"
          },
          "session.terminated": {
            "description": "Number of terminated sessions",
            "minimum": 0,
            "type": "integer"
          }
        },
        "type": "object"
      },
      "listeners.quic_not_required_bind": {
        "required": [
          "id",
          "type"
        ],
        "properties": {
          "type": {
            "description": "Listener type",
            "enum": [
              "quic"
            ],
            "type": "string"
          },
          "running": {
            "description": "Listener status",
            "type": "boolean"
          },
          "id": {
            "description": "Listener id",
            "type": "string"
          },
          "current_connections": {
            "description": "Current connections",
            "minimum": 0,
            "type": "integer"
          },
          "bind": {
            "default": 14567,
            "description": "</br>IP address and port for the listening socket.</br>",
            "oneOf": [
              {
                "type": "integer"
              },
              {
                "example": "127.0.0.1:80",
                "type": "string"
              }
            ]
          },
          "certfile": {
            "description": "</br>Path to the certificate file.</br>",
            "type": "string"
          },
          "keyfile": {
            "description": "</br>Path to the secret key file.</br>",
            "type": "string"
          },
          "ciphers": {
            "default": [
              "TLS_AES_256_GCM_SHA384",
              "TLS_AES_128_GCM_SHA256",
              "TLS_CHACHA20_POLY1305_SHA256"
            ],
            "description": "</br>This config holds TLS cipher suite names separated by comma,</br>or as an array of strings. e.g.</br><code>\"TLS_AES_256_GCM_SHA384,TLS_AES_128_GCM_SHA256\"</code> or</br><code>[\"TLS_AES_256_GCM_SHA384\",\"TLS_AES_128_GCM_SHA256\"]</code>.</br></br>Ciphers (and their ordering) define the way in which the</br>client and server encrypts information over the network connection.</br>Selecting a good cipher suite is critical for the</br>application's data security, confidentiality and performance.</br></br>The names should be in OpenSSL string format (not RFC format).</br>All default values and examples provided by EMQX config</br>documentation are all in OpenSSL format.</br></br>NOTE: Certain cipher suites are only compatible with</br>specific TLS <code>versions</code> ('tlsv1.1', 'tlsv1.2' or 'tlsv1.3')</br>incompatible cipher suites will be silently dropped.</br>For instance, if only 'tlsv1.3' is given in the <code>versions</code>,</br>configuring cipher suites for other versions will have no effect.</br></br></br>NOTE: PSK ciphers are suppressed by 'tlsv1.3' version config</br>If PSK cipher suites are intended, 'tlsv1.3' should be disabled from <code>versions</code>.</br>PSK cipher suites: <code>\"RSA-PSK-AES256-GCM-SHA384,RSA-PSK-AES256-CBC-SHA384,</br>RSA-PSK-AES128-GCM-SHA256,RSA-PSK-AES128-CBC-SHA256,</br>RSA-PSK-AES256-CBC-SHA,RSA-PSK-AES128-CBC-SHA,</br>RSA-PSK-DES-CBC3-SHA,RSA-PSK-RC4-SHA\"</code></br></br>NOTE: QUIC listener supports only 'tlsv1.3' ciphers</br>",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "idle_timeout": {
            "default": "15s",
            "description": "</br>Close transport-layer connections from the clients that have not sent MQTT CONNECT</br>message within this interval.</br>",
            "example": "12m",
            "type": "string"
          },
          "enabled": {
            "default": true,
            "description": "</br>Enable listener.</br>",
            "type": "boolean"
          },
          "acceptors": {
            "default": 16,
            "description": "</br>The size of the listener's receiving pool.</br>",
            "minimum": 1,
            "type": "integer"
          },
          "max_connections": {
            "default": "infinity",
            "description": "</br>The maximum number of concurrent connections allowed by the listener.</br>",
            "oneOf": [
              {
                "minimum": 1,
                "type": "integer"
              },
              {
                "enum": [
                  "infinity"
                ],
                "type": "string"
              }
            ]
          },
          "mountpoint": {
            "default": "",
            "description": "</br>When publishing or subscribing, prefix all topics with a mountpoint string.</br>The prefixed string will be removed from the topic name when the message</br>is delivered to the subscriber. The mountpoint is a way that users can use</br>to implement isolation of message routing between different listeners.</br>For example if a client A subscribes to `t` with `listeners.tcp.\\<name>.mountpoint`</br>set to `some_tenant`, then the client actually subscribes to the topic</br>`some_tenant/t`. Similarly, if another client B (connected to the same listener</br>as the client A) sends a message to topic `t`, the message is routed</br>to all the clients subscribed `some_tenant/t`, so client A will receive the</br>message, with topic name `t`.</br>Set to `\"\"` to disable the feature.</br></br>Variables in mountpoint string:</br>  - <code>${clientid}</code>: clientid</br>  - <code>${username}</code>: username</br>",
            "type": "string"
          },
          "zone": {
            "default": "default",
            "description": "</br>The configuration zone to which the listener belongs.</br>",
            "type": "string"
          },
          "limiter": {
            "default": {
              "connection": "default"
            },
            "description": "</br>Type of the rate limit.</br>",
            "properties": {
              "$ratelimit_name": {
                "example": "retainer",
                "type": "string"
              }
            },
            "type": "object"
          },
          "enable_authn": {
            "default": true,
            "description": "</br>Set <code>true</code> (default) to enable client authentication on this listener.</br>When set to <code>false</code> clients will be allowed to connect without authentication.</br>",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "retainer.message": {
        "properties": {
          "payload": {
            "description": "Payload.",
            "type": "string"
          },
          "msgid": {
            "description": "Message ID.",
            "type": "string"
          },
          "topic": {
            "description": "Topic.",
            "type": "string"
          },
          "qos": {
            "description": "QoS.",
            "enum": [
              0,
              1,
              2
            ],
            "type": "string"
          },
          "publish_at": {
            "description": "Message publish time, RFC 3339 format.",
            "type": "string"
          },
          "from_clientid": {
            "description": "The clientid of publisher.",
            "type": "string"
          },
          "from_username": {
            "description": "The username of publisher.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "emqx_authn_schema.node_status": {
        "properties": {
          "node": {
            "description": "Node name.",
            "example": "emqx@127.0.0.1",
            "type": "string"
          },
          "status": {
            "description": "The status of the resource for each node.",
            "enum": [
              "connected",
              "disconnected",
              "connecting"
            ],
            "type": "string"
          }
        },
        "type": "object"
      },
      "exhook.server_config": {
        "required": [
          "url",
          "name"
        ],
        "properties": {
          "name": {
            "description": "Name of the exhook server",
            "example": "default",
            "type": "string"
          },
          "enable": {
            "default": true,
            "description": "Enable this Exhook server",
            "type": "boolean"
          },
          "url": {
            "description": "URL of the gRPC server",
            "example": "http://127.0.0.1:9000",
            "type": "string"
          },
          "request_timeout": {
            "default": "5s",
            "description": "The timeout of request gRPC server",
            "example": "12m",
            "type": "string"
          },
          "failed_action": {
            "default": "deny",
            "description": "The value that is returned when the request to the gRPC server fails for any reason",
            "enum": [
              "deny",
              "ignore"
            ],
            "type": "string"
          },
          "ssl": {
            "$ref": "#/components/schemas/exhook.ssl_conf"
          },
          "socket_options": {
            "default": {
              "keepalive": true,
              "nodelay": true
            },
            "$ref": "#/components/schemas/exhook.socket_options"
          },
          "auto_reconnect": {
            "default": "60s",
            "description": "Whether to automatically reconnect (initialize) the gRPC server.</br>When gRPC is not available, Exhook tries to request the gRPC service at that interval and reinitialize the list of mounted hooks.",
            "oneOf": [
              {
                "example": "12m",
                "type": "string"
              },
              {
                "enum": [
                  false
                ],
                "type": "string"
              }
            ]
          },
          "pool_size": {
            "default": 8,
            "description": "The process pool size for gRPC client",
            "minimum": 1,
            "type": "integer"
          }
        },
        "type": "object"
      },
      "emqx_rule_api_schema.ctx_sub": {
        "required": [
          "event_type"
        ],
        "properties": {
          "event_type": {
            "description": "Event Type",
            "enum": [
              "session_subscribed"
            ],
            "type": "string"
          },
          "clientid": {
            "description": "The Client ID",
            "type": "string"
          },
          "username": {
            "description": "The User Name",
            "type": "string"
          },
          "payload": {
            "description": "The Message Payload",
            "type": "string"
          },
          "peerhost": {
            "description": "The IP Address of the Peer Client",
            "type": "string"
          },
          "topic": {
            "description": "Message Topic",
            "type": "string"
          },
          "publish_received_at": {
            "description": "The Time that this Message is Received",
            "type": "integer"
          },
          "qos": {
            "description": "The Message QoS",
            "enum": [
              0,
              1,
              2
            ],
            "type": "string"
          }
        },
        "type": "object"
      },
      "emqx_conf_schema.cluster_k8s": {
        "properties": {
          "apiserver": {
            "default": "http://10.110.111.204:8080",
            "description": "Kubernetes API endpoint URL.",
            "readOnly": true,
            "type": "string"
          },
          "service_name": {
            "default": "emqx",
            "description": "EMQX broker service name.",
            "readOnly": true,
            "type": "string"
          },
          "address_type": {
            "default": "ip",
            "description": "Address type used for connecting to the discovered nodes.</br>Setting <code>cluster.k8s.address_type</code> to <code>ip</code> will</br>make EMQX to discover IP addresses of peer nodes from Kubernetes API.</br>",
            "enum": [
              "ip",
              "dns",
              "hostname"
            ],
            "readOnly": true,
            "type": "string"
          },
          "namespace": {
            "default": "default",
            "description": "Kubernetes namespace.",
            "readOnly": true,
            "type": "string"
          },
          "suffix": {
            "default": "pod.local",
            "description": "Node name suffix.</br>Note: this parameter is only relevant when <code>address_type</code> is <code>dns</code></br>or <code>hostname</code>.",
            "readOnly": true,
            "type": "string"
          }
        },
        "type": "object"
      },
      "emqx_mgmt_api_publish.publish_message_info": {
        "required": [
          "payload",
          "topic"
        ],
        "properties": {
          "id": {
            "description": "Internal Message ID",
            "type": "string"
          },
          "topic": {
            "description": "Topic Name",
            "example": "api/example/topic",
            "type": "string"
          },
          "qos": {
            "default": 0,
            "description": "MQTT QoS",
            "enum": [
              0,
              1,
              2
            ],
            "type": "string"
          },
          "clientid": {
            "description": "From client ID",
            "example": "api_example_client",
            "type": "string"
          },
          "payload": {
            "description": "MQTT Payload",
            "example": "hello emqx api",
            "type": "string"
          },
          "retain": {
            "default": false,
            "description": "MQTT Retain Message",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "gateway.clientinfo_override": {
        "properties": {
          "username": {
            "description": "Template for overriding username.",
            "type": "string"
          },
          "password": {
            "description": "Template for overriding password.",
            "type": "string"
          },
          "clientid": {
            "description": "Template for overriding clientid.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "statsd.statsd": {
        "required": [
          "flush_time_interval",
          "sample_time_interval",
          "server",
          "enable"
        ],
        "properties": {
          "enable": {
            "default": false,
            "description": "Turn Statsd data pushing on or off",
            "type": "boolean"
          },
          "server": {
            "default": "127.0.0.1:8125",
            "description": "URL of Statsd server",
            "example": "127.0.0.1:80",
            "type": "string"
          },
          "sample_time_interval": {
            "default": "10s",
            "description": "Data collection interval in second.",
            "example": "32s",
            "type": "string"
          },
          "flush_time_interval": {
            "default": "10s",
            "description": "Data reporting interval, in second.",
            "example": "32s",
            "type": "string"
          }
        },
        "type": "object"
      },
      "emqx_rule_api_schema.rule_events": {
        "required": [
          "event"
        ],
        "properties": {
          "event": {
            "description": "The event topics",
            "enum": [
              "$events/client_connected",
              "$events/client_disconnected",
              "$events/client_connack",
              "$events/client_check_authz_complete",
              "$events/session_subscribed",
              "$events/session_unsubscribed",
              "$events/message_publish",
              "$events/message_delivered",
              "$events/message_acked",
              "$events/message_dropped",
              "$events/delivery_dropped"
            ],
            "type": "string"
          },
          "title": {
            "description": "The title",
            "example": "some title",
            "type": "string"
          },
          "description": {
            "description": "The description",
            "example": "some desc",
            "type": "string"
          },
          "columns": {
            "description": "The columns",
            "example": {},
            "type": "object"
          },
          "test_columns": {
            "description": "The test columns",
            "example": {},
            "type": "object"
          },
          "sql_example": {
            "description": "The sql_example",
            "type": "string"
          }
        },
        "type": "object"
      },
      "exhook.socket_options": {
        "properties": {
          "keepalive": {
            "default": true,
            "description": "Enables/disables periodic transmission on a connected socket when no other data is exchanged.</br>If the other end does not respond, the connection is considered broken and an error message is sent to the controlling process.",
            "type": "boolean"
          },
          "nodelay": {
            "default": true,
            "description": "If true, option TCP_NODELAY is turned on for the socket,</br>which means that also small amounts of data are sent immediately",
            "type": "boolean"
          },
          "recbuf": {
            "description": "The minimum size of receive buffer to use for the socket",
            "example": "64KB",
            "type": "string"
          },
          "sndbuf": {
            "description": "The minimum size of send buffer to use for the socket",
            "example": "16KB",
            "type": "string"
          }
        },
        "type": "object"
      },
      "emqx_mgmt_api_clients.keepalive": {
        "properties": {
          "interval": {
            "description": "Keepalive time, with the unit of second",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "listeners.status": {
        "properties": {
          "max_connections": {
            "description": "Max connections",
            "oneOf": [
              {
                "type": "integer"
              },
              {
                "enum": [
                  "infinity"
                ],
                "type": "string"
              }
            ]
          },
          "current_connections": {
            "description": "Current connections",
            "minimum": 0,
            "type": "integer"
          }
        },
        "type": "object"
      },
      "listeners.ws_not_required_bind": {
        "required": [
          "id",
          "type"
        ],
        "properties": {
          "type": {
            "description": "Listener type",
            "enum": [
              "ws"
            ],
            "type": "string"
          },
          "running": {
            "description": "Listener status",
            "type": "boolean"
          },
          "id": {
            "description": "Listener id",
            "type": "string"
          },
          "current_connections": {
            "description": "Current connections",
            "minimum": 0,
            "type": "integer"
          },
          "bind": {
            "default": 8083,
            "description": "</br>IP address and port for the listening socket.</br>",
            "oneOf": [
              {
                "type": "integer"
              },
              {
                "example": "127.0.0.1:80",
                "type": "string"
              }
            ]
          },
          "enabled": {
            "default": true,
            "description": "</br>Enable listener.</br>",
            "type": "boolean"
          },
          "acceptors": {
            "default": 16,
            "description": "</br>The size of the listener's receiving pool.</br>",
            "minimum": 1,
            "type": "integer"
          },
          "max_connections": {
            "default": "infinity",
            "description": "</br>The maximum number of concurrent connections allowed by the listener.</br>",
            "oneOf": [
              {
                "minimum": 1,
                "type": "integer"
              },
              {
                "enum": [
                  "infinity"
                ],
                "type": "string"
              }
            ]
          },
          "mountpoint": {
            "default": "",
            "description": "</br>When publishing or subscribing, prefix all topics with a mountpoint string.</br>The prefixed string will be removed from the topic name when the message</br>is delivered to the subscriber. The mountpoint is a way that users can use</br>to implement isolation of message routing between different listeners.</br>For example if a client A subscribes to `t` with `listeners.tcp.\\<name>.mountpoint`</br>set to `some_tenant`, then the client actually subscribes to the topic</br>`some_tenant/t`. Similarly, if another client B (connected to the same listener</br>as the client A) sends a message to topic `t`, the message is routed</br>to all the clients subscribed `some_tenant/t`, so client A will receive the</br>message, with topic name `t`.</br>Set to `\"\"` to disable the feature.</br></br>Variables in mountpoint string:</br>  - <code>${clientid}</code>: clientid</br>  - <code>${username}</code>: username</br>",
            "type": "string"
          },
          "zone": {
            "default": "default",
            "description": "</br>The configuration zone to which the listener belongs.</br>",
            "type": "string"
          },
          "limiter": {
            "default": {
              "connection": "default"
            },
            "description": "</br>Type of the rate limit.</br>",
            "properties": {
              "$ratelimit_name": {
                "example": "retainer",
                "type": "string"
              }
            },
            "type": "object"
          },
          "enable_authn": {
            "default": true,
            "description": "</br>Set <code>true</code> (default) to enable client authentication on this listener.</br>When set to <code>false</code> clients will be allowed to connect without authentication.</br>",
            "type": "boolean"
          },
          "access_rules": {
            "default": [
              "allow all"
            ],
            "description": "</br>The access control rules for this listener.</br>See: https://github.com/emqtt/esockd#allowdeny</br>",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "proxy_protocol": {
            "default": false,
            "description": "</br>Enable the Proxy Protocol V1/2 if the EMQX cluster is deployed behind HAProxy or Nginx.</br>See: https://www.haproxy.com/blog/haproxy/proxy-protocol/</br>",
            "type": "boolean"
          },
          "proxy_protocol_timeout": {
            "default": "3s",
            "description": "</br>Timeout for proxy protocol. EMQX will close the TCP connection if proxy protocol packet is not received within the timeout.</br>",
            "example": "12m",
            "type": "string"
          },
          "tcp_options": {
            "$ref": "#/components/schemas/broker.tcp_opts"
          },
          "websocket": {
            "$ref": "#/components/schemas/broker.ws_opts"
          }
        },
        "type": "object"
      },
      "emqx_authn_api.request_user_update": {
        "required": [
          "password"
        ],
        "properties": {
          "password": {
            "type": "string"
          },
          "is_superuser": {
            "default": false,
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "emqx_gateway_api_clients.subscription": {
        "properties": {
          "topic": {
            "description": "Topic Filter/Name",
            "type": "string"
          },
          "qos": {
            "description": "QoS level, enum: 0, 1, 2",
            "type": "integer"
          },
          "nl": {
            "description": "No Local option, enum: 0, 1",
            "type": "integer"
          },
          "rap": {
            "description": "Retain as Published option, enum: 0, 1",
            "type": "integer"
          },
          "rh": {
            "description": "Retain Handling option, enum: 0, 1, 2",
            "type": "integer"
          },
          "sub_props": {
            "description": "Subscription properties",
            "$ref": "#/components/schemas/emqx_gateway_api_clients.extra_sub_props"
          }
        },
        "type": "object"
      },
      "emqx_gateway_api.ssl_listener": {
        "properties": {
          "id": {
            "description": "Listener ID",
            "type": "string"
          },
          "type": {
            "description": "Listener Type",
            "enum": [
              "ssl"
            ],
            "type": "string"
          },
          "name": {
            "description": "Listener Name",
            "type": "string"
          },
          "running": {
            "description": "Listener Running status",
            "type": "boolean"
          },
          "acceptors": {
            "default": 16,
            "description": "Size of the acceptor pool.",
            "type": "integer"
          },
          "tcp_options": {
            "description": "Setting the TCP socket options.",
            "$ref": "#/components/schemas/broker.tcp_opts"
          },
          "proxy_protocol": {
            "default": false,
            "description": "Enable the Proxy Protocol V1/2 if the EMQX cluster is deployed behind HAProxy or Nginx.</br>See: https://www.haproxy.com/blog/haproxy/proxy-protocol/",
            "type": "boolean"
          },
          "proxy_protocol_timeout": {
            "default": "15s",
            "description": "Timeout for proxy protocol.</br>EMQX will close the TCP connection if proxy protocol packet is not received within the timeout.",
            "example": "12m",
            "type": "string"
          },
          "enable": {
            "default": true,
            "description": "Enable the listener.",
            "type": "boolean"
          },
          "bind": {
            "description": "The IP address and port that the listener will bind.",
            "oneOf": [
              {
                "type": "integer"
              },
              {
                "example": "127.0.0.1:80",
                "type": "string"
              }
            ]
          },
          "max_connections": {
            "default": 1024,
            "description": "Maximum number of concurrent connections.",
            "type": "integer"
          },
          "max_conn_rate": {
            "default": 1000,
            "description": "Maximum connections per second.",
            "type": "integer"
          },
          "authentication": {
            "description": "Default authentication configs for all the gateway listeners. For per-listener overrides see <code>authentication</code></br> in listener configs",
            "oneOf": [
              {
                "$ref": "#/components/schemas/authn-scram-builtin_db.authentication"
              },
              {
                "$ref": "#/components/schemas/authn-jwt.jwks"
              },
              {
                "$ref": "#/components/schemas/authn-jwt.public-key"
              },
              {
                "$ref": "#/components/schemas/authn-jwt.hmac-based"
              },
              {
                "$ref": "#/components/schemas/authn-http.post"
              },
              {
                "$ref": "#/components/schemas/authn-http.get"
              },
              {
                "$ref": "#/components/schemas/authn-redis.sentinel"
              },
              {
                "$ref": "#/components/schemas/authn-redis.cluster"
              },
              {
                "$ref": "#/components/schemas/authn-redis.standalone"
              },
              {
                "$ref": "#/components/schemas/authn-mongodb.sharded-cluster"
              },
              {
                "$ref": "#/components/schemas/authn-mongodb.replica-set"
              },
              {
                "$ref": "#/components/schemas/authn-mongodb.standalone"
              },
              {
                "$ref": "#/components/schemas/authn-postgresql.authentication"
              },
              {
                "$ref": "#/components/schemas/authn-mysql.authentication"
              },
              {
                "$ref": "#/components/schemas/authn-builtin_db.authentication"
              }
            ]
          },
          "enable_authn": {
            "default": true,
            "description": "Set <code>true</code> (default) to enable client authentication on this listener. </br>When set to <code>false</code> clients will be allowed to connect without authentication.",
            "type": "boolean"
          },
          "mountpoint": {
            "description": "When publishing or subscribing, prefix all topics with a mountpoint string.</br>The prefixed string will be removed from the topic name when the message is delivered to the subscriber. The mountpoint is a way that users can use to implement isolation of message routing between different listeners.</br>For example if a client A subscribes to `t` with `listeners.tcp.\\<name>.mountpoint` set to `some_tenant`, then the client actually subscribes to the topic `some_tenant/t`. Similarly, if another client B (connected to the same listener as the client A) sends a message to topic `t`, the message is routed to all the clients subscribed `some_tenant/t`, so client A will receive the message, with topic name `t`. Set to `\"\"` to disable the feature.</br>Variables in mountpoint string:</br>  - <code>${clientid}</code>: clientid</br>  - <code>${username}</code>: username</br>",
            "type": "string"
          },
          "access_rules": {
            "default": "",
            "description": "The access control rules for this listener.</br>See: https://github.com/emqtt/esockd#allowdeny",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "ssl_options": {
            "description": "SSL Socket options.",
            "$ref": "#/components/schemas/broker.listener_ssl_opts"
          }
        },
        "type": "object"
      },
      "emqx_bridge_mqtt_schema.get_egress": {
        "required": [
          "payload",
          "retain",
          "remote_qos",
          "remote_topic",
          "connector",
          "direction",
          "name",
          "type"
        ],
        "properties": {
          "metrics": {
            "description": "Bridge metrics.",
            "$ref": "#/components/schemas/bridge.metrics"
          },
          "node_metrics": {
            "description": "Node metrics.",
            "items": {
              "$ref": "#/components/schemas/bridge.node_metrics"
            },
            "type": "array"
          },
          "status": {
            "description": "The status of the bridge",
            "enum": [
              "connected",
              "disconnected",
              "connecting"
            ],
            "type": "string"
          },
          "node_status": {
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/bridge.node_status"
            },
            "type": "array"
          },
          "type": {
            "description": "The bridge type.",
            "enum": [
              "mqtt"
            ],
            "type": "string"
          },
          "name": {
            "description": "Bridge name, used as a human-readable description of the bridge.",
            "type": "string"
          },
          "direction": {
            "default": "egress",
            "description": "The direction of the bridge. Can be one of 'ingress' or 'egress'.</br>The egress config defines how this bridge forwards messages from the local broker to the remote</br>broker.</br>Template with variables is allowed in 'remote_topic', 'qos', 'retain', 'payload'.</br>NOTE: if this bridge is used as the action of a rule (emqx rule engine), and also local_topic</br>is configured, then both the data got from the rule and the MQTT messages that matches</br>local_topic will be forwarded.</br>",
            "enum": [
              "egress"
            ],
            "type": "string"
          },
          "connector": {
            "description": "</br>The ID or the configs of the connector to be used for this bridge. Connector IDs must be of format:</br><code>{type}:{name}</code>.</br>In config files, you can find the corresponding config entry for a connector by such path:</br>'connectors.{type}.{name}'.</br>",
            "example": "mqtt:my_mqtt_connector",
            "oneOf": [
              {
                "$ref": "#/components/schemas/connector-mqtt.connector"
              },
              {
                "type": "string"
              }
            ]
          },
          "local_topic": {
            "description": "The local topic to be forwarded to the remote broker",
            "type": "string"
          },
          "remote_topic": {
            "description": "</br>Forward to which topic of the remote broker.</br>Template with variables is allowed.</br>",
            "type": "string"
          },
          "remote_qos": {
            "description": "</br>The QoS of the MQTT message to be sent.</br>Template with variables is allowed.</br>",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "enum": [
                  0,
                  1,
                  2
                ],
                "type": "string"
              }
            ]
          },
          "retain": {
            "description": "</br>The 'retain' flag of the MQTT message to be sent.</br>Template with variables is allowed.</br>",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "boolean"
              }
            ]
          },
          "payload": {
            "description": "</br>The payload of the MQTT message to be sent.</br>Template with variables is allowed.</br>",
            "type": "string"
          }
        },
        "type": "object"
      },
      "bridge.get": {
        "required": [
          "url",
          "name",
          "type"
        ],
        "properties": {
          "metrics": {
            "description": "Bridge metrics.",
            "$ref": "#/components/schemas/bridge.metrics"
          },
          "node_metrics": {
            "description": "Node metrics.",
            "items": {
              "$ref": "#/components/schemas/bridge.node_metrics"
            },
            "type": "array"
          },
          "status": {
            "description": "The status of the bridge",
            "enum": [
              "connected",
              "disconnected",
              "connecting"
            ],
            "type": "string"
          },
          "node_status": {
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/bridge.node_status"
            },
            "type": "array"
          },
          "type": {
            "description": "The Bridge Type",
            "enum": [
              "webhook"
            ],
            "type": "string"
          },
          "name": {
            "description": "Bridge name, used as a human-readable description of the bridge.",
            "type": "string"
          },
          "enable": {
            "default": true,
            "description": "Enable or disable this bridge",
            "type": "boolean"
          },
          "direction": {
            "default": "egress",
            "description": "The direction of this bridge, MUST be 'egress'",
            "enum": [
              "egress"
            ],
            "type": "string"
          },
          "connect_timeout": {
            "default": "15s",
            "description": "The timeout when connecting to the HTTP server.",
            "example": "32s",
            "type": "string"
          },
          "max_retries": {
            "default": 5,
            "description": "Max retry times if error on sending request.",
            "minimum": 0,
            "type": "integer"
          },
          "retry_interval": {
            "default": "1s",
            "description": "Interval between retries.",
            "example": "12m",
            "type": "string"
          },
          "pool_type": {
            "default": "random",
            "description": "The type of the pool. Can be one of `random`, `hash`.",
            "enum": [
              "random",
              "hash"
            ],
            "type": "string"
          },
          "pool_size": {
            "default": 8,
            "description": "The pool size.",
            "minimum": 1,
            "type": "integer"
          },
          "enable_pipelining": {
            "default": 100,
            "description": "Whether to send HTTP requests continuously, when set to 0, it means that after each HTTP request is sent, you need to wait for the server to return and then continue to send the next request.",
            "minimum": 1,
            "type": "integer"
          },
          "request": {
            "description": "</br>If the request is provided, the caller can send HTTP requests via</br><code>emqx_resource:query(ResourceId, {send_message, BridgeId, Message})</code></br>",
            "$ref": "#/components/schemas/connector-http.request"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/broker.ssl_client_opts"
          },
          "url": {
            "description": "</br>The URL of the HTTP Bridge.</br>Template with variables is allowed in the path, but variables cannot be used in the scheme, host,</br>or port part.</br>For example, <code> http://localhost:9901/${topic} </code> is allowed, but</br><code> http://${host}:9901/message </code> or <code> http://localhost:${port}/message </code></br>is not allowed.</br>",
            "type": "string"
          },
          "local_topic": {
            "description": "</br>The MQTT topic filter to be forwarded to the HTTP server. All MQTT 'PUBLISH' messages with the topic</br>matching the local_topic will be forwarded.</br>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is</br>configured, then both the data got from the rule and the MQTT messages that match local_topic</br>will be forwarded.</br>",
            "type": "string"
          },
          "method": {
            "default": "post",
            "description": "</br>The method of the HTTP request. All the available methods are: post, put, get, delete.</br>Template with variables is allowed.</br>",
            "enum": [
              "post",
              "put",
              "get",
              "delete"
            ],
            "type": "string"
          },
          "headers": {
            "default": {
              "accept": "application/json",
              "cache-control": "no-cache",
              "connection": "keep-alive",
              "content-type": "application/json",
              "keep-alive": "timeout=5"
            },
            "description": "</br>The headers of the HTTP request.</br>Template with variables is allowed.</br>",
            "example": {},
            "type": "object"
          },
          "body": {
            "default": "${payload}",
            "description": "</br>The body of the HTTP request.</br>Template with variables is allowed.</br>",
            "type": "string"
          },
          "request_timeout": {
            "default": "15s",
            "description": "HTTP request timeout.",
            "example": "32s",
            "type": "string"
          }
        },
        "type": "object"
      },
      "emqx_authz_api_schema.http_post": {
        "required": [
          "url",
          "type",
          "method"
        ],
        "properties": {
          "method": {
            "default": "post",
            "description": "HTTP method.",
            "enum": [
              "post"
            ],
            "type": "string"
          },
          "headers": {
            "default": {
              "accept": "application/json",
              "cache-control": "no-cache",
              "connection": "keep-alive",
              "content-type": "application/json",
              "keep-alive": "timeout=30, max=1000"
            },
            "description": "List of HTTP Headers.",
            "example": {},
            "type": "object"
          },
          "enable": {
            "default": true,
            "description": "Set to <code>true</code> or <code>false</code> to disable this ACL provider",
            "type": "boolean"
          },
          "type": {
            "default": "http",
            "description": "Backend type.",
            "enum": [
              "http"
            ],
            "type": "string"
          },
          "url": {
            "description": "URL of the auth server.",
            "type": "string"
          },
          "body": {
            "description": "HTTP request body.",
            "example": {},
            "type": "object"
          },
          "request_timeout": {
            "default": "30s",
            "description": "Request timeout.",
            "type": "string"
          },
          "connect_timeout": {
            "default": "15s",
            "description": "The timeout when connecting to the HTTP server.",
            "example": "32s",
            "type": "string"
          },
          "enable_pipelining": {
            "default": 100,
            "description": "Whether to send HTTP requests continuously, when set to 0, it means that after each HTTP request is sent, you need to wait for the server to return and then continue to send the next request.",
            "minimum": 1,
            "type": "integer"
          },
          "max_retries": {
            "default": 5,
            "description": "Max retry times if error on sending request.",
            "minimum": 0,
            "type": "integer"
          },
          "pool_size": {
            "default": 8,
            "description": "The pool size.",
            "minimum": 1,
            "type": "integer"
          },
          "request": {
            "description": "</br>If the request is provided, the caller can send HTTP requests via</br><code>emqx_resource:query(ResourceId, {send_message, BridgeId, Message})</code></br>",
            "$ref": "#/components/schemas/connector-http.request"
          },
          "retry_interval": {
            "default": "1s",
            "description": "Interval between retries.",
            "example": "12m",
            "type": "string"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/broker.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "retainer.mnesia_config": {
        "properties": {
          "type": {
            "default": "built_in_database",
            "description": "Backend type.",
            "enum": [
              "built_in_database"
            ],
            "type": "string"
          },
          "storage_type": {
            "default": "ram",
            "description": "Specifies whether the messages are stored in RAM or persisted on disc.",
            "enum": [
              "ram",
              "disc"
            ],
            "type": "string"
          },
          "max_retained_messages": {
            "default": 0,
            "description": "Maximum number of retained messages. 0 means no limit.",
            "minimum": 0,
            "type": "integer"
          },
          "index_specs": {
            "default": [
              [
                1,
                2,
                3
              ],
              [
                1,
                3
              ],
              [
                2,
                3
              ],
              [
                3
              ]
            ],
            "description": "Retainer index specifications: list of arrays of positive ascending integers. Each array specifies an index. Numbers in an index specification are 1-based word positions in topics. Words from specified positions will be used for indexing.</br>For example, it is good to have <code>[2, 4]</code> index to optimize <code>+/X/+/Y/...</code> topic wildcard subscriptions.",
            "example": [
              [
                2,
                4
              ],
              [
                1,
                3
              ]
            ],
            "items": {
              "type": "integer"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "emqx_conf_schema.console_handler": {
        "properties": {
          "enable": {
            "default": false,
            "description": "Enable this log handler.",
            "type": "boolean"
          },
          "level": {
            "default": "warning",
            "description": "</br>The log level for the current log handler.</br>Defaults to warning.</br>",
            "enum": [
              "debug",
              "info",
              "notice",
              "warning",
              "error",
              "critical",
              "alert",
              "emergency",
              "all"
            ],
            "type": "string"
          },
          "time_offset": {
            "default": "system",
            "description": "</br>The time offset to be used when formatting the timestamp.</br>Can be one of:</br>  - <code>system</code>: the time offset used by the local system</br>  - <code>utc</code>: the UTC time offset</br>  - <code>+-[hh]:[mm]</code>: user specified time offset, such as \"-02:00\" or \"+00:00\"</br>Defaults to: <code>system</code>.</br>",
            "type": "string"
          },
          "chars_limit": {
            "default": "unlimited",
            "description": "Set the maximum length of a single log message. If this length is exceeded, the log message will be truncated.",
            "oneOf": [
              {
                "minimum": 100,
                "type": "integer"
              },
              {
                "enum": [
                  "unlimited"
                ],
                "type": "string"
              }
            ]
          },
          "formatter": {
            "default": "text",
            "description": "Choose log formatter. <code>text</code> for free text, and <code>json</code> for structured logging.",
            "enum": [
              "text",
              "json"
            ],
            "type": "string"
          },
          "single_line": {
            "default": true,
            "description": "Print logs in a single line if set to true. Otherwise, log messages may span multiple lines.",
            "type": "boolean"
          },
          "sync_mode_qlen": {
            "default": 100,
            "description": "As long as the number of buffered log events is lower than this value,</br>all log events are handled asynchronously. This means that the client process sending the log event,</br>by calling a log function in the Logger API, does not wait for a response from the handler</br>but continues executing immediately after the event is sent.</br>It is not affected by the time it takes the handler to print the event to the log device.</br>If the message queue grows larger than this value,</br>the handler starts handling log events synchronously instead,</br>meaning that the client process sending the event must wait for a response.</br>When the handler reduces the message queue to a level below the sync_mode_qlen threshold,</br>asynchronous operation is resumed.</br>",
            "minimum": 0,
            "type": "integer"
          },
          "drop_mode_qlen": {
            "default": 3000,
            "description": "When the number of buffered log events is larger than this value, the new log events are dropped.</br>When drop mode is activated or deactivated, a message is printed in the logs.",
            "minimum": 1,
            "type": "integer"
          },
          "flush_qlen": {
            "default": 8000,
            "description": "If the number of buffered log events grows larger than this threshold, a flush (delete) operation takes place.</br>To flush events, the handler discards the buffered log messages without logging.",
            "minimum": 1,
            "type": "integer"
          },
          "overload_kill": {
            "$ref": "#/components/schemas/emqx_conf_schema.log_overload_kill"
          },
          "burst_limit": {
            "$ref": "#/components/schemas/emqx_conf_schema.log_burst_limit"
          },
          "supervisor_reports": {
            "default": "error",
            "description": "</br>Type of supervisor reports that are logged. Defaults to <code>error</code></br>  - <code>error</code>: only log errors in the Erlang processes.</br>  - <code>progress</code>: log process startup.</br>",
            "enum": [
              "error",
              "progress"
            ],
            "type": "string"
          },
          "max_depth": {
            "default": 100,
            "description": "Maximum depth for Erlang term log formatting and Erlang process message queue inspection.",
            "oneOf": [
              {
                "minimum": 0,
                "type": "integer"
              },
              {
                "enum": [
                  "unlimited"
                ],
                "type": "string"
              }
            ]
          }
        },
        "type": "object"
      },
      "broker.mqtt_tcp_listener": {
        "required": [
          "bind"
        ],
        "properties": {
          "enabled": {
            "default": true,
            "description": "</br>Enable listener.</br>",
            "type": "boolean"
          },
          "bind": {
            "default": 1883,
            "description": "</br>IP address and port for the listening socket.</br>",
            "oneOf": [
              {
                "type": "integer"
              },
              {
                "example": "127.0.0.1:80",
                "type": "string"
              }
            ]
          },
          "acceptors": {
            "default": 16,
            "description": "</br>The size of the listener's receiving pool.</br>",
            "minimum": 1,
            "type": "integer"
          },
          "max_connections": {
            "default": "infinity",
            "description": "</br>The maximum number of concurrent connections allowed by the listener.</br>",
            "oneOf": [
              {
                "minimum": 1,
                "type": "integer"
              },
              {
                "enum": [
                  "infinity"
                ],
                "type": "string"
              }
            ]
          },
          "mountpoint": {
            "default": "",
            "description": "</br>When publishing or subscribing, prefix all topics with a mountpoint string.</br>The prefixed string will be removed from the topic name when the message</br>is delivered to the subscriber. The mountpoint is a way that users can use</br>to implement isolation of message routing between different listeners.</br>For example if a client A subscribes to `t` with `listeners.tcp.\\<name>.mountpoint`</br>set to `some_tenant`, then the client actually subscribes to the topic</br>`some_tenant/t`. Similarly, if another client B (connected to the same listener</br>as the client A) sends a message to topic `t`, the message is routed</br>to all the clients subscribed `some_tenant/t`, so client A will receive the</br>message, with topic name `t`.</br>Set to `\"\"` to disable the feature.</br></br>Variables in mountpoint string:</br>  - <code>${clientid}</code>: clientid</br>  - <code>${username}</code>: username</br>",
            "type": "string"
          },
          "zone": {
            "default": "default",
            "description": "</br>The configuration zone to which the listener belongs.</br>",
            "type": "string"
          },
          "limiter": {
            "default": {
              "connection": "default"
            },
            "description": "</br>Type of the rate limit.</br>",
            "properties": {
              "$ratelimit_name": {
                "example": "retainer",
                "type": "string"
              }
            },
            "type": "object"
          },
          "enable_authn": {
            "default": true,
            "description": "</br>Set <code>true</code> (default) to enable client authentication on this listener.</br>When set to <code>false</code> clients will be allowed to connect without authentication.</br>",
            "type": "boolean"
          },
          "access_rules": {
            "default": [
              "allow all"
            ],
            "description": "</br>The access control rules for this listener.</br>See: https://github.com/emqtt/esockd#allowdeny</br>",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "proxy_protocol": {
            "default": false,
            "description": "</br>Enable the Proxy Protocol V1/2 if the EMQX cluster is deployed behind HAProxy or Nginx.</br>See: https://www.haproxy.com/blog/haproxy/proxy-protocol/</br>",
            "type": "boolean"
          },
          "proxy_protocol_timeout": {
            "default": "3s",
            "description": "</br>Timeout for proxy protocol. EMQX will close the TCP connection if proxy protocol packet is not received within the timeout.</br>",
            "example": "12m",
            "type": "string"
          },
          "authentication": {
            "description": "</br>Per-listener authentication override.</br>Authentication can be one single authenticator instance or a chain of authenticators as an array.</br>When authenticating a login (username, client ID, etc.) the authenticators are checked in the configured order.</br></br>",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/authn-scram-builtin_db.authentication"
                },
                {
                  "$ref": "#/components/schemas/authn-jwt.jwks"
                },
                {
                  "$ref": "#/components/schemas/authn-jwt.public-key"
                },
                {
                  "$ref": "#/components/schemas/authn-jwt.hmac-based"
                },
                {
                  "$ref": "#/components/schemas/authn-http.post"
                },
                {
                  "$ref": "#/components/schemas/authn-http.get"
                },
                {
                  "$ref": "#/components/schemas/authn-redis.sentinel"
                },
                {
                  "$ref": "#/components/schemas/authn-redis.cluster"
                },
                {
                  "$ref": "#/components/schemas/authn-redis.standalone"
                },
                {
                  "$ref": "#/components/schemas/authn-mongodb.sharded-cluster"
                },
                {
                  "$ref": "#/components/schemas/authn-mongodb.replica-set"
                },
                {
                  "$ref": "#/components/schemas/authn-mongodb.standalone"
                },
                {
                  "$ref": "#/components/schemas/authn-postgresql.authentication"
                },
                {
                  "$ref": "#/components/schemas/authn-mysql.authentication"
                },
                {
                  "$ref": "#/components/schemas/authn-builtin_db.authentication"
                }
              ]
            },
            "type": "array"
          },
          "tcp_options": {
            "$ref": "#/components/schemas/broker.tcp_opts"
          }
        },
        "type": "object"
      },
      "emqx_authn_schema.metrics_status_fields": {
        "properties": {
          "resource_metrics": {
            "description": "The metrics of the resource.",
            "$ref": "#/components/schemas/emqx_authn_schema.resource_metrics"
          },
          "node_resource_metrics": {
            "description": "The metrics of the resource for each node.",
            "$ref": "#/components/schemas/emqx_authn_schema.node_resource_metrics"
          },
          "metrics": {
            "description": "The metrics of the resource.",
            "$ref": "#/components/schemas/emqx_authn_schema.metrics"
          },
          "node_metrics": {
            "description": "The metrics of the resource for each node.",
            "$ref": "#/components/schemas/emqx_authn_schema.node_metrics"
          },
          "status": {
            "description": "The status of the resource.",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "type": "string"
          },
          "node_status": {
            "description": "The status of the resource for each node.",
            "$ref": "#/components/schemas/emqx_authn_schema.node_status"
          },
          "node_error": {
            "description": "The error of node.",
            "$ref": "#/components/schemas/emqx_authn_schema.node_error"
          }
        },
        "type": "object"
      },
      "listeners.tcp_not_required_bind": {
        "required": [
          "id",
          "type"
        ],
        "properties": {
          "type": {
            "description": "Listener type",
            "enum": [
              "tcp"
            ],
            "type": "string"
          },
          "running": {
            "description": "Listener status",
            "type": "boolean"
          },
          "id": {
            "description": "Listener id",
            "type": "string"
          },
          "current_connections": {
            "description": "Current connections",
            "minimum": 0,
            "type": "integer"
          },
          "bind": {
            "default": 1883,
            "description": "</br>IP address and port for the listening socket.</br>",
            "oneOf": [
              {
                "type": "integer"
              },
              {
                "example": "127.0.0.1:80",
                "type": "string"
              }
            ]
          },
          "enabled": {
            "default": true,
            "description": "</br>Enable listener.</br>",
            "type": "boolean"
          },
          "acceptors": {
            "default": 16,
            "description": "</br>The size of the listener's receiving pool.</br>",
            "minimum": 1,
            "type": "integer"
          },
          "max_connections": {
            "default": "infinity",
            "description": "</br>The maximum number of concurrent connections allowed by the listener.</br>",
            "oneOf": [
              {
                "minimum": 1,
                "type": "integer"
              },
              {
                "enum": [
                  "infinity"
                ],
                "type": "string"
              }
            ]
          },
          "mountpoint": {
            "default": "",
            "description": "</br>When publishing or subscribing, prefix all topics with a mountpoint string.</br>The prefixed string will be removed from the topic name when the message</br>is delivered to the subscriber. The mountpoint is a way that users can use</br>to implement isolation of message routing between different listeners.</br>For example if a client A subscribes to `t` with `listeners.tcp.\\<name>.mountpoint`</br>set to `some_tenant`, then the client actually subscribes to the topic</br>`some_tenant/t`. Similarly, if another client B (connected to the same listener</br>as the client A) sends a message to topic `t`, the message is routed</br>to all the clients subscribed `some_tenant/t`, so client A will receive the</br>message, with topic name `t`.</br>Set to `\"\"` to disable the feature.</br></br>Variables in mountpoint string:</br>  - <code>${clientid}</code>: clientid</br>  - <code>${username}</code>: username</br>",
            "type": "string"
          },
          "zone": {
            "default": "default",
            "description": "</br>The configuration zone to which the listener belongs.</br>",
            "type": "string"
          },
          "limiter": {
            "default": {
              "connection": "default"
            },
            "description": "</br>Type of the rate limit.</br>",
            "properties": {
              "$ratelimit_name": {
                "example": "retainer",
                "type": "string"
              }
            },
            "type": "object"
          },
          "enable_authn": {
            "default": true,
            "description": "</br>Set <code>true</code> (default) to enable client authentication on this listener.</br>When set to <code>false</code> clients will be allowed to connect without authentication.</br>",
            "type": "boolean"
          },
          "access_rules": {
            "default": [
              "allow all"
            ],
            "description": "</br>The access control rules for this listener.</br>See: https://github.com/emqtt/esockd#allowdeny</br>",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "proxy_protocol": {
            "default": false,
            "description": "</br>Enable the Proxy Protocol V1/2 if the EMQX cluster is deployed behind HAProxy or Nginx.</br>See: https://www.haproxy.com/blog/haproxy/proxy-protocol/</br>",
            "type": "boolean"
          },
          "proxy_protocol_timeout": {
            "default": "3s",
            "description": "</br>Timeout for proxy protocol. EMQX will close the TCP connection if proxy protocol packet is not received within the timeout.</br>",
            "example": "12m",
            "type": "string"
          },
          "tcp_options": {
            "$ref": "#/components/schemas/broker.tcp_opts"
          }
        },
        "type": "object"
      },
      "public.meta": {
        "required": [
          "count"
        ],
        "properties": {
          "page": {
            "default": 1,
            "description": "Page number of the results to fetch.",
            "example": 1,
            "minimum": 1,
            "type": "integer"
          },
          "limit": {
            "default": 100,
            "description": "Results per page(max 1000)",
            "example": 50,
            "maximum": 1000,
            "minimum": 1,
            "type": "integer"
          },
          "count": {
            "description": "Results count.",
            "minimum": 0,
            "type": "integer"
          }
        },
        "type": "object"
      },
      "broker.sysmon_top": {
        "properties": {
          "num_items": {
            "default": 10,
            "description": "The number of top processes per monitoring group",
            "minimum": 0,
            "type": "integer"
          },
          "sample_interval": {
            "default": "2s",
            "description": "Specifies how often process top should be collected",
            "example": "12m",
            "type": "string"
          },
          "max_procs": {
            "default": 1000000,
            "description": "Stop collecting data when the number of processes</br>in the VM exceeds this value",
            "minimum": 0,
            "type": "integer"
          },
          "db_hostname": {
            "default": "",
            "description": "Hostname of the PostgreSQL database that collects the data points",
            "type": "string"
          },
          "db_port": {
            "default": 5432,
            "description": "Port of the PostgreSQL database that collects the data points",
            "type": "integer"
          },
          "db_username": {
            "default": "system_monitor",
            "description": "Username of the PostgreSQL database",
            "type": "string"
          },
          "db_password": {
            "default": "system_monitor_password",
            "description": "EMQX user password in the PostgreSQL database",
            "type": "string"
          },
          "db_name": {
            "default": "postgres",
            "description": "PostgreSQL database name",
            "type": "string"
          }
        },
        "type": "object"
      },
      "emqx_gateway_api_clients.extra_sub_props": {
        "properties": {
          "subid": {
            "description": "Only stomp protocol, a unique identity for the subscription. range: 1-65535.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "emqx_telemetry_api.status": {
        "properties": {
          "enable": {
            "default": true,
            "description": "Enable telemetry",
            "example": false,
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "authn-hash.bcrypt_rw": {
        "required": [
          "name"
        ],
        "properties": {
          "name": {
            "description": "BCRYPT password hashing.",
            "enum": [
              "bcrypt"
            ],
            "type": "string"
          },
          "salt_rounds": {
            "default": 10,
            "description": "Salt rounds for BCRYPT password generation.",
            "example": 10,
            "type": "integer"
          }
        },
        "type": "object"
      },
      "broker.event_names": {
        "properties": {
          "client_connected": {
            "default": true,
            "description": "Enable to publish client connected event messages",
            "type": "boolean"
          },
          "client_disconnected": {
            "default": true,
            "description": "Enable to publish client disconnected event messages.",
            "type": "boolean"
          },
          "client_subscribed": {
            "default": false,
            "description": "Enable to publish event message that client subscribed a topic successfully.",
            "type": "boolean"
          },
          "client_unsubscribed": {
            "default": false,
            "description": "Enable to publish event message that client unsubscribed a topic successfully.",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "gateway.dtls_opts": {
        "properties": {
          "cacertfile": {
            "description": "</br>Trusted PEM format CA certificates bundle file.</br>The certificates in this file are used to verify the TLS peer's certificates.</br>Append new certificates to the file if new CAs are to be trusted.</br>There is no need to restart EMQX to have the updated file loaded, because</br>the system regularly checks if file has been updated (and reload).</br>NOTE: invalidating (deleting) a certificate from the file will not affect</br>already established connections.</br>",
            "type": "string"
          },
          "certfile": {
            "description": "</br>PEM format certificates chain file.</br>The certificates in this file should be in reversed order of the certificate</br>issue chain. That is, the host's certificate should be placed in the beginning</br>of the file, followed by the immediate issuer certificate and so on.</br>Although the root CA certificate is optional, it should be placed at the end of</br>the file if it is to be added.</br>",
            "type": "string"
          },
          "keyfile": {
            "description": "</br>PEM format private key file.</br>",
            "type": "string"
          },
          "verify": {
            "default": "verify_none",
            "description": "</br>Enable or disable peer verification.</br>",
            "enum": [
              "verify_peer",
              "verify_none"
            ],
            "type": "string"
          },
          "reuse_sessions": {
            "default": true,
            "description": "</br>Enable TLS session reuse.</br>",
            "type": "boolean"
          },
          "depth": {
            "default": 10,
            "description": "</br>Maximum number of non-self-issued intermediate certificates that can follow the peer certificate in a valid certification path. So, if depth is 0 the PEER must be signed by the trusted ROOT-CA directly; if 1 the path can be PEER, CA, ROOT-CA; if 2 the path can be PEER, CA, CA, ROOT-CA, and so on. The default value is 10.</br>",
            "type": "integer"
          },
          "password": {
            "description": "</br>String containing the user's password.</br>Only used if the private key file is password-protected.</br>",
            "example": "",
            "type": "string"
          },
          "versions": {
            "default": [
              "dtlsv1.2",
              "dtlsv1"
            ],
            "description": "</br>All TLS/DTLS versions to be supported.</br>NOTE: PSK ciphers are suppressed by 'tlsv1.3' version config.</br>In case PSK cipher suites are intended, make sure to configured</br><code>['tlsv1.2', 'tlsv1.1']</code> here.</br>",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "ciphers": {
            "default": [
              "ECDHE-ECDSA-AES256-GCM-SHA384",
              "ECDHE-RSA-AES256-GCM-SHA384",
              "ECDHE-ECDSA-AES256-SHA384",
              "ECDHE-RSA-AES256-SHA384",
              "ECDH-ECDSA-AES256-GCM-SHA384",
              "ECDH-RSA-AES256-GCM-SHA384",
              "ECDH-ECDSA-AES256-SHA384",
              "ECDH-RSA-AES256-SHA384",
              "DHE-DSS-AES256-GCM-SHA384",
              "DHE-DSS-AES256-SHA256",
              "AES256-GCM-SHA384",
              "AES256-SHA256",
              "ECDHE-ECDSA-AES128-GCM-SHA256",
              "ECDHE-RSA-AES128-GCM-SHA256",
              "ECDHE-ECDSA-AES128-SHA256",
              "ECDHE-RSA-AES128-SHA256",
              "ECDH-ECDSA-AES128-GCM-SHA256",
              "ECDH-RSA-AES128-GCM-SHA256",
              "ECDH-ECDSA-AES128-SHA256",
              "ECDH-RSA-AES128-SHA256",
              "DHE-DSS-AES128-GCM-SHA256",
              "DHE-DSS-AES128-SHA256",
              "AES128-GCM-SHA256",
              "AES128-SHA256",
              "ECDHE-ECDSA-AES256-SHA",
              "ECDHE-RSA-AES256-SHA",
              "DHE-DSS-AES256-SHA",
              "ECDH-ECDSA-AES256-SHA",
              "ECDH-RSA-AES256-SHA",
              "ECDHE-ECDSA-AES128-SHA",
              "ECDHE-RSA-AES128-SHA",
              "DHE-DSS-AES128-SHA",
              "ECDH-ECDSA-AES128-SHA",
              "ECDH-RSA-AES128-SHA",
              "RSA-PSK-AES256-GCM-SHA384",
              "RSA-PSK-AES256-CBC-SHA384",
              "RSA-PSK-AES128-GCM-SHA256",
              "RSA-PSK-AES128-CBC-SHA256",
              "RSA-PSK-AES256-CBC-SHA",
              "RSA-PSK-AES128-CBC-SHA"
            ],
            "description": "</br>This config holds TLS cipher suite names separated by comma,</br>or as an array of strings. e.g.</br><code>\"TLS_AES_256_GCM_SHA384,TLS_AES_128_GCM_SHA256\"</code> or</br><code>[\"TLS_AES_256_GCM_SHA384\",\"TLS_AES_128_GCM_SHA256\"]</code>.</br></br>Ciphers (and their ordering) define the way in which the</br>client and server encrypts information over the network connection.</br>Selecting a good cipher suite is critical for the</br>application's data security, confidentiality and performance.</br></br>The names should be in OpenSSL string format (not RFC format).</br>All default values and examples provided by EMQX config</br>documentation are all in OpenSSL format.</br></br>NOTE: Certain cipher suites are only compatible with</br>specific TLS <code>versions</code> ('tlsv1.1', 'tlsv1.2' or 'tlsv1.3')</br>incompatible cipher suites will be silently dropped.</br>For instance, if only 'tlsv1.3' is given in the <code>versions</code>,</br>configuring cipher suites for other versions will have no effect.</br></br></br>NOTE: PSK ciphers are suppressed by 'tlsv1.3' version config</br>If PSK cipher suites are intended, 'tlsv1.3' should be disabled from <code>versions</code>.</br>PSK cipher suites: <code>\"RSA-PSK-AES256-GCM-SHA384,RSA-PSK-AES256-CBC-SHA384,</br>RSA-PSK-AES128-GCM-SHA256,RSA-PSK-AES128-CBC-SHA256,</br>RSA-PSK-AES256-CBC-SHA,RSA-PSK-AES128-CBC-SHA,</br>RSA-PSK-DES-CBC3-SHA,RSA-PSK-RC4-SHA\"</code></br>",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "user_lookup_fun": {
            "default": "emqx_tls_psk:lookup",
            "description": "</br>EMQX-internal callback that is used to lookup pre-shared key (PSK) identity.</br>",
            "type": "string"
          },
          "secure_renegotiate": {
            "default": true,
            "description": "</br>SSL parameter renegotiation is a feature that allows a client and a server</br>to renegotiate the parameters of the SSL connection on the fly.</br>RFC 5746 defines a more secure way of doing this. By enabling secure renegotiation,</br>you drop support for the insecure renegotiation, prone to MitM attacks.</br>",
            "type": "boolean"
          },
          "dhfile": {
            "description": "</br>Path to a file containing PEM-encoded Diffie-Hellman parameters</br>to be used by the server if a cipher suite using Diffie-Hellman</br>key exchange is negotiated. If not specified, default parameters</br>are used.</br>NOTE: The <code>dhfile</code> option is not supported by TLS 1.3.</br>",
            "type": "string"
          },
          "fail_if_no_peer_cert": {
            "default": false,
            "description": "</br>Used together with {verify, verify_peer} by an TLS/DTLS server.</br>If set to true, the server fails if the client does not have a</br>certificate to send, that is, sends an empty certificate.</br>If set to false, it fails only if the client sends an invalid</br>certificate (an empty certificate is considered valid).</br>",
            "type": "boolean"
          },
          "honor_cipher_order": {
            "default": true,
            "description": "</br>An important security setting, it forces the cipher to be set based</br> on the server-specified order instead of the client-specified order,</br> hence enforcing the (usually more properly configured) security</br> ordering of the server administrator.</br>",
            "type": "boolean"
          },
          "client_renegotiation": {
            "default": true,
            "description": "</br>In protocols that support client-initiated renegotiation,</br>the cost of resources of such an operation is higher for the server than the client.</br>This can act as a vector for denial of service attacks.</br>The SSL application already takes measures to counter-act such attempts,</br>but client-initiated renegotiation can be strictly disabled by setting this option to false.</br>The default value is true. Note that disabling renegotiation can result in</br>long-lived connections becoming unusable due to limits on</br>the number of messages the underlying cipher suite can encipher.</br>",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "emqx_connector_mqtt.get": {
        "required": [
          "server",
          "name",
          "type"
        ],
        "properties": {
          "num_of_bridges": {
            "description": "The current number of bridges that are using this connector.",
            "type": "integer"
          },
          "type": {
            "description": "The Connector Type.",
            "enum": [
              "mqtt"
            ],
            "type": "string"
          },
          "name": {
            "description": "Connector name, used as a human-readable description of the connector.",
            "type": "string"
          },
          "mode": {
            "default": "cluster_shareload",
            "description": "</br>The mode of the MQTT Bridge.</br></br>- cluster_shareload: create an MQTT connection on each node in the emqx cluster.</br>In 'cluster_shareload' mode, the incoming load from the remote broker is shared by</br>using shared subscription.</br>Note that the 'clientid' is suffixed by the node name, this is to avoid</br>clientid conflicts between different nodes. And we can only use shared subscription</br>topic filters for 'remote_topic' of ingress connections.</br>",
            "enum": [
              "cluster_shareload"
            ],
            "type": "string"
          },
          "server": {
            "description": "The host and port of the remote MQTT broker",
            "example": "127.0.0.1:80",
            "type": "string"
          },
          "reconnect_interval": {
            "default": "15s",
            "description": "Reconnect interval. Delay for the MQTT bridge to retry establishing the connection in case of transportation failure. Time interval is a string that contains a number followed by time unit:</br>- `ms` for milliseconds,</br>- `s` for seconds,</br>- `m` for minutes,</br>- `h` for hours;</br></br>or combination of whereof: `1h5m0s`",
            "type": "string"
          },
          "proto_ver": {
            "default": "v4",
            "description": "The MQTT protocol version",
            "enum": [
              "v3",
              "v4",
              "v5"
            ],
            "type": "string"
          },
          "bridge_mode": {
            "default": false,
            "description": "</br>If enable bridge mode.</br>NOTE: This setting is only for MQTT protocol version older than 5.0, and the remote MQTT</br>broker MUST support this feature.</br>    ",
            "type": "boolean"
          },
          "username": {
            "default": "emqx",
            "description": "The username of the MQTT protocol",
            "type": "string"
          },
          "password": {
            "default": "emqx",
            "description": "The password of the MQTT protocol",
            "type": "string"
          },
          "clean_start": {
            "default": true,
            "description": "The clean-start or the clean-session of the MQTT protocol",
            "type": "boolean"
          },
          "keepalive": {
            "default": "300s",
            "description": "MQTT Keepalive. Time interval is a string that contains a number followed by time unit:</br>- `ms` for milliseconds,</br>- `s` for seconds,</br>- `m` for minutes,</br>- `h` for hours;</br></br>or combination of whereof: `1h5m0s`",
            "type": "string"
          },
          "retry_interval": {
            "default": "15s",
            "description": "Message retry interval. Delay for the MQTT bridge to retry sending the QoS1/QoS2 messages in case of ACK not received. Time interval is a string that contains a number followed by time unit:</br>- `ms` for milliseconds,</br>- `s` for seconds,</br>- `m` for minutes,</br>- `h` for hours;</br></br>or combination of whereof: `1h5m0s`",
            "type": "string"
          },
          "max_inflight": {
            "default": 32,
            "description": "Max inflight (sent, but un-acked) messages of the MQTT protocol",
            "minimum": 0,
            "type": "integer"
          },
          "replayq": {
            "$ref": "#/components/schemas/connector-mqtt.replayq"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/broker.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "broker.listeners": {
        "properties": {
          "tcp": {
            "description": "</br>TCP listeners</br>",
            "properties": {
              "$name": {
                "$ref": "#/components/schemas/broker.mqtt_tcp_listener"
              }
            },
            "type": "object"
          },
          "ssl": {
            "description": "</br>SSL listeners</br>",
            "properties": {
              "$name": {
                "$ref": "#/components/schemas/broker.mqtt_ssl_listener"
              }
            },
            "type": "object"
          },
          "ws": {
            "description": "</br>HTTP websocket listeners</br>",
            "properties": {
              "$name": {
                "$ref": "#/components/schemas/broker.mqtt_ws_listener"
              }
            },
            "type": "object"
          },
          "wss": {
            "description": "</br>HTTPS websocket listeners</br>",
            "properties": {
              "$name": {
                "$ref": "#/components/schemas/broker.mqtt_wss_listener"
              }
            },
            "type": "object"
          },
          "quic": {
            "description": "</br>QUIC listeners</br>",
            "properties": {
              "$name": {
                "$ref": "#/components/schemas/broker.mqtt_quic_listener"
              }
            },
            "type": "object"
          }
        },
        "type": "object"
      },
      "authn-http.post": {
        "required": [
          "url",
          "backend",
          "mechanism",
          "method"
        ],
        "properties": {
          "method": {
            "default": "post",
            "description": "HTTP request method.",
            "enum": [
              "post"
            ],
            "type": "string"
          },
          "headers": {
            "default": {
              "accept": "application/json",
              "cache-control": "no-cache",
              "connection": "keep-alive",
              "content-type": "application/json",
              "keep-alive": "timeout=30, max=1000"
            },
            "description": "List of HTTP Headers.",
            "example": {},
            "type": "object"
          },
          "mechanism": {
            "description": "Authentication mechanism.",
            "enum": [
              "password_based"
            ],
            "type": "string"
          },
          "backend": {
            "description": "Backend type.",
            "enum": [
              "http"
            ],
            "type": "string"
          },
          "url": {
            "description": "URL of the HTTP server.",
            "type": "string"
          },
          "body": {
            "description": "HTTP request body.",
            "example": {},
            "type": "object"
          },
          "request_timeout": {
            "default": "5s",
            "description": "HTTP request timeout.",
            "example": "32s",
            "type": "string"
          },
          "enable": {
            "default": true,
            "description": "Set to <code>true</code> or <code>false</code> to disable this auth provider.",
            "type": "boolean"
          },
          "connect_timeout": {
            "default": "15s",
            "description": "The timeout when connecting to the HTTP server.",
            "example": "32s",
            "type": "string"
          },
          "enable_pipelining": {
            "default": 100,
            "description": "Whether to send HTTP requests continuously, when set to 0, it means that after each HTTP request is sent, you need to wait for the server to return and then continue to send the next request.",
            "minimum": 1,
            "type": "integer"
          },
          "max_retries": {
            "default": 5,
            "description": "Max retry times if error on sending request.",
            "minimum": 0,
            "type": "integer"
          },
          "pool_size": {
            "default": 8,
            "description": "The pool size.",
            "minimum": 1,
            "type": "integer"
          },
          "request": {
            "description": "</br>If the request is provided, the caller can send HTTP requests via</br><code>emqx_resource:query(ResourceId, {send_message, BridgeId, Message})</code></br>",
            "$ref": "#/components/schemas/connector-http.request"
          },
          "retry_interval": {
            "default": "1s",
            "description": "Interval between retries.",
            "example": "12m",
            "type": "string"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/broker.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "emqx_gateway_api_clients.stomp_client": {
        "properties": {
          "node": {
            "description": "Name of the node to which the client is connected",
            "type": "string"
          },
          "clientid": {
            "description": "Client ID",
            "type": "string"
          },
          "username": {
            "description": "Username of client when connecting",
            "type": "string"
          },
          "mountpoint": {
            "description": "Topic mountpoint",
            "type": "string"
          },
          "proto_name": {
            "description": "Client protocol name",
            "type": "string"
          },
          "proto_ver": {
            "description": "Protocol version used by the client",
            "type": "string"
          },
          "ip_address": {
            "description": "Client's IP address",
            "type": "string"
          },
          "port": {
            "description": "Client's port",
            "type": "integer"
          },
          "is_bridge": {
            "description": "Indicates whether the client is connected via bridge",
            "type": "boolean"
          },
          "connected_at": {
            "description": "Client connection time",
            "oneOf": [
              {
                "description": "epoch-millisecond",
                "example": 1640995200000,
                "type": "integer"
              },
              {
                "example": "2022-01-01T00:00:00.000Z",
                "format": "date-time",
                "type": "string"
              }
            ]
          },
          "disconnected_at": {
            "description": "Client offline time, This field is only valid and returned when connected is false",
            "oneOf": [
              {
                "description": "epoch-millisecond",
                "example": 1640995200000,
                "type": "integer"
              },
              {
                "example": "2022-01-01T00:00:00.000Z",
                "format": "date-time",
                "type": "string"
              }
            ]
          },
          "connected": {
            "description": "Whether the client is connected",
            "type": "boolean"
          },
          "keepalive": {
            "description": "Keepalive time, with the unit of second",
            "type": "integer"
          },
          "clean_start": {
            "description": "Indicate whether the client is using a brand new session",
            "type": "boolean"
          },
          "expiry_interval": {
            "description": "Session expiration interval, with the unit of second",
            "type": "integer"
          },
          "created_at": {
            "description": "Session creation time",
            "oneOf": [
              {
                "description": "epoch-millisecond",
                "example": 1640995200000,
                "type": "integer"
              },
              {
                "example": "2022-01-01T00:00:00.000Z",
                "format": "date-time",
                "type": "string"
              }
            ]
          },
          "subscriptions_cnt": {
            "description": "Number of subscriptions established by this client",
            "type": "integer"
          },
          "subscriptions_max": {
            "description": "Maximum number of subscriptions allowed by this client",
            "type": "integer"
          },
          "inflight_cnt": {
            "description": "Current length of inflight",
            "type": "integer"
          },
          "inflight_max": {
            "description": "Maximum length of inflight",
            "type": "integer"
          },
          "mqueue_len": {
            "description": "Current length of message queue",
            "type": "integer"
          },
          "mqueue_max": {
            "description": "Maximum length of message queue",
            "type": "integer"
          },
          "mqueue_dropped": {
            "description": "Number of messages dropped by the message queue due to exceeding the length",
            "type": "integer"
          },
          "awaiting_rel_cnt": {
            "description": "Number of awaiting acknowledge packet",
            "type": "integer"
          },
          "awaiting_rel_max": {
            "description": "Maximum allowed number of awaiting PUBREC packet",
            "type": "integer"
          },
          "recv_oct": {
            "description": "Number of bytes received",
            "type": "integer"
          },
          "recv_cnt": {
            "description": "Number of socket packets received",
            "type": "integer"
          },
          "recv_pkt": {
            "description": "Number of protocol packets received",
            "type": "integer"
          },
          "recv_msg": {
            "description": "Number of message packets received",
            "type": "integer"
          },
          "send_oct": {
            "description": "Number of bytes sent",
            "type": "integer"
          },
          "send_cnt": {
            "description": "Number of socket packets sent",
            "type": "integer"
          },
          "send_pkt": {
            "description": "Number of protocol packets sent",
            "type": "integer"
          },
          "send_msg": {
            "description": "Number of message packets sent",
            "type": "integer"
          },
          "mailbox_len": {
            "description": "Process mailbox size",
            "type": "integer"
          },
          "heap_size": {
            "description": "Process heap size with the unit of byte",
            "type": "integer"
          },
          "reductions": {
            "description": "Erlang reduction",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "emqx_authz_api_mnesia.clientid_response_data": {
        "properties": {
          "data": {
            "items": {
              "$ref": "#/components/schemas/emqx_authz_api_mnesia.rules_for_clientid"
            },
            "type": "array"
          },
          "meta": {
            "$ref": "#/components/schemas/public.meta"
          }
        },
        "type": "object"
      },
      "zone.force_gc": {
        "properties": {
          "enable": {
            "description": "Enable forced garbage collection.",
            "type": "boolean"
          },
          "count": {
            "description": "GC the process after this many received messages.",
            "minimum": 0,
            "type": "integer"
          },
          "bytes": {
            "description": "GC the process after specified number of bytes have passed through.",
            "example": "32MB",
            "type": "string"
          }
        },
        "type": "object"
      },
      "emqx_mgmt_api_nodes.node_info": {
        "properties": {
          "node": {
            "description": "Node name",
            "example": "emqx@127.0.0.1",
            "type": "string"
          },
          "connections": {
            "description": "Number of clients currently connected to this node",
            "example": 0,
            "minimum": 0,
            "type": "integer"
          },
          "load1": {
            "description": "CPU average load in 1 minute",
            "example": "2.66",
            "type": "string"
          },
          "load5": {
            "description": "CPU average load in 5 minute",
            "example": "2.66",
            "type": "string"
          },
          "load15": {
            "description": "CPU average load in 15 minute",
            "example": "2.66",
            "type": "string"
          },
          "max_fds": {
            "description": "File descriptors limit",
            "example": 1024,
            "minimum": 0,
            "type": "integer"
          },
          "memory_total": {
            "description": "Allocated memory",
            "example": "512.00M",
            "type": "string"
          },
          "memory_used": {
            "description": "Used memory",
            "example": "256.00M",
            "type": "string"
          },
          "node_status": {
            "description": "Node status",
            "enum": [
              "Running",
              "Stopped"
            ],
            "example": "Running",
            "type": "string"
          },
          "otp_release": {
            "description": "Erlang/OTP version",
            "example": "24.2/12.2",
            "type": "string"
          },
          "process_available": {
            "description": "Erlang processes limit",
            "example": 2097152,
            "minimum": 0,
            "type": "integer"
          },
          "process_used": {
            "description": "Running Erlang processes",
            "example": 1024,
            "minimum": 0,
            "type": "integer"
          },
          "uptime": {
            "description": "System uptime, milliseconds",
            "example": 5120000,
            "minimum": 0,
            "type": "integer"
          },
          "version": {
            "description": "Release version",
            "example": "5.0.0-beat.3-00000000",
            "type": "string"
          },
          "sys_path": {
            "description": "Path to system files",
            "example": "path/to/emqx",
            "type": "string"
          },
          "log_path": {
            "description": "Path to log files",
            "example": "path/to/log | The log path is not yet set",
            "type": "string"
          },
          "role": {
            "description": "Node role",
            "enum": [
              "core",
              "replicant"
            ],
            "example": "core",
            "type": "string"
          }
        },
        "type": "object"
      },
      "emqx_delayed_api.message_without_payload": {
        "properties": {
          "msgid": {
            "description": "Delayed Message ID",
            "type": "integer"
          },
          "node": {
            "description": "The node where message from",
            "type": "string"
          },
          "publish_at": {
            "description": "Clinet publish message time, in RFC 3339 format",
            "type": "string"
          },
          "delayed_interval": {
            "description": "Delayed interval(second)",
            "minimum": 1,
            "type": "integer"
          },
          "delayed_remaining": {
            "description": "Delayed remaining(second)",
            "minimum": 0,
            "type": "integer"
          },
          "expected_at": {
            "description": "Expect publish time, in RFC 3339 format",
            "type": "string"
          },
          "topic": {
            "description": "Topic",
            "example": "/sys/#",
            "type": "string"
          },
          "qos": {
            "description": "QoS",
            "enum": [
              0,
              1,
              2
            ],
            "type": "string"
          },
          "from_clientid": {
            "description": "From ClientID",
            "type": "string"
          },
          "from_username": {
            "description": "From Username",
            "type": "string"
          }
        },
        "type": "object"
      },
      "emqx_authz_api_mnesia.rules": {
        "properties": {
          "rules": {
            "items": {
              "$ref": "#/components/schemas/emqx_authz_api_mnesia.rule_item"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "emqx_bridge_mqtt_schema.get_ingress": {
        "required": [
          "remote_topic",
          "connector",
          "direction",
          "name",
          "type"
        ],
        "properties": {
          "metrics": {
            "description": "Bridge metrics.",
            "$ref": "#/components/schemas/bridge.metrics"
          },
          "node_metrics": {
            "description": "Node metrics.",
            "items": {
              "$ref": "#/components/schemas/bridge.node_metrics"
            },
            "type": "array"
          },
          "status": {
            "description": "The status of the bridge",
            "enum": [
              "connected",
              "disconnected",
              "connecting"
            ],
            "type": "string"
          },
          "node_status": {
            "description": "Node status.",
            "items": {
              "$ref": "#/components/schemas/bridge.node_status"
            },
            "type": "array"
          },
          "type": {
            "description": "The bridge type.",
            "enum": [
              "mqtt"
            ],
            "type": "string"
          },
          "name": {
            "description": "Bridge name, used as a human-readable description of the bridge.",
            "type": "string"
          },
          "direction": {
            "default": "egress",
            "description": "The direction of the bridge. Can be one of 'ingress' or 'egress'.</br>The ingress config defines how this bridge receive messages from the remote MQTT broker, and then</br>send them to the local broker.</br>Template with variables is allowed in 'local_topic', 'remote_qos', 'qos', 'retain',</br>'payload'.</br>NOTE: if this bridge is used as the input of a rule (emqx rule engine), and also local_topic is</br>configured, then messages got from the remote broker will be sent to both the 'local_topic' and</br>the rule.</br>",
            "enum": [
              "ingress"
            ],
            "type": "string"
          },
          "connector": {
            "description": "</br>The ID or the configs of the connector to be used for this bridge. Connector IDs must be of format:</br><code>{type}:{name}</code>.</br>In config files, you can find the corresponding config entry for a connector by such path:</br>'connectors.{type}.{name}'.</br>",
            "example": "mqtt:my_mqtt_connector",
            "oneOf": [
              {
                "$ref": "#/components/schemas/connector-mqtt.connector"
              },
              {
                "type": "string"
              }
            ]
          },
          "remote_topic": {
            "description": "Receive messages from which topic of the remote broker",
            "type": "string"
          },
          "remote_qos": {
            "default": 1,
            "description": "The QoS level to be used when subscribing to the remote broker",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "enum": [
                  0,
                  1,
                  2
                ],
                "type": "string"
              }
            ]
          },
          "local_topic": {
            "description": "</br>Send messages to which topic of the local broker.</br>Template with variables is allowed.</br>",
            "type": "string"
          },
          "local_qos": {
            "default": "${qos}",
            "description": "</br>The QoS of the MQTT message to be sent.</br>Template with variables is allowed.</br>",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "enum": [
                  0,
                  1,
                  2
                ],
                "type": "string"
              }
            ]
          },
          "retain": {
            "default": "${retain}",
            "description": "</br>The 'retain' flag of the MQTT message to be sent.</br>Template with variables is allowed.</br>",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "boolean"
              }
            ]
          },
          "payload": {
            "default": "${payload}",
            "description": "</br>The payload of the MQTT message to be sent.</br>Template with variables is allowed.</br>",
            "type": "string"
          }
        },
        "type": "object"
      },
      "slow_subscribers_statistics.record": {
        "properties": {
          "clientid": {
            "description": "Message clientid",
            "type": "string"
          },
          "node": {
            "description": "Message node name",
            "type": "string"
          },
          "topic": {
            "description": "Message topic",
            "type": "string"
          },
          "timespan": {
            "description": "Timespan for message transmission",
            "type": "integer"
          },
          "last_update_time": {
            "description": "The timestamp of last update",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "emqx_gateway_api_clients.mqttsn_client": {
        "properties": {
          "node": {
            "description": "Name of the node to which the client is connected",
            "type": "string"
          },
          "clientid": {
            "description": "Client ID",
            "type": "string"
          },
          "username": {
            "description": "Username of client when connecting",
            "type": "string"
          },
          "mountpoint": {
            "description": "Topic mountpoint",
            "type": "string"
          },
          "proto_name": {
            "description": "Client protocol name",
            "type": "string"
          },
          "proto_ver": {
            "description": "Protocol version used by the client",
            "type": "string"
          },
          "ip_address": {
            "description": "Client's IP address",
            "type": "string"
          },
          "port": {
            "description": "Client's port",
            "type": "integer"
          },
          "is_bridge": {
            "description": "Indicates whether the client is connected via bridge",
            "type": "boolean"
          },
          "connected_at": {
            "description": "Client connection time",
            "oneOf": [
              {
                "description": "epoch-millisecond",
                "example": 1640995200000,
                "type": "integer"
              },
              {
                "example": "2022-01-01T00:00:00.000Z",
                "format": "date-time",
                "type": "string"
              }
            ]
          },
          "disconnected_at": {
            "description": "Client offline time, This field is only valid and returned when connected is false",
            "oneOf": [
              {
                "description": "epoch-millisecond",
                "example": 1640995200000,
                "type": "integer"
              },
              {
                "example": "2022-01-01T00:00:00.000Z",
                "format": "date-time",
                "type": "string"
              }
            ]
          },
          "connected": {
            "description": "Whether the client is connected",
            "type": "boolean"
          },
          "keepalive": {
            "description": "Keepalive time, with the unit of second",
            "type": "integer"
          },
          "clean_start": {
            "description": "Indicate whether the client is using a brand new session",
            "type": "boolean"
          },
          "expiry_interval": {
            "description": "Session expiration interval, with the unit of second",
            "type": "integer"
          },
          "created_at": {
            "description": "Session creation time",
            "oneOf": [
              {
                "description": "epoch-millisecond",
                "example": 1640995200000,
                "type": "integer"
              },
              {
                "example": "2022-01-01T00:00:00.000Z",
                "format": "date-time",
                "type": "string"
              }
            ]
          },
          "subscriptions_cnt": {
            "description": "Number of subscriptions established by this client",
            "type": "integer"
          },
          "subscriptions_max": {
            "description": "Maximum number of subscriptions allowed by this client",
            "type": "integer"
          },
          "inflight_cnt": {
            "description": "Current length of inflight",
            "type": "integer"
          },
          "inflight_max": {
            "description": "Maximum length of inflight",
            "type": "integer"
          },
          "mqueue_len": {
            "description": "Current length of message queue",
            "type": "integer"
          },
          "mqueue_max": {
            "description": "Maximum length of message queue",
            "type": "integer"
          },
          "mqueue_dropped": {
            "description": "Number of messages dropped by the message queue due to exceeding the length",
            "type": "integer"
          },
          "awaiting_rel_cnt": {
            "description": "Number of awaiting acknowledge packet",
            "type": "integer"
          },
          "awaiting_rel_max": {
            "description": "Maximum allowed number of awaiting PUBREC packet",
            "type": "integer"
          },
          "recv_oct": {
            "description": "Number of bytes received",
            "type": "integer"
          },
          "recv_cnt": {
            "description": "Number of socket packets received",
            "type": "integer"
          },
          "recv_pkt": {
            "description": "Number of protocol packets received",
            "type": "integer"
          },
          "recv_msg": {
            "description": "Number of message packets received",
            "type": "integer"
          },
          "send_oct": {
            "description": "Number of bytes sent",
            "type": "integer"
          },
          "send_cnt": {
            "description": "Number of socket packets sent",
            "type": "integer"
          },
          "send_pkt": {
            "description": "Number of protocol packets sent",
            "type": "integer"
          },
          "send_msg": {
            "description": "Number of message packets sent",
            "type": "integer"
          },
          "mailbox_len": {
            "description": "Process mailbox size",
            "type": "integer"
          },
          "heap_size": {
            "description": "Process heap size with the unit of byte",
            "type": "integer"
          },
          "reductions": {
            "description": "Erlang reduction",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "emqx_topic_metrics_api.metrics": {
        "properties": {
          "message.dropped.count": {
            "description": "Dropped messages count",
            "example": 0,
            "type": "integer"
          },
          "message.in.count": {
            "description": "In messages count",
            "example": 0,
            "type": "integer"
          },
          "message.out.count": {
            "description": "Out messages count",
            "example": 0,
            "type": "integer"
          },
          "message.qos0.in.count": {
            "description": "QoS0 in messages count",
            "example": 0,
            "type": "integer"
          },
          "message.qos0.out.count": {
            "description": "QoS0 out messages count",
            "example": 0,
            "type": "integer"
          },
          "message.qos1.in.count": {
            "description": "QoS1 in messages count",
            "example": 0,
            "type": "integer"
          },
          "message.qos1.out.count": {
            "description": "QoS1 out messages count",
            "example": 0,
            "type": "integer"
          },
          "message.qos2.in.count": {
            "description": "QoS2 in messages count",
            "example": 0,
            "type": "integer"
          },
          "message.qos2.out.count": {
            "description": "QoS2 out messages count",
            "example": 0,
            "type": "integer"
          },
          "message.dropped.rate": {
            "description": "Dropped messages rate",
            "example": 0,
            "type": "number"
          },
          "message.in.rate": {
            "description": "In messages rate",
            "example": 0,
            "type": "number"
          },
          "message.out.rate": {
            "description": "Out messages rate",
            "example": 0,
            "type": "number"
          },
          "message.qos0.in.rate": {
            "description": "QoS0 in messages rate",
            "example": 0,
            "type": "number"
          },
          "message.qos0.out.rate": {
            "description": "QoS0 out messages rate",
            "example": 0,
            "type": "number"
          },
          "message.qos1.in.rate": {
            "description": "QoS1 in messages rate",
            "example": 0,
            "type": "number"
          },
          "message.qos1.out.rate": {
            "description": "QoS1 out messages rate",
            "example": 0,
            "type": "number"
          },
          "message.qos2.in.rate": {
            "description": "QoS2 in messages rate",
            "example": 0,
            "type": "number"
          },
          "message.qos2.out.rate": {
            "description": "QoS2 out messages rate",
            "example": 0,
            "type": "number"
          }
        },
        "type": "object"
      },
      "listeners.ssl_not_required_bind": {
        "required": [
          "id",
          "type"
        ],
        "properties": {
          "type": {
            "description": "Listener type",
            "enum": [
              "ssl"
            ],
            "type": "string"
          },
          "running": {
            "description": "Listener status",
            "type": "boolean"
          },
          "id": {
            "description": "Listener id",
            "type": "string"
          },
          "current_connections": {
            "description": "Current connections",
            "minimum": 0,
            "type": "integer"
          },
          "bind": {
            "default": 8883,
            "description": "</br>IP address and port for the listening socket.</br>",
            "oneOf": [
              {
                "type": "integer"
              },
              {
                "example": "127.0.0.1:80",
                "type": "string"
              }
            ]
          },
          "enabled": {
            "default": true,
            "description": "</br>Enable listener.</br>",
            "type": "boolean"
          },
          "acceptors": {
            "default": 16,
            "description": "</br>The size of the listener's receiving pool.</br>",
            "minimum": 1,
            "type": "integer"
          },
          "max_connections": {
            "default": "infinity",
            "description": "</br>The maximum number of concurrent connections allowed by the listener.</br>",
            "oneOf": [
              {
                "minimum": 1,
                "type": "integer"
              },
              {
                "enum": [
                  "infinity"
                ],
                "type": "string"
              }
            ]
          },
          "mountpoint": {
            "default": "",
            "description": "</br>When publishing or subscribing, prefix all topics with a mountpoint string.</br>The prefixed string will be removed from the topic name when the message</br>is delivered to the subscriber. The mountpoint is a way that users can use</br>to implement isolation of message routing between different listeners.</br>For example if a client A subscribes to `t` with `listeners.tcp.\\<name>.mountpoint`</br>set to `some_tenant`, then the client actually subscribes to the topic</br>`some_tenant/t`. Similarly, if another client B (connected to the same listener</br>as the client A) sends a message to topic `t`, the message is routed</br>to all the clients subscribed `some_tenant/t`, so client A will receive the</br>message, with topic name `t`.</br>Set to `\"\"` to disable the feature.</br></br>Variables in mountpoint string:</br>  - <code>${clientid}</code>: clientid</br>  - <code>${username}</code>: username</br>",
            "type": "string"
          },
          "zone": {
            "default": "default",
            "description": "</br>The configuration zone to which the listener belongs.</br>",
            "type": "string"
          },
          "limiter": {
            "default": {
              "connection": "default"
            },
            "description": "</br>Type of the rate limit.</br>",
            "properties": {
              "$ratelimit_name": {
                "example": "retainer",
                "type": "string"
              }
            },
            "type": "object"
          },
          "enable_authn": {
            "default": true,
            "description": "</br>Set <code>true</code> (default) to enable client authentication on this listener.</br>When set to <code>false</code> clients will be allowed to connect without authentication.</br>",
            "type": "boolean"
          },
          "access_rules": {
            "default": [
              "allow all"
            ],
            "description": "</br>The access control rules for this listener.</br>See: https://github.com/emqtt/esockd#allowdeny</br>",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "proxy_protocol": {
            "default": false,
            "description": "</br>Enable the Proxy Protocol V1/2 if the EMQX cluster is deployed behind HAProxy or Nginx.</br>See: https://www.haproxy.com/blog/haproxy/proxy-protocol/</br>",
            "type": "boolean"
          },
          "proxy_protocol_timeout": {
            "default": "3s",
            "description": "</br>Timeout for proxy protocol. EMQX will close the TCP connection if proxy protocol packet is not received within the timeout.</br>",
            "example": "12m",
            "type": "string"
          },
          "tcp_options": {
            "$ref": "#/components/schemas/broker.tcp_opts"
          },
          "ssl_options": {
            "$ref": "#/components/schemas/broker.listener_ssl_opts"
          }
        },
        "type": "object"
      },
      "emqx_gateway_api.update_lwm2m": {
        "required": [
          "translators",
          "xml_dir"
        ],
        "properties": {
          "xml_dir": {
            "default": "/mnt/code/src/emqx/0/_build/emqx/rel/emqx/etc/lwm2m_xml",
            "description": "The Directory for LwM2M Resource definition",
            "type": "string"
          },
          "lifetime_min": {
            "default": "15s",
            "description": "Minimum value of lifetime allowed to be set by the LwM2M client",
            "example": "12m",
            "type": "string"
          },
          "lifetime_max": {
            "default": "86400s",
            "description": "Maximum value of lifetime allowed to be set by the LwM2M client",
            "example": "12m",
            "type": "string"
          },
          "qmode_time_window": {
            "default": "22s",
            "description": "The value of the time window during which the network link is considered valid by the LwM2M Gateway in QMode mode.</br>For example, after receiving an update message from a client, any messages within this time window are sent directly to the LwM2M client, and all messages beyond this time window are temporarily stored in memory.",
            "example": "1h",
            "type": "string"
          },
          "auto_observe": {
            "default": false,
            "description": "Automatically observe the object list of REGISTER packet",
            "type": "boolean"
          },
          "update_msg_publish_condition": {
            "default": "contains_object_list",
            "description": "Policy for publishing UPDATE event message.</br>  - always: send update events as long as the UPDATE request is received.</br>  - contains_object_list: send update events only if the UPDATE request carries any Object List</br>",
            "enum": [
              "always",
              "contains_object_list"
            ],
            "type": "string"
          },
          "translators": {
            "description": "Topic configuration for LwM2M's gateway publishing and subscription",
            "$ref": "#/components/schemas/gateway.lwm2m_translators"
          },
          "mountpoint": {
            "default": "lwm2m/${endpoint_name}/",
            "description": " ",
            "type": "string"
          },
          "enable": {
            "default": true,
            "description": "Whether to enable this gateway",
            "type": "boolean"
          },
          "enable_stats": {
            "default": true,
            "description": "Whether to enable client process statistic",
            "type": "boolean"
          },
          "idle_timeout": {
            "default": "30s",
            "description": "The idle time of the client connection process. It has two purposes:</br>  1. A newly created client process that does not receive any client requests after that time will be closed directly.</br>  2. A running client process that does not receive any client requests after this time will go into hibernation to save resources.",
            "example": "12m",
            "type": "string"
          },
          "clientinfo_override": {
            "description": "ClientInfo override.",
            "$ref": "#/components/schemas/gateway.clientinfo_override"
          }
        },
        "type": "object"
      },
      "emqx_rule_api_schema.ctx_bridge_mqtt": {
        "required": [
          "event_type"
        ],
        "properties": {
          "event_type": {
            "description": "Event Type",
            "enum": [
              "$bridges/mqtt:*"
            ],
            "type": "string"
          },
          "id": {
            "description": "Message ID",
            "type": "string"
          },
          "payload": {
            "description": "The Message Payload",
            "type": "string"
          },
          "topic": {
            "description": "Message Topic",
            "type": "string"
          },
          "server": {
            "description": "The IP address (or hostname) and port of the MQTT broker, in IP:Port format",
            "type": "string"
          },
          "dup": {
            "description": "The DUP flag of the MQTT message",
            "type": "string"
          },
          "retain": {
            "description": "If is a retain message",
            "type": "string"
          },
          "message_received_at": {
            "description": "The Time that this Message is Received",
            "type": "integer"
          },
          "qos": {
            "description": "The Message QoS",
            "enum": [
              0,
              1,
              2
            ],
            "type": "string"
          }
        },
        "type": "object"
      },
      "emqx_rule_api_schema.ctx_delivered": {
        "required": [
          "event_type"
        ],
        "properties": {
          "event_type": {
            "description": "Event Type",
            "enum": [
              "message_delivered"
            ],
            "type": "string"
          },
          "id": {
            "description": "Message ID",
            "type": "string"
          },
          "from_clientid": {
            "description": "The Client ID",
            "type": "string"
          },
          "from_username": {
            "description": "The User Name",
            "type": "string"
          },
          "clientid": {
            "description": "The Client ID",
            "type": "string"
          },
          "username": {
            "description": "The User Name",
            "type": "string"
          },
          "payload": {
            "description": "The Message Payload",
            "type": "string"
          },
          "peerhost": {
            "description": "The IP Address of the Peer Client",
            "type": "string"
          },
          "topic": {
            "description": "Message Topic",
            "type": "string"
          },
          "publish_received_at": {
            "description": "The Time that this Message is Received",
            "type": "integer"
          },
          "qos": {
            "description": "The Message QoS",
            "enum": [
              0,
              1,
              2
            ],
            "type": "string"
          }
        },
        "type": "object"
      },
      "emqx_bridge_mqtt_schema.put_egress": {
        "required": [
          "payload",
          "retain",
          "remote_qos",
          "remote_topic",
          "connector",
          "direction"
        ],
        "properties": {
          "direction": {
            "default": "egress",
            "description": "The direction of the bridge. Can be one of 'ingress' or 'egress'.</br>The egress config defines how this bridge forwards messages from the local broker to the remote</br>broker.</br>Template with variables is allowed in 'remote_topic', 'qos', 'retain', 'payload'.</br>NOTE: if this bridge is used as the action of a rule (emqx rule engine), and also local_topic</br>is configured, then both the data got from the rule and the MQTT messages that matches</br>local_topic will be forwarded.</br>",
            "enum": [
              "egress"
            ],
            "type": "string"
          },
          "connector": {
            "description": "</br>The ID or the configs of the connector to be used for this bridge. Connector IDs must be of format:</br><code>{type}:{name}</code>.</br>In config files, you can find the corresponding config entry for a connector by such path:</br>'connectors.{type}.{name}'.</br>",
            "example": "mqtt:my_mqtt_connector",
            "oneOf": [
              {
                "$ref": "#/components/schemas/connector-mqtt.connector"
              },
              {
                "type": "string"
              }
            ]
          },
          "local_topic": {
            "description": "The local topic to be forwarded to the remote broker",
            "type": "string"
          },
          "remote_topic": {
            "description": "</br>Forward to which topic of the remote broker.</br>Template with variables is allowed.</br>",
            "type": "string"
          },
          "remote_qos": {
            "description": "</br>The QoS of the MQTT message to be sent.</br>Template with variables is allowed.</br>",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "enum": [
                  0,
                  1,
                  2
                ],
                "type": "string"
              }
            ]
          },
          "retain": {
            "description": "</br>The 'retain' flag of the MQTT message to be sent.</br>Template with variables is allowed.</br>",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "boolean"
              }
            ]
          },
          "payload": {
            "description": "</br>The payload of the MQTT message to be sent.</br>Template with variables is allowed.</br>",
            "type": "string"
          }
        },
        "type": "object"
      },
      "emqx_conf_schema.cluster_dns": {
        "properties": {
          "name": {
            "default": "localhost",
            "description": "The domain name from which to discover peer EMQX nodes' IP addresses.</br>Applicable when <code>cluster.discovery_strategy = dns</code></br>",
            "readOnly": true,
            "type": "string"
          },
          "record_type": {
            "default": "a",
            "description": "DNS record type. ",
            "enum": [
              "a",
              "srv"
            ],
            "readOnly": true,
            "type": "string"
          }
        },
        "type": "object"
      },
      "modules.delayed": {
        "properties": {
          "enable": {
            "default": true,
            "description": "Enable this feature",
            "type": "boolean"
          },
          "max_delayed_messages": {
            "default": 0,
            "description": "Maximum number of delayed messages (0 is no limit).",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "emqx_connector_mongo.topology": {
        "properties": {
          "pool_size": {
            "default": 8,
            "description": "Size of the connection pool.",
            "minimum": 1,
            "type": "integer"
          },
          "max_overflow": {
            "default": 0,
            "description": "Max Overflow.",
            "minimum": 0,
            "type": "integer"
          },
          "overflow_ttl": {
            "description": "Time interval, such as timeout or TTL.",
            "example": "32s",
            "type": "string"
          },
          "overflow_check_period": {
            "description": "Time interval, such as timeout or TTL.",
            "example": "32s",
            "type": "string"
          },
          "local_threshold_ms": {
            "description": "Time interval, such as timeout or TTL.",
            "example": "32s",
            "type": "string"
          },
          "connect_timeout_ms": {
            "description": "Time interval, such as timeout or TTL.",
            "example": "32s",
            "type": "string"
          },
          "socket_timeout_ms": {
            "description": "Time interval, such as timeout or TTL.",
            "example": "32s",
            "type": "string"
          },
          "server_selection_timeout_ms": {
            "description": "Time interval, such as timeout or TTL.",
            "example": "32s",
            "type": "string"
          },
          "wait_queue_timeout_ms": {
            "description": "Time interval, such as timeout or TTL.",
            "example": "32s",
            "type": "string"
          },
          "heartbeat_frequency_ms": {
            "description": "Time interval, such as timeout or TTL.",
            "example": "32s",
            "type": "string"
          },
          "min_heartbeat_frequency_ms": {
            "description": "Time interval, such as timeout or TTL.",
            "example": "32s",
            "type": "string"
          }
        },
        "type": "object"
      },
      "plugins.builder": {
        "properties": {
          "contact": {
            "example": "emqx-support@emqx.io",
            "type": "string"
          },
          "name": {
            "example": "EMQX Team",
            "type": "string"
          },
          "website": {
            "example": "www.emqx.com",
            "type": "string"
          }
        },
        "type": "object"
      },
      "retainer.flow_control": {
        "properties": {
          "batch_read_number": {
            "default": 0,
            "description": "Size of the batch when reading messages from storage. 0 means no limit.",
            "minimum": 0,
            "type": "integer"
          },
          "batch_deliver_number": {
            "default": 0,
            "description": "The number of retained messages can be delivered per batch.",
            "maximum": 1000,
            "minimum": 0,
            "type": "integer"
          },
          "batch_deliver_limiter": {
            "description": "The rate limiter name for retained messages' delivery.</br>Limiter helps to avoid delivering too many messages to the client at once, which may cause the client to block or crash, or drop messages due to exceeding the size of the message queue.</br>The names of the available rate limiters are taken from the existing rate limiters under `limiter.batch`.</br>If this field is empty, limiter is not used.",
            "example": "retainer",
            "type": "string"
          }
        },
        "type": "object"
      },
      "exhook.hook_info": {
        "properties": {
          "name": {
            "description": "The hook's name",
            "type": "string"
          },
          "params": {
            "description": "The parameters used when the hook is registered",
            "properties": {
              "$name": {
                "type": "string"
              }
            },
            "type": "object"
          }
        },
        "type": "object"
      },
      "authn-redis.cluster": {
        "required": [
          "database",
          "redis_type",
          "servers",
          "cmd",
          "backend",
          "mechanism"
        ],
        "properties": {
          "mechanism": {
            "description": "Authentication mechanism.",
            "enum": [
              "password_based"
            ],
            "type": "string"
          },
          "backend": {
            "description": "Backend type.",
            "enum": [
              "redis"
            ],
            "type": "string"
          },
          "cmd": {
            "description": "The Redis Command used to query data for authentication such as password hash, currently only supports <code>HGET</code> and <code>HMGET</code>.",
            "type": "string"
          },
          "password_hash_algorithm": {
            "default": {
              "name": "sha256",
              "salt_position": "prefix"
            },
            "description": "Options for password hash verification.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/authn-hash.other_algorithms"
              },
              {
                "$ref": "#/components/schemas/authn-hash.pbkdf2"
              },
              {
                "$ref": "#/components/schemas/authn-hash.bcrypt"
              }
            ]
          },
          "enable": {
            "default": true,
            "description": "Set to <code>true</code> or <code>false</code> to disable this auth provider.",
            "type": "boolean"
          },
          "servers": {
            "description": "</br>A Node list for Cluster to connect to. The nodes should be separated with commas, such as: `Node[,Node].`</br>For each Node should be: The IPv4 or IPv6 address or the hostname to connect to.</br>A host entry has the following form: `Host[:Port]`.</br>The MongoDB default port 27017 is used if `[:Port]` is not specified.</br>",
            "items": {
              "example": "any",
              "type": "string"
            },
            "type": "array"
          },
          "redis_type": {
            "description": "Cluster mode",
            "enum": [
              "cluster"
            ],
            "type": "string"
          },
          "pool_size": {
            "default": 8,
            "description": "Size of the connection pool.",
            "minimum": 1,
            "type": "integer"
          },
          "password": {
            "description": "EMQX's password in the external database.",
            "type": "string"
          },
          "database": {
            "default": 0,
            "description": "Redis database ID.",
            "type": "integer"
          },
          "auto_reconnect": {
            "default": true,
            "description": "Enable automatic reconnect to the database.",
            "type": "boolean"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/broker.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "emqx_conf_schema.log_file_handler": {
        "properties": {
          "file": {
            "description": "Name the log file.",
            "example": "/path/to/file",
            "type": "string"
          },
          "rotation": {
            "$ref": "#/components/schemas/emqx_conf_schema.log_rotation"
          },
          "max_size": {
            "default": "50MB",
            "description": "This parameter controls log file rotation. The value `infinity` means the log file will grow indefinitely, otherwise the log file will be rotated once it reaches `max_size` in bytes.",
            "oneOf": [
              {
                "example": "32MB",
                "type": "string"
              },
              {
                "enum": [
                  "infinity"
                ],
                "type": "string"
              }
            ]
          },
          "enable": {
            "default": true,
            "description": "Enable this log handler.",
            "type": "boolean"
          },
          "level": {
            "default": "warning",
            "description": "</br>The log level for the current log handler.</br>Defaults to warning.</br>",
            "enum": [
              "debug",
              "info",
              "notice",
              "warning",
              "error",
              "critical",
              "alert",
              "emergency",
              "all"
            ],
            "type": "string"
          },
          "time_offset": {
            "default": "system",
            "description": "</br>The time offset to be used when formatting the timestamp.</br>Can be one of:</br>  - <code>system</code>: the time offset used by the local system</br>  - <code>utc</code>: the UTC time offset</br>  - <code>+-[hh]:[mm]</code>: user specified time offset, such as \"-02:00\" or \"+00:00\"</br>Defaults to: <code>system</code>.</br>",
            "type": "string"
          },
          "chars_limit": {
            "default": "unlimited",
            "description": "Set the maximum length of a single log message. If this length is exceeded, the log message will be truncated.",
            "oneOf": [
              {
                "minimum": 100,
                "type": "integer"
              },
              {
                "enum": [
                  "unlimited"
                ],
                "type": "string"
              }
            ]
          },
          "formatter": {
            "default": "text",
            "description": "Choose log formatter. <code>text</code> for free text, and <code>json</code> for structured logging.",
            "enum": [
              "text",
              "json"
            ],
            "type": "string"
          },
          "single_line": {
            "default": true,
            "description": "Print logs in a single line if set to true. Otherwise, log messages may span multiple lines.",
            "type": "boolean"
          },
          "sync_mode_qlen": {
            "default": 100,
            "description": "As long as the number of buffered log events is lower than this value,</br>all log events are handled asynchronously. This means that the client process sending the log event,</br>by calling a log function in the Logger API, does not wait for a response from the handler</br>but continues executing immediately after the event is sent.</br>It is not affected by the time it takes the handler to print the event to the log device.</br>If the message queue grows larger than this value,</br>the handler starts handling log events synchronously instead,</br>meaning that the client process sending the event must wait for a response.</br>When the handler reduces the message queue to a level below the sync_mode_qlen threshold,</br>asynchronous operation is resumed.</br>",
            "minimum": 0,
            "type": "integer"
          },
          "drop_mode_qlen": {
            "default": 3000,
            "description": "When the number of buffered log events is larger than this value, the new log events are dropped.</br>When drop mode is activated or deactivated, a message is printed in the logs.",
            "minimum": 1,
            "type": "integer"
          },
          "flush_qlen": {
            "default": 8000,
            "description": "If the number of buffered log events grows larger than this threshold, a flush (delete) operation takes place.</br>To flush events, the handler discards the buffered log messages without logging.",
            "minimum": 1,
            "type": "integer"
          },
          "overload_kill": {
            "$ref": "#/components/schemas/emqx_conf_schema.log_overload_kill"
          },
          "burst_limit": {
            "$ref": "#/components/schemas/emqx_conf_schema.log_burst_limit"
          },
          "supervisor_reports": {
            "default": "error",
            "description": "</br>Type of supervisor reports that are logged. Defaults to <code>error</code></br>  - <code>error</code>: only log errors in the Erlang processes.</br>  - <code>progress</code>: log process startup.</br>",
            "enum": [
              "error",
              "progress"
            ],
            "type": "string"
          },
          "max_depth": {
            "default": 100,
            "description": "Maximum depth for Erlang term log formatting and Erlang process message queue inspection.",
            "oneOf": [
              {
                "minimum": 0,
                "type": "integer"
              },
              {
                "enum": [
                  "unlimited"
                ],
                "type": "string"
              }
            ]
          }
        },
        "type": "object"
      },
      "retainer.retainer": {
        "properties": {
          "enable": {
            "default": true,
            "description": "Enable retainer feature",
            "type": "boolean"
          },
          "msg_expiry_interval": {
            "default": "0s",
            "description": "Message retention time. 0 means message will never be expired.",
            "example": "32s",
            "type": "string"
          },
          "msg_clear_interval": {
            "default": "0s",
            "description": "Periodic interval for cleaning up expired messages.</br>Never clear if the value is 0.</br>      ",
            "example": "32s",
            "type": "string"
          },
          "flow_control": {
            "description": "Flow control.",
            "$ref": "#/components/schemas/retainer.flow_control"
          },
          "max_payload_size": {
            "default": "1MB",
            "description": "Maximum retained message size.",
            "example": "32MB",
            "type": "string"
          },
          "stop_publish_clear_msg": {
            "default": false,
            "description": "When the retained flag of the `PUBLISH` message is set and Payload is empty,</br>whether to continue to publish the message.</br>See:</br>http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718038",
            "type": "boolean"
          },
          "backend": {
            "description": "Settings for the database storing the retained messages.",
            "$ref": "#/components/schemas/retainer.mnesia_config"
          }
        },
        "type": "object"
      },
      "emqx_authz_api_schema.position": {
        "required": [
          "position"
        ],
        "properties": {
          "position": {
            "description": "Where to place the source",
            "type": "string"
          }
        },
        "type": "object"
      },
      "authn-jwt.hmac-based": {
        "required": [
          "mechanism",
          "secret",
          "algorithm",
          "use_jwks"
        ],
        "properties": {
          "use_jwks": {
            "description": "Whether to use JWKS.",
            "enum": [
              false
            ],
            "type": "string"
          },
          "algorithm": {
            "description": "JWT signing algorithm, Supports HMAC (configured as <code>hmac-based</code>) and RSA, ECDSA (configured as <code>public-key</code>).",
            "enum": [
              "hmac-based"
            ],
            "type": "string"
          },
          "secret": {
            "description": "The key to verify the JWT using HMAC algorithm.",
            "type": "string"
          },
          "secret_base64_encoded": {
            "default": false,
            "description": "Whether secret is base64 encoded.",
            "type": "boolean"
          },
          "mechanism": {
            "description": "Authentication mechanism.",
            "enum": [
              "jwt"
            ],
            "type": "string"
          },
          "acl_claim_name": {
            "default": "acl",
            "description": "JWT claim name to use for getting ACL rules.",
            "type": "string"
          },
          "verify_claims": {
            "default": {},
            "description": "</br>A list of custom claims to validate, which is a list of name/value pairs.</br>Values can use the following placeholders:</br>- <code>${username}</code>: Will be replaced at runtime with <code>Username</code> used by the client when connecting</br>- <code>${clientid}</code>: Will be replaced at runtime with <code>Client ID</code> used by the client when connecting</br>Authentication will verify that the value of claims in the JWT (taken from the Password field) matches what is required in <code>verify_claims</code>.</br>",
            "items": {
              "example": "any",
              "type": "string"
            },
            "type": "array"
          },
          "from": {
            "default": "password",
            "description": "Field to take JWT from.",
            "enum": [
              "username",
              "password"
            ],
            "type": "string"
          },
          "enable": {
            "default": true,
            "description": "Set to <code>true</code> or <code>false</code> to disable this auth provider.",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "zone.flapping_detect": {
        "properties": {
          "enable": {
            "description": "Enable flapping connection detection feature.",
            "type": "boolean"
          },
          "max_count": {
            "description": "The maximum number of disconnects allowed for a MQTT Client in `window_time`",
            "type": "integer"
          },
          "window_time": {
            "description": "The time window for flapping detection.",
            "example": "12m",
            "type": "string"
          },
          "ban_time": {
            "description": "How long the flapping clientid will be banned.",
            "example": "12m",
            "type": "string"
          }
        },
        "type": "object"
      },
      "emqx_rule_api_schema.node_metrics": {
        "properties": {
          "node": {
            "description": "The node name",
            "example": "emqx@127.0.0.1",
            "type": "string"
          },
          "matched": {
            "description": "How much times the FROM clause of the SQL is matched.",
            "minimum": 0,
            "type": "integer"
          },
          "matched.rate": {
            "description": "The rate of matched, times/second",
            "type": "number"
          },
          "matched.rate.max": {
            "description": "The max rate of matched, times/second",
            "type": "number"
          },
          "matched.rate.last5m": {
            "description": "The average rate of matched in last 5 minutes, times/second",
            "type": "number"
          },
          "passed": {
            "description": "How much times the SQL is passed",
            "minimum": 0,
            "type": "integer"
          },
          "failed": {
            "description": "How much times the SQL is failed",
            "minimum": 0,
            "type": "integer"
          },
          "failed.exception": {
            "description": "How much times the SQL is failed due to exceptions. This may because of a crash when calling a SQL function, or trying to do arithmetic operation on undefined variables",
            "minimum": 0,
            "type": "integer"
          },
          "failed.unknown": {
            "description": "How much times the SQL is failed due to an unknown error.",
            "minimum": 0,
            "type": "integer"
          },
          "actions.total": {
            "description": "How much times the actions are called by the rule. This value may several times of 'matched', depending on the number of the actions of the rule.",
            "minimum": 0,
            "type": "integer"
          },
          "actions.success": {
            "description": "How much times the rule success to call the actions.",
            "minimum": 0,
            "type": "integer"
          },
          "actions.failed": {
            "description": "How much times the rule failed to call the actions.",
            "minimum": 0,
            "type": "integer"
          },
          "actions.failed.out_of_service": {
            "description": "How much times the rule failed to call actions due to the action is out of service. For example, a bridge is disabled or stopped.",
            "minimum": 0,
            "type": "integer"
          },
          "actions.failed.unknown": {
            "description": "How much times the rule failed to call actions due to to an unknown error.",
            "minimum": 0,
            "type": "integer"
          }
        },
        "type": "object"
      },
      "zone.stats": {
        "properties": {
          "enable": {
            "description": "Enable/disable statistic data collection.",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "authn-mongodb.replica-set": {
        "required": [
          "database",
          "replica_set_name",
          "servers",
          "mongo_type",
          "collection",
          "backend",
          "mechanism"
        ],
        "properties": {
          "mechanism": {
            "description": "Authentication mechanism.",
            "enum": [
              "password_based"
            ],
            "type": "string"
          },
          "backend": {
            "description": "Backend type.",
            "enum": [
              "mongodb"
            ],
            "type": "string"
          },
          "collection": {
            "description": "Collection used to store authentication data.",
            "type": "string"
          },
          "filter": {
            "default": {},
            "description": "</br>Conditional expression that defines the filter condition in the query.</br>Filter supports the following placeholders:</br>- <code>${username}</code>: Will be replaced at runtime with <code>Username</code> used by the client when connecting</br>- <code>${clientid}</code>: Will be replaced at runtime with <code>Client ID</code> used by the client when connecting</br>",
            "example": {},
            "type": "object"
          },
          "password_hash_field": {
            "default": "password_hash",
            "description": "Document field that contains password hash.",
            "type": "string"
          },
          "salt_field": {
            "default": "salt",
            "description": "Document field that contains the password salt.",
            "type": "string"
          },
          "is_superuser_field": {
            "default": "is_superuser",
            "description": "Document field that defines if the user has superuser privileges.",
            "type": "string"
          },
          "password_hash_algorithm": {
            "default": {
              "name": "sha256",
              "salt_position": "prefix"
            },
            "description": "Options for password hash verification.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/authn-hash.other_algorithms"
              },
              {
                "$ref": "#/components/schemas/authn-hash.pbkdf2"
              },
              {
                "$ref": "#/components/schemas/authn-hash.bcrypt"
              }
            ]
          },
          "enable": {
            "default": true,
            "description": "Set to <code>true</code> or <code>false</code> to disable this auth provider.",
            "type": "boolean"
          },
          "mongo_type": {
            "default": "rs",
            "description": "Replica set.",
            "enum": [
              "rs"
            ],
            "type": "string"
          },
          "servers": {
            "description": "</br>A Node list for Cluster to connect to. The nodes should be separated with commas, such as: `Node[,Node].`</br>For each Node should be: The IPv4 or IPv6 address or the hostname to connect to.</br>A host entry has the following form: `Host[:Port]`.</br>The MongoDB default port 27017 is used if `[:Port]` is not specified.</br>",
            "items": {
              "example": "any",
              "type": "string"
            },
            "type": "array"
          },
          "w_mode": {
            "default": "unsafe",
            "description": "Write mode.",
            "enum": [
              "unsafe",
              "safe"
            ],
            "type": "string"
          },
          "r_mode": {
            "default": "master",
            "description": "Read mode.",
            "enum": [
              "master",
              "slave_ok"
            ],
            "type": "string"
          },
          "replica_set_name": {
            "description": "Name of the replica set.",
            "type": "string"
          },
          "srv_record": {
            "default": false,
            "description": "Use DNS SRV record.",
            "type": "boolean"
          },
          "pool_size": {
            "default": 8,
            "description": "Size of the connection pool.",
            "minimum": 1,
            "type": "integer"
          },
          "username": {
            "description": "EMQX's username in the external database.",
            "type": "string"
          },
          "password": {
            "description": "EMQX's password in the external database.",
            "type": "string"
          },
          "auth_source": {
            "description": "Database name associated with the user's credentials.",
            "type": "string"
          },
          "database": {
            "description": "Database name.",
            "type": "string"
          },
          "topology": {
            "$ref": "#/components/schemas/emqx_connector_mongo.topology"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/broker.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "exhook.node_metrics": {
        "properties": {
          "node": {
            "description": "Node name",
            "type": "string"
          },
          "metrics": {
            "description": "Metrics information",
            "$ref": "#/components/schemas/exhook.metrics"
          }
        },
        "type": "object"
      },
      "exhook.move_req": {
        "required": [
          "position"
        ],
        "properties": {
          "position": {
            "description": "The target position to be moved",
            "example": "front",
            "type": "string"
          }
        },
        "type": "object"
      },
      "broker.zone": {
        "properties": {
          "mqtt": {
            "description": "Global MQTT configuration.</br>The configs here work as default values which can be overridden</br>in <code>zone</code> configs",
            "$ref": "#/components/schemas/zone.mqtt"
          },
          "stats": {
            "description": "Enable/disable statistic data collection.</br>Statistic data such as message receive/send count/rate etc. It provides insights of system performance and helps to diagnose issues. You can find statistic data from the dashboard, or from the '/stats' API.",
            "$ref": "#/components/schemas/zone.stats"
          },
          "flapping_detect": {
            "description": "This config controls the allowed maximum number of `CONNECT` packets received</br>from the same clientid in a time frame defined by `window_time`.</br>After the limit is reached, successive `CONNECT` requests are forbidden</br>(banned) until the end of the time period defined by `ban_time`.",
            "$ref": "#/components/schemas/zone.flapping_detect"
          },
          "force_shutdown": {
            "description": "When the process message queue length, or the memory bytes</br>reaches a certain value, the process is forced to close.</br></br>Note: \"message queue\" here refers to the \"message mailbox\"</br>of the Erlang process, not the `mqueue` of QoS 1 and QoS 2.",
            "$ref": "#/components/schemas/zone.force_shutdown"
          },
          "conn_congestion": {
            "description": "Settings for `conn_congestion` alarm.</br></br>Sometimes the MQTT connection (usually an MQTT subscriber) may</br>get \"congested\", because there are too many packets to be sent.</br>The socket tries to buffer the packets until the buffer is</br>full. If more packets arrive after that, the packets will be</br>\"pending\" in the queue, and we consider the connection</br>congested.</br></br>Note: `sndbuf` can be set to larger value if the</br>alarm is triggered too often.</br>The name of the alarm is of format `conn_congestion/<ClientID>/<Username>`,</br>where the `<ClientID>` is the client ID of the congested MQTT connection,</br>and `<Username>` is the username or `unknown_user`.",
            "$ref": "#/components/schemas/zone.conn_congestion"
          },
          "force_gc": {
            "description": "Force garbage collection in MQTT connection process after</br> they process certain number of messages or bytes of data.",
            "$ref": "#/components/schemas/zone.force_gc"
          },
          "overload_protection": {
            "description": "Overload protection mechanism monitors the load of the system and temporarily</br>disables some features (such as accepting new connections) when the load is high.",
            "$ref": "#/components/schemas/zone.overload_protection"
          }
        },
        "type": "object"
      },
      "emqx_conf_schema.log_overload_kill": {
        "properties": {
          "enable": {
            "default": true,
            "description": "Enable log handler overload kill feature.",
            "type": "boolean"
          },
          "mem_size": {
            "default": "30MB",
            "description": "Maximum memory size that the log handler process is allowed to use.",
            "example": "32MB",
            "type": "string"
          },
          "qlen": {
            "default": 20000,
            "description": "Maximum allowed queue length.",
            "minimum": 1,
            "type": "integer"
          },
          "restart_after": {
            "default": "5s",
            "description": "If the handler is terminated, it restarts automatically after a delay specified in milliseconds. The value `infinity` prevents restarts.",
            "oneOf": [
              {
                "enum": [
                  "infinity"
                ],
                "type": "string"
              },
              {
                "example": "32s",
                "type": "string"
              }
            ]
          }
        },
        "type": "object"
      },
      "exhook.node_status": {
        "properties": {
          "node": {
            "description": "Node name",
            "type": "string"
          },
          "status": {
            "description": "The status of Exhook server.</br>connected: connection succeeded</br>connecting: connection failed, reconnecting</br>disconnected: failed to connect and didn't reconnect</br>disabled: this server is disabled</br>error: failed to view the status of this server</br>",
            "enum": [
              "connected",
              "connecting",
              "disconnected",
              "disabled",
              "error"
            ],
            "type": "string"
          }
        },
        "type": "object"
      },
      "emqx_rule_api_schema.rule_creation": {
        "required": [
          "sql"
        ],
        "properties": {
          "name": {
            "default": "",
            "description": "The name of the rule",
            "example": "foo",
            "type": "string"
          },
          "sql": {
            "description": "</br>SQL query to transform the messages.</br>Example: <code>SELECT * FROM \"test/topic\" WHERE payload.x = 1</code></br>",
            "example": "SELECT * FROM \"test/topic\" WHERE payload.x = 1",
            "type": "string"
          },
          "actions": {
            "default": "",
            "description": "</br>A list of actions of the rule.</br>An action can be a string that refers to the channel ID of an EMQX bridge, or an object</br>that refers to a function.</br>There a some built-in functions like \"republish\" and \"console\", and we also support user</br>provided functions in the format: \"{module}:{function}\".</br>The actions in the list are executed sequentially.</br>This means that if one of the action is executing slowly, all the following actions will not</br>be executed until it returns.</br>If one of the action crashed, all other actions come after it will still be executed, in the</br>original order.</br>If there's any error when running an action, there will be an error message, and the 'failure'</br>counter of the function action or the bridge channel will increase.</br>",
            "example": [
              "webhook:my_webhook",
              {
                "args": {
                  "payload": "${payload}",
                  "topic": "t/1"
                },
                "function": "republish"
              },
              {
                "function": "console"
              }
            ],
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/rule_engine.user_provided_function"
                },
                {
                  "$ref": "#/components/schemas/rule_engine.builtin_action_console"
                },
                {
                  "$ref": "#/components/schemas/rule_engine.builtin_action_republish"
                },
                {
                  "type": "string"
                }
              ]
            },
            "type": "array"
          },
          "enable": {
            "default": true,
            "description": "Enable or disable the rule",
            "type": "boolean"
          },
          "description": {
            "default": "",
            "description": "The description of the rule",
            "example": "Some description",
            "type": "string"
          }
        },
        "type": "object"
      },
      "listeners.ws_required_bind": {
        "required": [
          "bind",
          "id",
          "type"
        ],
        "properties": {
          "type": {
            "description": "Listener type",
            "enum": [
              "ws"
            ],
            "type": "string"
          },
          "running": {
            "description": "Listener status",
            "type": "boolean"
          },
          "id": {
            "description": "Listener id",
            "type": "string"
          },
          "current_connections": {
            "description": "Current connections",
            "minimum": 0,
            "type": "integer"
          },
          "enabled": {
            "default": true,
            "description": "</br>Enable listener.</br>",
            "type": "boolean"
          },
          "bind": {
            "default": 8083,
            "description": "</br>IP address and port for the listening socket.</br>",
            "oneOf": [
              {
                "type": "integer"
              },
              {
                "example": "127.0.0.1:80",
                "type": "string"
              }
            ]
          },
          "acceptors": {
            "default": 16,
            "description": "</br>The size of the listener's receiving pool.</br>",
            "minimum": 1,
            "type": "integer"
          },
          "max_connections": {
            "default": "infinity",
            "description": "</br>The maximum number of concurrent connections allowed by the listener.</br>",
            "oneOf": [
              {
                "minimum": 1,
                "type": "integer"
              },
              {
                "enum": [
                  "infinity"
                ],
                "type": "string"
              }
            ]
          },
          "mountpoint": {
            "default": "",
            "description": "</br>When publishing or subscribing, prefix all topics with a mountpoint string.</br>The prefixed string will be removed from the topic name when the message</br>is delivered to the subscriber. The mountpoint is a way that users can use</br>to implement isolation of message routing between different listeners.</br>For example if a client A subscribes to `t` with `listeners.tcp.\\<name>.mountpoint`</br>set to `some_tenant`, then the client actually subscribes to the topic</br>`some_tenant/t`. Similarly, if another client B (connected to the same listener</br>as the client A) sends a message to topic `t`, the message is routed</br>to all the clients subscribed `some_tenant/t`, so client A will receive the</br>message, with topic name `t`.</br>Set to `\"\"` to disable the feature.</br></br>Variables in mountpoint string:</br>  - <code>${clientid}</code>: clientid</br>  - <code>${username}</code>: username</br>",
            "type": "string"
          },
          "zone": {
            "default": "default",
            "description": "</br>The configuration zone to which the listener belongs.</br>",
            "type": "string"
          },
          "limiter": {
            "default": {
              "connection": "default"
            },
            "description": "</br>Type of the rate limit.</br>",
            "properties": {
              "$ratelimit_name": {
                "example": "retainer",
                "type": "string"
              }
            },
            "type": "object"
          },
          "enable_authn": {
            "default": true,
            "description": "</br>Set <code>true</code> (default) to enable client authentication on this listener.</br>When set to <code>false</code> clients will be allowed to connect without authentication.</br>",
            "type": "boolean"
          },
          "access_rules": {
            "default": [
              "allow all"
            ],
            "description": "</br>The access control rules for this listener.</br>See: https://github.com/emqtt/esockd#allowdeny</br>",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "proxy_protocol": {
            "default": false,
            "description": "</br>Enable the Proxy Protocol V1/2 if the EMQX cluster is deployed behind HAProxy or Nginx.</br>See: https://www.haproxy.com/blog/haproxy/proxy-protocol/</br>",
            "type": "boolean"
          },
          "proxy_protocol_timeout": {
            "default": "3s",
            "description": "</br>Timeout for proxy protocol. EMQX will close the TCP connection if proxy protocol packet is not received within the timeout.</br>",
            "example": "12m",
            "type": "string"
          },
          "tcp_options": {
            "$ref": "#/components/schemas/broker.tcp_opts"
          },
          "websocket": {
            "$ref": "#/components/schemas/broker.ws_opts"
          }
        },
        "type": "object"
      },
      "broker.persistent_session_builtin": {
        "properties": {
          "type": {
            "default": "builtin",
            "description": "",
            "enum": [
              "builtin"
            ],
            "type": "string"
          },
          "session": {
            "description": "Performance tuning options for built-in session table.",
            "$ref": "#/components/schemas/broker.persistent_table_mria_opts"
          },
          "session_messages": {
            "description": "Performance tuning options for built-in session messages table.",
            "$ref": "#/components/schemas/broker.persistent_table_mria_opts"
          },
          "messages": {
            "description": "Performance tuning options for built-in messages table.",
            "$ref": "#/components/schemas/broker.persistent_table_mria_opts"
          }
        },
        "type": "object"
      },
      "listeners.listener_type_status": {
        "required": [
          "ids",
          "enable",
          "type"
        ],
        "properties": {
          "type": {
            "description": "Listener type",
            "enum": [
              "tcp",
              "ssl",
              "ws",
              "wss",
              "quic"
            ],
            "type": "string"
          },
          "enable": {
            "description": "Listener enable",
            "type": "boolean"
          },
          "ids": {
            "description": "Listener Ids",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "status": {
            "$ref": "#/components/schemas/listeners.status"
          },
          "node_status": {
            "items": {
              "$ref": "#/components/schemas/listeners.node_status"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "emqx_authz_api_schema.redis_sentinel": {
        "required": [
          "database",
          "redis_type",
          "servers",
          "cmd",
          "type"
        ],
        "properties": {
          "enable": {
            "default": true,
            "description": "Set to <code>true</code> or <code>false</code> to disable this ACL provider",
            "type": "boolean"
          },
          "type": {
            "default": "redis",
            "description": "Backend type.",
            "enum": [
              "redis"
            ],
            "type": "string"
          },
          "cmd": {
            "description": "Database query used to retrieve authorization data.",
            "example": "HGETALL mqtt_authz",
            "type": "string"
          },
          "servers": {
            "description": "</br>A Node list for Cluster to connect to. The nodes should be separated with commas, such as: `Node[,Node].`</br>For each Node should be: The IPv4 or IPv6 address or the hostname to connect to.</br>A host entry has the following form: `Host[:Port]`.</br>The MongoDB default port 27017 is used if `[:Port]` is not specified.</br>",
            "items": {
              "example": "any",
              "type": "string"
            },
            "type": "array"
          },
          "redis_type": {
            "description": "Sentinel mode",
            "enum": [
              "sentinel"
            ],
            "type": "string"
          },
          "sentinel": {
            "description": "The cluster name in Redis sentinel mode.",
            "type": "string"
          },
          "pool_size": {
            "default": 8,
            "description": "Size of the connection pool.",
            "minimum": 1,
            "type": "integer"
          },
          "password": {
            "description": "EMQX's password in the external database.",
            "type": "string"
          },
          "database": {
            "default": 0,
            "description": "Redis database ID.",
            "type": "integer"
          },
          "auto_reconnect": {
            "default": true,
            "description": "Enable automatic reconnect to the database.",
            "type": "boolean"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/broker.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "gateway.translator": {
        "required": [
          "topic"
        ],
        "properties": {
          "topic": {
            "description": "Topic Name",
            "type": "string"
          },
          "qos": {
            "default": 0,
            "description": "QoS Level",
            "enum": [
              0,
              1,
              2
            ],
            "type": "string"
          }
        },
        "type": "object"
      },
      "emqx_gateway_api.update_disable_enable_only": {
        "properties": {
          "enable": {
            "description": "Enable/Disable the gateway",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "emqx_authz_api_schema.mysql": {
        "required": [
          "database",
          "server",
          "query",
          "type"
        ],
        "properties": {
          "enable": {
            "default": true,
            "description": "Set to <code>true</code> or <code>false</code> to disable this ACL provider",
            "type": "boolean"
          },
          "type": {
            "default": "mysql",
            "description": "Backend type.",
            "enum": [
              "mysql"
            ],
            "type": "string"
          },
          "query": {
            "description": "Database query used to retrieve authorization data.",
            "type": "string"
          },
          "server": {
            "description": "</br>The IPv4 or IPv6 address or the hostname to connect to.</br>A host entry has the following form: `Host[:Port]`.</br>The MySQL default port 3306 is used if `[:Port]` is not specified.</br>",
            "example": "127.0.0.1:80",
            "type": "string"
          },
          "database": {
            "description": "Database name.",
            "type": "string"
          },
          "pool_size": {
            "default": 8,
            "description": "Size of the connection pool.",
            "minimum": 1,
            "type": "integer"
          },
          "username": {
            "description": "EMQX's username in the external database.",
            "type": "string"
          },
          "password": {
            "description": "EMQX's password in the external database.",
            "type": "string"
          },
          "auto_reconnect": {
            "default": true,
            "description": "Enable automatic reconnect to the database.",
            "type": "boolean"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/broker.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "emqx_mgmt_api_stats.aggergate_data": {
        "properties": {
          "node": {
            "description": "Node name",
            "example": "emqx@127.0.0.1",
            "type": "string"
          },
          "channels.count": {
            "description": "sessions.count",
            "example": 0,
            "minimum": 0,
            "type": "integer"
          },
          "channels.max": {
            "description": "session.max",
            "example": 0,
            "minimum": 0,
            "type": "integer"
          },
          "connections.count": {
            "description": "Number of current connections",
            "example": 0,
            "minimum": 0,
            "type": "integer"
          },
          "connections.max": {
            "description": "Historical maximum number of connections",
            "example": 0,
            "minimum": 0,
            "type": "integer"
          },
          "delayed.count": {
            "description": "Number of delayed messages",
            "example": 0,
            "minimum": 0,
            "type": "integer"
          },
          "delayed.max": {
            "description": "Historical maximum number of delayed messages",
            "example": 0,
            "minimum": 0,
            "type": "integer"
          },
          "live_connections.count": {
            "description": "Number of current live connections",
            "example": 0,
            "minimum": 0,
            "type": "integer"
          },
          "live_connections.max": {
            "description": "Historical maximum number of live connections",
            "example": 0,
            "minimum": 0,
            "type": "integer"
          },
          "retained.count": {
            "description": "Number of currently retained messages",
            "example": 0,
            "minimum": 0,
            "type": "integer"
          },
          "retained.max": {
            "description": "Historical maximum number of retained messages",
            "example": 0,
            "minimum": 0,
            "type": "integer"
          },
          "sessions.count": {
            "description": "Number of current sessions",
            "example": 0,
            "minimum": 0,
            "type": "integer"
          },
          "sessions.max": {
            "description": "Historical maximum number of sessions",
            "example": 0,
            "minimum": 0,
            "type": "integer"
          },
          "suboptions.count": {
            "description": "subscriptions.count",
            "example": 0,
            "minimum": 0,
            "type": "integer"
          },
          "suboptions.max": {
            "description": "subscriptions.max",
            "example": 0,
            "minimum": 0,
            "type": "integer"
          },
          "subscribers.count": {
            "description": "Number of current subscribers",
            "example": 0,
            "minimum": 0,
            "type": "integer"
          },
          "subscribers.max": {
            "description": "Historical maximum number of subscribers",
            "example": 0,
            "minimum": 0,
            "type": "integer"
          },
          "subscriptions.count": {
            "description": "Number of current subscriptions, including shared subscriptions",
            "example": 0,
            "minimum": 0,
            "type": "integer"
          },
          "subscriptions.max": {
            "description": "Historical maximum number of subscriptions",
            "example": 0,
            "minimum": 0,
            "type": "integer"
          },
          "subscriptions.shared.count": {
            "description": "Number of current shared subscriptions",
            "example": 0,
            "minimum": 0,
            "type": "integer"
          },
          "subscriptions.shared.max": {
            "description": "Historical maximum number of shared subscriptions",
            "example": 0,
            "minimum": 0,
            "type": "integer"
          },
          "topics.count": {
            "description": "Number of current topics",
            "example": 0,
            "minimum": 0,
            "type": "integer"
          },
          "topics.max": {
            "description": "Historical maximum number of topics",
            "example": 0,
            "minimum": 0,
            "type": "integer"
          }
        },
        "type": "object"
      },
      "authn-redis.standalone": {
        "required": [
          "database",
          "redis_type",
          "server",
          "cmd",
          "backend",
          "mechanism"
        ],
        "properties": {
          "mechanism": {
            "description": "Authentication mechanism.",
            "enum": [
              "password_based"
            ],
            "type": "string"
          },
          "backend": {
            "description": "Backend type.",
            "enum": [
              "redis"
            ],
            "type": "string"
          },
          "cmd": {
            "description": "The Redis Command used to query data for authentication such as password hash, currently only supports <code>HGET</code> and <code>HMGET</code>.",
            "type": "string"
          },
          "password_hash_algorithm": {
            "default": {
              "name": "sha256",
              "salt_position": "prefix"
            },
            "description": "Options for password hash verification.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/authn-hash.other_algorithms"
              },
              {
                "$ref": "#/components/schemas/authn-hash.pbkdf2"
              },
              {
                "$ref": "#/components/schemas/authn-hash.bcrypt"
              }
            ]
          },
          "enable": {
            "default": true,
            "description": "Set to <code>true</code> or <code>false</code> to disable this auth provider.",
            "type": "boolean"
          },
          "server": {
            "description": "</br>The IPv4 or IPv6 address or the hostname to connect to.</br>A host entry has the following form: `Host[:Port]`.</br>The Redis default port 6379 is used if `[:Port]` is not specified.</br>",
            "example": "127.0.0.1:80",
            "type": "string"
          },
          "redis_type": {
            "description": "Single mode",
            "enum": [
              "single"
            ],
            "type": "string"
          },
          "pool_size": {
            "default": 8,
            "description": "Size of the connection pool.",
            "minimum": 1,
            "type": "integer"
          },
          "password": {
            "description": "EMQX's password in the external database.",
            "type": "string"
          },
          "database": {
            "default": 0,
            "description": "Redis database ID.",
            "type": "integer"
          },
          "auto_reconnect": {
            "default": true,
            "description": "Enable automatic reconnect to the database.",
            "type": "boolean"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/broker.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "gateway.ssl_server_opts": {
        "properties": {
          "cacertfile": {
            "description": "</br>Trusted PEM format CA certificates bundle file.</br>The certificates in this file are used to verify the TLS peer's certificates.</br>Append new certificates to the file if new CAs are to be trusted.</br>There is no need to restart EMQX to have the updated file loaded, because</br>the system regularly checks if file has been updated (and reload).</br>NOTE: invalidating (deleting) a certificate from the file will not affect</br>already established connections.</br>",
            "type": "string"
          },
          "certfile": {
            "description": "</br>PEM format certificates chain file.</br>The certificates in this file should be in reversed order of the certificate</br>issue chain. That is, the host's certificate should be placed in the beginning</br>of the file, followed by the immediate issuer certificate and so on.</br>Although the root CA certificate is optional, it should be placed at the end of</br>the file if it is to be added.</br>",
            "type": "string"
          },
          "keyfile": {
            "description": "</br>PEM format private key file.</br>",
            "type": "string"
          },
          "verify": {
            "default": "verify_none",
            "description": "</br>Enable or disable peer verification.</br>",
            "enum": [
              "verify_peer",
              "verify_none"
            ],
            "type": "string"
          },
          "reuse_sessions": {
            "default": true,
            "description": "</br>Enable TLS session reuse.</br>",
            "type": "boolean"
          },
          "depth": {
            "default": 10,
            "description": "</br>Maximum number of non-self-issued intermediate certificates that can follow the peer certificate in a valid certification path. So, if depth is 0 the PEER must be signed by the trusted ROOT-CA directly; if 1 the path can be PEER, CA, ROOT-CA; if 2 the path can be PEER, CA, CA, ROOT-CA, and so on. The default value is 10.</br>",
            "type": "integer"
          },
          "password": {
            "description": "</br>String containing the user's password.</br>Only used if the private key file is password-protected.</br>",
            "example": "",
            "type": "string"
          },
          "versions": {
            "default": [
              "tlsv1.3",
              "tlsv1.2",
              "tlsv1.1",
              "tlsv1"
            ],
            "description": "</br>All TLS/DTLS versions to be supported.</br>NOTE: PSK ciphers are suppressed by 'tlsv1.3' version config.</br>In case PSK cipher suites are intended, make sure to configured</br><code>['tlsv1.2', 'tlsv1.1']</code> here.</br>",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "ciphers": {
            "default": [
              "TLS_AES_256_GCM_SHA384",
              "TLS_AES_128_GCM_SHA256",
              "TLS_CHACHA20_POLY1305_SHA256",
              "TLS_AES_128_CCM_SHA256",
              "TLS_AES_128_CCM_8_SHA256",
              "ECDHE-ECDSA-AES256-GCM-SHA384",
              "ECDHE-RSA-AES256-GCM-SHA384",
              "ECDHE-ECDSA-AES256-SHA384",
              "ECDHE-RSA-AES256-SHA384",
              "ECDH-ECDSA-AES256-GCM-SHA384",
              "ECDH-RSA-AES256-GCM-SHA384",
              "ECDH-ECDSA-AES256-SHA384",
              "ECDH-RSA-AES256-SHA384",
              "DHE-DSS-AES256-GCM-SHA384",
              "DHE-DSS-AES256-SHA256",
              "AES256-GCM-SHA384",
              "AES256-SHA256",
              "ECDHE-ECDSA-AES128-GCM-SHA256",
              "ECDHE-RSA-AES128-GCM-SHA256",
              "ECDHE-ECDSA-AES128-SHA256",
              "ECDHE-RSA-AES128-SHA256",
              "ECDH-ECDSA-AES128-GCM-SHA256",
              "ECDH-RSA-AES128-GCM-SHA256",
              "ECDH-ECDSA-AES128-SHA256",
              "ECDH-RSA-AES128-SHA256",
              "DHE-DSS-AES128-GCM-SHA256",
              "DHE-DSS-AES128-SHA256",
              "AES128-GCM-SHA256",
              "AES128-SHA256",
              "ECDHE-ECDSA-AES256-SHA",
              "ECDHE-RSA-AES256-SHA",
              "DHE-DSS-AES256-SHA",
              "ECDH-ECDSA-AES256-SHA",
              "ECDH-RSA-AES256-SHA",
              "ECDHE-ECDSA-AES128-SHA",
              "ECDHE-RSA-AES128-SHA",
              "DHE-DSS-AES128-SHA",
              "ECDH-ECDSA-AES128-SHA",
              "ECDH-RSA-AES128-SHA",
              "RSA-PSK-AES256-GCM-SHA384",
              "RSA-PSK-AES256-CBC-SHA384",
              "RSA-PSK-AES128-GCM-SHA256",
              "RSA-PSK-AES128-CBC-SHA256",
              "RSA-PSK-AES256-CBC-SHA",
              "RSA-PSK-AES128-CBC-SHA"
            ],
            "description": "</br>This config holds TLS cipher suite names separated by comma,</br>or as an array of strings. e.g.</br><code>\"TLS_AES_256_GCM_SHA384,TLS_AES_128_GCM_SHA256\"</code> or</br><code>[\"TLS_AES_256_GCM_SHA384\",\"TLS_AES_128_GCM_SHA256\"]</code>.</br></br>Ciphers (and their ordering) define the way in which the</br>client and server encrypts information over the network connection.</br>Selecting a good cipher suite is critical for the</br>application's data security, confidentiality and performance.</br></br>The names should be in OpenSSL string format (not RFC format).</br>All default values and examples provided by EMQX config</br>documentation are all in OpenSSL format.</br></br>NOTE: Certain cipher suites are only compatible with</br>specific TLS <code>versions</code> ('tlsv1.1', 'tlsv1.2' or 'tlsv1.3')</br>incompatible cipher suites will be silently dropped.</br>For instance, if only 'tlsv1.3' is given in the <code>versions</code>,</br>configuring cipher suites for other versions will have no effect.</br></br></br>NOTE: PSK ciphers are suppressed by 'tlsv1.3' version config</br>If PSK cipher suites are intended, 'tlsv1.3' should be disabled from <code>versions</code>.</br>PSK cipher suites: <code>\"RSA-PSK-AES256-GCM-SHA384,RSA-PSK-AES256-CBC-SHA384,</br>RSA-PSK-AES128-GCM-SHA256,RSA-PSK-AES128-CBC-SHA256,</br>RSA-PSK-AES256-CBC-SHA,RSA-PSK-AES128-CBC-SHA,</br>RSA-PSK-DES-CBC3-SHA,RSA-PSK-RC4-SHA\"</code></br>",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "user_lookup_fun": {
            "default": "emqx_tls_psk:lookup",
            "description": "</br>EMQX-internal callback that is used to lookup pre-shared key (PSK) identity.</br>",
            "type": "string"
          },
          "secure_renegotiate": {
            "default": true,
            "description": "</br>SSL parameter renegotiation is a feature that allows a client and a server</br>to renegotiate the parameters of the SSL connection on the fly.</br>RFC 5746 defines a more secure way of doing this. By enabling secure renegotiation,</br>you drop support for the insecure renegotiation, prone to MitM attacks.</br>",
            "type": "boolean"
          },
          "dhfile": {
            "description": "</br>Path to a file containing PEM-encoded Diffie-Hellman parameters</br>to be used by the server if a cipher suite using Diffie-Hellman</br>key exchange is negotiated. If not specified, default parameters</br>are used.</br>NOTE: The <code>dhfile</code> option is not supported by TLS 1.3.</br>",
            "type": "string"
          },
          "fail_if_no_peer_cert": {
            "default": false,
            "description": "</br>Used together with {verify, verify_peer} by an TLS/DTLS server.</br>If set to true, the server fails if the client does not have a</br>certificate to send, that is, sends an empty certificate.</br>If set to false, it fails only if the client sends an invalid</br>certificate (an empty certificate is considered valid).</br>",
            "type": "boolean"
          },
          "honor_cipher_order": {
            "default": true,
            "description": "</br>An important security setting, it forces the cipher to be set based</br> on the server-specified order instead of the client-specified order,</br> hence enforcing the (usually more properly configured) security</br> ordering of the server administrator.</br>",
            "type": "boolean"
          },
          "client_renegotiation": {
            "default": true,
            "description": "</br>In protocols that support client-initiated renegotiation,</br>the cost of resources of such an operation is higher for the server than the client.</br>This can act as a vector for denial of service attacks.</br>The SSL application already takes measures to counter-act such attempts,</br>but client-initiated renegotiation can be strictly disabled by setting this option to false.</br>The default value is true. Note that disabling renegotiation can result in</br>long-lived connections becoming unusable due to limits on</br>the number of messages the underlying cipher suite can encipher.</br>",
            "type": "boolean"
          },
          "handshake_timeout": {
            "default": "15s",
            "description": "</br>Maximum time duration allowed for the handshake to complete</br>",
            "example": "12m",
            "type": "string"
          }
        },
        "type": "object"
      },
      "authn-jwt.public-key": {
        "required": [
          "mechanism",
          "algorithm",
          "use_jwks"
        ],
        "properties": {
          "use_jwks": {
            "description": "Whether to use JWKS.",
            "enum": [
              false
            ],
            "type": "string"
          },
          "algorithm": {
            "description": "JWT signing algorithm, Supports HMAC (configured as <code>hmac-based</code>) and RSA, ECDSA (configured as <code>public-key</code>).",
            "enum": [
              "public-key"
            ],
            "type": "string"
          },
          "public_key": {
            "description": "The public key used to verify the JWT.",
            "type": "string"
          },
          "mechanism": {
            "description": "Authentication mechanism.",
            "enum": [
              "jwt"
            ],
            "type": "string"
          },
          "acl_claim_name": {
            "default": "acl",
            "description": "JWT claim name to use for getting ACL rules.",
            "type": "string"
          },
          "verify_claims": {
            "default": {},
            "description": "</br>A list of custom claims to validate, which is a list of name/value pairs.</br>Values can use the following placeholders:</br>- <code>${username}</code>: Will be replaced at runtime with <code>Username</code> used by the client when connecting</br>- <code>${clientid}</code>: Will be replaced at runtime with <code>Client ID</code> used by the client when connecting</br>Authentication will verify that the value of claims in the JWT (taken from the Password field) matches what is required in <code>verify_claims</code>.</br>",
            "items": {
              "example": "any",
              "type": "string"
            },
            "type": "array"
          },
          "from": {
            "default": "password",
            "description": "Field to take JWT from.",
            "enum": [
              "username",
              "password"
            ],
            "type": "string"
          },
          "enable": {
            "default": true,
            "description": "Set to <code>true</code> or <code>false</code> to disable this auth provider.",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "emqx_bridge_mqtt_schema.put_ingress": {
        "required": [
          "remote_topic",
          "connector",
          "direction"
        ],
        "properties": {
          "direction": {
            "default": "egress",
            "description": "The direction of the bridge. Can be one of 'ingress' or 'egress'.</br>The ingress config defines how this bridge receive messages from the remote MQTT broker, and then</br>send them to the local broker.</br>Template with variables is allowed in 'local_topic', 'remote_qos', 'qos', 'retain',</br>'payload'.</br>NOTE: if this bridge is used as the input of a rule (emqx rule engine), and also local_topic is</br>configured, then messages got from the remote broker will be sent to both the 'local_topic' and</br>the rule.</br>",
            "enum": [
              "ingress"
            ],
            "type": "string"
          },
          "connector": {
            "description": "</br>The ID or the configs of the connector to be used for this bridge. Connector IDs must be of format:</br><code>{type}:{name}</code>.</br>In config files, you can find the corresponding config entry for a connector by such path:</br>'connectors.{type}.{name}'.</br>",
            "example": "mqtt:my_mqtt_connector",
            "oneOf": [
              {
                "$ref": "#/components/schemas/connector-mqtt.connector"
              },
              {
                "type": "string"
              }
            ]
          },
          "remote_topic": {
            "description": "Receive messages from which topic of the remote broker",
            "type": "string"
          },
          "remote_qos": {
            "default": 1,
            "description": "The QoS level to be used when subscribing to the remote broker",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "enum": [
                  0,
                  1,
                  2
                ],
                "type": "string"
              }
            ]
          },
          "local_topic": {
            "description": "</br>Send messages to which topic of the local broker.</br>Template with variables is allowed.</br>",
            "type": "string"
          },
          "local_qos": {
            "default": "${qos}",
            "description": "</br>The QoS of the MQTT message to be sent.</br>Template with variables is allowed.</br>",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "enum": [
                  0,
                  1,
                  2
                ],
                "type": "string"
              }
            ]
          },
          "retain": {
            "default": "${retain}",
            "description": "</br>The 'retain' flag of the MQTT message to be sent.</br>Template with variables is allowed.</br>",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "boolean"
              }
            ]
          },
          "payload": {
            "default": "${payload}",
            "description": "</br>The payload of the MQTT message to be sent.</br>Template with variables is allowed.</br>",
            "type": "string"
          }
        },
        "type": "object"
      },
      "emqx_mgmt_api_alarms.alarm": {
        "properties": {
          "node": {
            "description": "Alarm in node",
            "example": "emqx@127.0.0.1",
            "type": "string"
          },
          "name": {
            "description": "Alarm in node",
            "example": "high_system_memory_usage",
            "type": "string"
          },
          "message": {
            "description": "Alarm readable information",
            "example": "System memory usage is higher than 70%",
            "type": "string"
          },
          "details": {
            "description": "Alarm details information",
            "example": {
              "high_watermark": 70
            },
            "type": "object"
          },
          "duration": {
            "description": "Alarms duration time; UNIX time stamp, millisecond",
            "example": 297056,
            "type": "integer"
          },
          "activate_at": {
            "description": "Alarms activate time, RFC 3339",
            "example": "2021-10-25T11:52:52.548+08:00",
            "type": "string"
          },
          "deactivate_at": {
            "description": "Alarms deactivate time, RFC 3339",
            "example": "2021-10-31T10:52:52.548+08:00",
            "type": "string"
          }
        },
        "type": "object"
      },
      "emqx_conf_schema.cluster_static": {
        "properties": {
          "seeds": {
            "default": "",
            "description": "List EMQX node names in the static cluster. See <code>node.name</code>.",
            "items": {
              "type": "string"
            },
            "readOnly": true,
            "type": "array"
          }
        },
        "type": "object"
      },
      "authn-redis.sentinel": {
        "required": [
          "database",
          "redis_type",
          "servers",
          "cmd",
          "backend",
          "mechanism"
        ],
        "properties": {
          "mechanism": {
            "description": "Authentication mechanism.",
            "enum": [
              "password_based"
            ],
            "type": "string"
          },
          "backend": {
            "description": "Backend type.",
            "enum": [
              "redis"
            ],
            "type": "string"
          },
          "cmd": {
            "description": "The Redis Command used to query data for authentication such as password hash, currently only supports <code>HGET</code> and <code>HMGET</code>.",
            "type": "string"
          },
          "password_hash_algorithm": {
            "default": {
              "name": "sha256",
              "salt_position": "prefix"
            },
            "description": "Options for password hash verification.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/authn-hash.other_algorithms"
              },
              {
                "$ref": "#/components/schemas/authn-hash.pbkdf2"
              },
              {
                "$ref": "#/components/schemas/authn-hash.bcrypt"
              }
            ]
          },
          "enable": {
            "default": true,
            "description": "Set to <code>true</code> or <code>false</code> to disable this auth provider.",
            "type": "boolean"
          },
          "servers": {
            "description": "</br>A Node list for Cluster to connect to. The nodes should be separated with commas, such as: `Node[,Node].`</br>For each Node should be: The IPv4 or IPv6 address or the hostname to connect to.</br>A host entry has the following form: `Host[:Port]`.</br>The MongoDB default port 27017 is used if `[:Port]` is not specified.</br>",
            "items": {
              "example": "any",
              "type": "string"
            },
            "type": "array"
          },
          "redis_type": {
            "description": "Sentinel mode",
            "enum": [
              "sentinel"
            ],
            "type": "string"
          },
          "sentinel": {
            "description": "The cluster name in Redis sentinel mode.",
            "type": "string"
          },
          "pool_size": {
            "default": 8,
            "description": "Size of the connection pool.",
            "minimum": 1,
            "type": "integer"
          },
          "password": {
            "description": "EMQX's password in the external database.",
            "type": "string"
          },
          "database": {
            "default": 0,
            "description": "Redis database ID.",
            "type": "integer"
          },
          "auto_reconnect": {
            "default": true,
            "description": "Enable automatic reconnect to the database.",
            "type": "boolean"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/broker.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "broker.ssl_client_opts": {
        "properties": {
          "cacertfile": {
            "description": "</br>Trusted PEM format CA certificates bundle file.</br>The certificates in this file are used to verify the TLS peer's certificates.</br>Append new certificates to the file if new CAs are to be trusted.</br>There is no need to restart EMQX to have the updated file loaded, because</br>the system regularly checks if file has been updated (and reload).</br>NOTE: invalidating (deleting) a certificate from the file will not affect</br>already established connections.</br>",
            "type": "string"
          },
          "certfile": {
            "description": "</br>PEM format certificates chain file.</br>The certificates in this file should be in reversed order of the certificate</br>issue chain. That is, the host's certificate should be placed in the beginning</br>of the file, followed by the immediate issuer certificate and so on.</br>Although the root CA certificate is optional, it should be placed at the end of</br>the file if it is to be added.</br>",
            "type": "string"
          },
          "keyfile": {
            "description": "</br>PEM format private key file.</br>",
            "type": "string"
          },
          "verify": {
            "default": "verify_none",
            "description": "</br>Enable or disable peer verification.</br>",
            "enum": [
              "verify_peer",
              "verify_none"
            ],
            "type": "string"
          },
          "reuse_sessions": {
            "default": true,
            "description": "</br>Enable TLS session reuse.</br>",
            "type": "boolean"
          },
          "depth": {
            "default": 10,
            "description": "</br>Maximum number of non-self-issued intermediate certificates that can follow the peer certificate in a valid certification path. So, if depth is 0 the PEER must be signed by the trusted ROOT-CA directly; if 1 the path can be PEER, CA, ROOT-CA; if 2 the path can be PEER, CA, CA, ROOT-CA, and so on. The default value is 10.</br>",
            "type": "integer"
          },
          "password": {
            "description": "</br>String containing the user's password.</br>Only used if the private key file is password-protected.</br>",
            "example": "",
            "type": "string"
          },
          "versions": {
            "default": [
              "tlsv1.3",
              "tlsv1.2",
              "tlsv1.1",
              "tlsv1"
            ],
            "description": "</br>All TLS/DTLS versions to be supported.</br>NOTE: PSK ciphers are suppressed by 'tlsv1.3' version config.</br>In case PSK cipher suites are intended, make sure to configured</br><code>['tlsv1.2', 'tlsv1.1']</code> here.</br>",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "ciphers": {
            "default": [
              "TLS_AES_256_GCM_SHA384",
              "TLS_AES_128_GCM_SHA256",
              "TLS_CHACHA20_POLY1305_SHA256",
              "TLS_AES_128_CCM_SHA256",
              "TLS_AES_128_CCM_8_SHA256",
              "ECDHE-ECDSA-AES256-GCM-SHA384",
              "ECDHE-RSA-AES256-GCM-SHA384",
              "ECDHE-ECDSA-AES256-SHA384",
              "ECDHE-RSA-AES256-SHA384",
              "ECDH-ECDSA-AES256-GCM-SHA384",
              "ECDH-RSA-AES256-GCM-SHA384",
              "ECDH-ECDSA-AES256-SHA384",
              "ECDH-RSA-AES256-SHA384",
              "DHE-DSS-AES256-GCM-SHA384",
              "DHE-DSS-AES256-SHA256",
              "AES256-GCM-SHA384",
              "AES256-SHA256",
              "ECDHE-ECDSA-AES128-GCM-SHA256",
              "ECDHE-RSA-AES128-GCM-SHA256",
              "ECDHE-ECDSA-AES128-SHA256",
              "ECDHE-RSA-AES128-SHA256",
              "ECDH-ECDSA-AES128-GCM-SHA256",
              "ECDH-RSA-AES128-GCM-SHA256",
              "ECDH-ECDSA-AES128-SHA256",
              "ECDH-RSA-AES128-SHA256",
              "DHE-DSS-AES128-GCM-SHA256",
              "DHE-DSS-AES128-SHA256",
              "AES128-GCM-SHA256",
              "AES128-SHA256",
              "ECDHE-ECDSA-AES256-SHA",
              "ECDHE-RSA-AES256-SHA",
              "DHE-DSS-AES256-SHA",
              "ECDH-ECDSA-AES256-SHA",
              "ECDH-RSA-AES256-SHA",
              "ECDHE-ECDSA-AES128-SHA",
              "ECDHE-RSA-AES128-SHA",
              "DHE-DSS-AES128-SHA",
              "ECDH-ECDSA-AES128-SHA",
              "ECDH-RSA-AES128-SHA",
              "RSA-PSK-AES256-GCM-SHA384",
              "RSA-PSK-AES256-CBC-SHA384",
              "RSA-PSK-AES128-GCM-SHA256",
              "RSA-PSK-AES128-CBC-SHA256",
              "RSA-PSK-AES256-CBC-SHA",
              "RSA-PSK-AES128-CBC-SHA"
            ],
            "description": "</br>This config holds TLS cipher suite names separated by comma,</br>or as an array of strings. e.g.</br><code>\"TLS_AES_256_GCM_SHA384,TLS_AES_128_GCM_SHA256\"</code> or</br><code>[\"TLS_AES_256_GCM_SHA384\",\"TLS_AES_128_GCM_SHA256\"]</code>.</br></br>Ciphers (and their ordering) define the way in which the</br>client and server encrypts information over the network connection.</br>Selecting a good cipher suite is critical for the</br>application's data security, confidentiality and performance.</br></br>The names should be in OpenSSL string format (not RFC format).</br>All default values and examples provided by EMQX config</br>documentation are all in OpenSSL format.</br></br>NOTE: Certain cipher suites are only compatible with</br>specific TLS <code>versions</code> ('tlsv1.1', 'tlsv1.2' or 'tlsv1.3')</br>incompatible cipher suites will be silently dropped.</br>For instance, if only 'tlsv1.3' is given in the <code>versions</code>,</br>configuring cipher suites for other versions will have no effect.</br></br></br>NOTE: PSK ciphers are suppressed by 'tlsv1.3' version config</br>If PSK cipher suites are intended, 'tlsv1.3' should be disabled from <code>versions</code>.</br>PSK cipher suites: <code>\"RSA-PSK-AES256-GCM-SHA384,RSA-PSK-AES256-CBC-SHA384,</br>RSA-PSK-AES128-GCM-SHA256,RSA-PSK-AES128-CBC-SHA256,</br>RSA-PSK-AES256-CBC-SHA,RSA-PSK-AES128-CBC-SHA,</br>RSA-PSK-DES-CBC3-SHA,RSA-PSK-RC4-SHA\"</code></br>",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "user_lookup_fun": {
            "default": "emqx_tls_psk:lookup",
            "description": "</br>EMQX-internal callback that is used to lookup pre-shared key (PSK) identity.</br>",
            "type": "string"
          },
          "secure_renegotiate": {
            "default": true,
            "description": "</br>SSL parameter renegotiation is a feature that allows a client and a server</br>to renegotiate the parameters of the SSL connection on the fly.</br>RFC 5746 defines a more secure way of doing this. By enabling secure renegotiation,</br>you drop support for the insecure renegotiation, prone to MitM attacks.</br>",
            "type": "boolean"
          },
          "enable": {
            "default": false,
            "description": "</br>Enable TLS.</br>",
            "type": "boolean"
          },
          "server_name_indication": {
            "description": "</br>Specify the host name to be used in TLS Server Name Indication extension.</br>For instance, when connecting to \"server.example.net\", the genuine server</br>which accepts the connection and performs TLS handshake may differ from the</br>host the TLS client initially connects to, e.g. when connecting to an IP address</br>or when the host has multiple resolvable DNS records </br>If not specified, it will default to the host name string which is used</br>to establish the connection, unless it is IP addressed used.</br>The host name is then also used in the host name verification of the peer</br>certificate.</br> The special value 'disable' prevents the Server Name</br>Indication extension from being sent and disables the hostname</br>verification check.</br>",
            "example": "disable",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "enum": [
                  "disable"
                ],
                "type": "string"
              }
            ]
          }
        },
        "type": "object"
      },
      "emqx_conf_schema.cluster_call": {
        "properties": {
          "retry_interval": {
            "default": "1m",
            "description": "Time interval to retry after a failed call.",
            "example": "12m",
            "type": "string"
          },
          "max_history": {
            "default": 100,
            "description": "Retain the maximum number of completed transactions (for queries).",
            "maximum": 500,
            "minimum": 1,
            "type": "integer"
          },
          "cleanup_interval": {
            "default": "5m",
            "description": "Time interval to clear completed but stale transactions.</br>Ensure that the number of completed transactions is less than the <code>max_history</code>.",
            "example": "12m",
            "type": "string"
          }
        },
        "type": "object"
      },
      "zone.overload_protection": {
        "properties": {
          "enable": {
            "description": "React on system overload or not",
            "type": "boolean"
          },
          "backoff_delay": {
            "description": "Some unimportant tasks could be delayed for execution, here set the delays in ms",
            "minimum": 0,
            "type": "integer"
          },
          "backoff_gc": {
            "description": "Skip forceful GC if necessary",
            "type": "boolean"
          },
          "backoff_hibernation": {
            "description": "Skip process hibernation if necessary",
            "type": "boolean"
          },
          "backoff_new_conn": {
            "description": "Close new incoming connections if necessary",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "emqx_authz_api_schema.file": {
        "required": [
          "rules",
          "type"
        ],
        "properties": {
          "enable": {
            "default": true,
            "description": "Set to <code>true</code> or <code>false</code> to disable this ACL provider",
            "type": "boolean"
          },
          "type": {
            "default": "file",
            "description": "Backend type.",
            "enum": [
              "file"
            ],
            "type": "string"
          },
          "rules": {
            "description": "Authorization static file rules.",
            "example": "{allow,{username,\"^dashboard?\"},subscribe,[\"$SYS/#\"]}.\n{allow,{ipaddr,\"127.0.0.1\"},all,[\"$SYS/#\",\"#\"]}.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "exhook.detail_server_info": {
        "required": [
          "url",
          "name"
        ],
        "properties": {
          "metrics": {
            "description": "Metrics information of this server in the current node",
            "$ref": "#/components/schemas/exhook.metrics"
          },
          "node_metrics": {
            "description": "Metrics information of this server in all nodes",
            "items": {
              "$ref": "#/components/schemas/exhook.node_metrics"
            },
            "type": "array"
          },
          "node_status": {
            "description": "status of this server in all nodes",
            "items": {
              "$ref": "#/components/schemas/exhook.node_status"
            },
            "type": "array"
          },
          "hooks": {
            "items": {
              "$ref": "#/components/schemas/exhook.hook_info"
            },
            "type": "array"
          },
          "name": {
            "description": "Name of the exhook server",
            "example": "default",
            "type": "string"
          },
          "enable": {
            "default": true,
            "description": "Enable this Exhook server",
            "type": "boolean"
          },
          "url": {
            "description": "URL of the gRPC server",
            "example": "http://127.0.0.1:9000",
            "type": "string"
          },
          "request_timeout": {
            "default": "5s",
            "description": "The timeout of request gRPC server",
            "example": "12m",
            "type": "string"
          },
          "failed_action": {
            "default": "deny",
            "description": "The value that is returned when the request to the gRPC server fails for any reason",
            "enum": [
              "deny",
              "ignore"
            ],
            "type": "string"
          },
          "ssl": {
            "$ref": "#/components/schemas/exhook.ssl_conf"
          },
          "socket_options": {
            "default": {
              "keepalive": true,
              "nodelay": true
            },
            "$ref": "#/components/schemas/exhook.socket_options"
          },
          "auto_reconnect": {
            "default": "60s",
            "description": "Whether to automatically reconnect (initialize) the gRPC server.</br>When gRPC is not available, Exhook tries to request the gRPC service at that interval and reinitialize the list of mounted hooks.",
            "oneOf": [
              {
                "example": "12m",
                "type": "string"
              },
              {
                "enum": [
                  false
                ],
                "type": "string"
              }
            ]
          },
          "pool_size": {
            "default": 8,
            "description": "The process pool size for gRPC client",
            "minimum": 1,
            "type": "integer"
          }
        },
        "type": "object"
      },
      "emqx_dashboard_monitor_api.sampler": {
        "properties": {
          "time_stamp": {
            "description": "Timestamp",
            "minimum": 0,
            "type": "integer"
          },
          "subscriptions": {
            "description": "Subscriptions at the time of sampling. Can only represent the approximate state",
            "type": "integer"
          },
          "topics": {
            "description": "Count topics at the time of sampling. Can only represent the approximate state",
            "type": "integer"
          },
          "connections": {
            "description": "Connections at the time of sampling. Can only represent the approximate state",
            "type": "integer"
          },
          "received": {
            "description": "Received messages last 10 seconds",
            "type": "integer"
          },
          "sent": {
            "description": "Sent messages last 10 seconds",
            "type": "integer"
          },
          "dropped": {
            "description": "Dropped messages last 10 seconds",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "broker.trace": {
        "properties": {
          "payload_encode": {
            "default": "text",
            "description": "</br>Determine the format of the payload format in the trace file.</br>`text`: Text-based protocol or plain text protocol.</br> It is recommended when payload is JSON encoded.</br>`hex`: Binary hexadecimal encode. It is recommended when payload is a custom binary protocol.</br>`hidden`: payload is obfuscated as `******`</br></br>",
            "enum": [
              "hex",
              "text",
              "hidden"
            ],
            "type": "string"
          }
        },
        "type": "object"
      },
      "emqx_rule_api_schema.ctx_check_authz_complete": {
        "required": [
          "event_type"
        ],
        "properties": {
          "event_type": {
            "description": "Event Type",
            "enum": [
              "client_check_authz_complete"
            ],
            "type": "string"
          },
          "clientid": {
            "description": "The Client ID",
            "type": "string"
          },
          "username": {
            "description": "The User Name",
            "type": "string"
          },
          "peerhost": {
            "description": "The IP Address of the Peer Client",
            "type": "string"
          },
          "topic": {
            "description": "Message Topic",
            "type": "string"
          },
          "action": {
            "description": "Publish or Subscribe",
            "type": "string"
          },
          "authz_source": {
            "description": "Cache, Plugs or Default",
            "type": "string"
          },
          "result": {
            "description": "Allow or Deny",
            "type": "string"
          }
        },
        "type": "object"
      },
      "authz.metrics_status_fields": {
        "properties": {
          "resource_metrics": {
            "description": "The metrics of the resource.",
            "$ref": "#/components/schemas/authz.resource_metrics"
          },
          "node_resource_metrics": {
            "description": "The metrics of the resource for each node.",
            "items": {
              "$ref": "#/components/schemas/authz.node_resource_metrics"
            },
            "type": "array"
          },
          "metrics": {
            "description": "The metrics of the resource.",
            "$ref": "#/components/schemas/authz.metrics"
          },
          "node_metrics": {
            "description": "The metrics of the resource for each node.",
            "items": {
              "$ref": "#/components/schemas/authz.node_metrics"
            },
            "type": "array"
          },
          "status": {
            "description": "The status of the resource.",
            "enum": [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "type": "string"
          },
          "node_status": {
            "description": "The status of the resource for each node.",
            "items": {
              "$ref": "#/components/schemas/authz.node_status"
            },
            "type": "array"
          },
          "node_error": {
            "description": "The error of node.",
            "items": {
              "$ref": "#/components/schemas/authz.node_error"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "authn-hash.other_algorithms": {
        "required": [
          "name"
        ],
        "properties": {
          "name": {
            "description": "Simple password hashing algorithm.",
            "enum": [
              "plain",
              "md5",
              "sha",
              "sha256",
              "sha512"
            ],
            "type": "string"
          },
          "salt_position": {
            "default": "prefix",
            "description": "Salt position for PLAIN, MD5, SHA, SHA256 and SHA512 algorithms.",
            "enum": [
              "disable",
              "prefix",
              "suffix"
            ],
            "type": "string"
          }
        },
        "type": "object"
      },
      "emqx_authn_api.response_user": {
        "required": [
          "user_id"
        ],
        "properties": {
          "user_id": {
            "type": "string"
          },
          "is_superuser": {
            "default": false,
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "broker.sysmon_vm": {
        "properties": {
          "process_check_interval": {
            "default": "30s",
            "description": "The time interval for the periodic process limit check.",
            "example": "12m",
            "type": "string"
          },
          "process_high_watermark": {
            "default": "80%",
            "description": "The threshold, as percentage of processes, for how many</br> processes can simultaneously exist at the local node before the corresponding</br> alarm is raised.",
            "example": "12%",
            "type": "number"
          },
          "process_low_watermark": {
            "default": "60%",
            "description": "The threshold, as percentage of processes, for how many</br> processes can simultaneously exist at the local node before the corresponding</br> alarm is cleared.",
            "example": "12%",
            "type": "number"
          },
          "long_gc": {
            "default": "disabled",
            "description": "Enable Long GC monitoring.",
            "oneOf": [
              {
                "example": "12m",
                "type": "string"
              },
              {
                "enum": [
                  "disabled"
                ],
                "type": "string"
              }
            ]
          },
          "long_schedule": {
            "default": "240ms",
            "description": "Enable Long Schedule monitoring.",
            "oneOf": [
              {
                "example": "12m",
                "type": "string"
              },
              {
                "enum": [
                  "disabled"
                ],
                "type": "string"
              }
            ]
          },
          "large_heap": {
            "default": "32MB",
            "description": "Enable Large Heap monitoring.",
            "oneOf": [
              {
                "example": "32MB",
                "type": "string"
              },
              {
                "enum": [
                  "disabled"
                ],
                "type": "string"
              }
            ]
          },
          "busy_dist_port": {
            "default": true,
            "description": "Enable Busy Distribution Port monitoring.",
            "type": "boolean"
          },
          "busy_port": {
            "default": true,
            "description": "Enable Busy Port monitoring.",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "exhook.metrics": {
        "properties": {
          "succeed": {
            "description": "The number of times the hooks execution successful",
            "type": "integer"
          },
          "failed": {
            "description": "The number of times the hook execution failed",
            "type": "integer"
          },
          "rate": {
            "description": "The call rate of hooks",
            "type": "integer"
          },
          "max_rate": {
            "description": "Maximum call rate of hooks",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "emqx_rule_api_schema.ctx_disconnected": {
        "required": [
          "event_type"
        ],
        "properties": {
          "event_type": {
            "description": "Event Type",
            "enum": [
              "client_disconnected"
            ],
            "type": "string"
          },
          "clientid": {
            "description": "The Client ID",
            "type": "string"
          },
          "username": {
            "description": "The User Name",
            "type": "string"
          },
          "reason": {
            "description": "The Reason for Disconnect",
            "type": "string"
          },
          "peername": {
            "description": "The IP Address and Port of the Peer Client",
            "type": "string"
          },
          "sockname": {
            "description": "The IP Address and Port of the Local Listener",
            "type": "string"
          },
          "disconnected_at": {
            "description": "The Time that this Client is Disconnected",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "dashboard.listeners": {
        "properties": {
          "http": {
            "description": "TCP listeners",
            "$ref": "#/components/schemas/dashboard.http"
          },
          "https": {
            "description": "SSL listeners",
            "$ref": "#/components/schemas/dashboard.https"
          }
        },
        "type": "object"
      },
      "listeners.tcp_required_bind": {
        "required": [
          "bind",
          "id",
          "type"
        ],
        "properties": {
          "type": {
            "description": "Listener type",
            "enum": [
              "tcp"
            ],
            "type": "string"
          },
          "running": {
            "description": "Listener status",
            "type": "boolean"
          },
          "id": {
            "description": "Listener id",
            "type": "string"
          },
          "current_connections": {
            "description": "Current connections",
            "minimum": 0,
            "type": "integer"
          },
          "enabled": {
            "default": true,
            "description": "</br>Enable listener.</br>",
            "type": "boolean"
          },
          "bind": {
            "default": 1883,
            "description": "</br>IP address and port for the listening socket.</br>",
            "oneOf": [
              {
                "type": "integer"
              },
              {
                "example": "127.0.0.1:80",
                "type": "string"
              }
            ]
          },
          "acceptors": {
            "default": 16,
            "description": "</br>The size of the listener's receiving pool.</br>",
            "minimum": 1,
            "type": "integer"
          },
          "max_connections": {
            "default": "infinity",
            "description": "</br>The maximum number of concurrent connections allowed by the listener.</br>",
            "oneOf": [
              {
                "minimum": 1,
                "type": "integer"
              },
              {
                "enum": [
                  "infinity"
                ],
                "type": "string"
              }
            ]
          },
          "mountpoint": {
            "default": "",
            "description": "</br>When publishing or subscribing, prefix all topics with a mountpoint string.</br>The prefixed string will be removed from the topic name when the message</br>is delivered to the subscriber. The mountpoint is a way that users can use</br>to implement isolation of message routing between different listeners.</br>For example if a client A subscribes to `t` with `listeners.tcp.\\<name>.mountpoint`</br>set to `some_tenant`, then the client actually subscribes to the topic</br>`some_tenant/t`. Similarly, if another client B (connected to the same listener</br>as the client A) sends a message to topic `t`, the message is routed</br>to all the clients subscribed `some_tenant/t`, so client A will receive the</br>message, with topic name `t`.</br>Set to `\"\"` to disable the feature.</br></br>Variables in mountpoint string:</br>  - <code>${clientid}</code>: clientid</br>  - <code>${username}</code>: username</br>",
            "type": "string"
          },
          "zone": {
            "default": "default",
            "description": "</br>The configuration zone to which the listener belongs.</br>",
            "type": "string"
          },
          "limiter": {
            "default": {
              "connection": "default"
            },
            "description": "</br>Type of the rate limit.</br>",
            "properties": {
              "$ratelimit_name": {
                "example": "retainer",
                "type": "string"
              }
            },
            "type": "object"
          },
          "enable_authn": {
            "default": true,
            "description": "</br>Set <code>true</code> (default) to enable client authentication on this listener.</br>When set to <code>false</code> clients will be allowed to connect without authentication.</br>",
            "type": "boolean"
          },
          "access_rules": {
            "default": [
              "allow all"
            ],
            "description": "</br>The access control rules for this listener.</br>See: https://github.com/emqtt/esockd#allowdeny</br>",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "proxy_protocol": {
            "default": false,
            "description": "</br>Enable the Proxy Protocol V1/2 if the EMQX cluster is deployed behind HAProxy or Nginx.</br>See: https://www.haproxy.com/blog/haproxy/proxy-protocol/</br>",
            "type": "boolean"
          },
          "proxy_protocol_timeout": {
            "default": "3s",
            "description": "</br>Timeout for proxy protocol. EMQX will close the TCP connection if proxy protocol packet is not received within the timeout.</br>",
            "example": "12m",
            "type": "string"
          },
          "tcp_options": {
            "$ref": "#/components/schemas/broker.tcp_opts"
          }
        },
        "type": "object"
      },
      "broker.alarm": {
        "properties": {
          "actions": {
            "default": [
              "log",
              "publish"
            ],
            "description": "The actions triggered when the alarm is activated.</br>Currently, the following actions are supported: <code>log</code> and <code>publish</code>.</br><code>log</code> is to write the alarm to log (console or file).</br><code>publish</code> is to publish the alarm as an MQTT message to the system topics:</br><code>$SYS/brokers/emqx@xx.xx.xx.x/alarms/activate</code> and</br><code>$SYS/brokers/emqx@xx.xx.xx.x/alarms/deactivate</code>",
            "example": [
              "log",
              "publish"
            ],
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "size_limit": {
            "default": 1000,
            "description": "The maximum total number of deactivated alarms to keep as history.</br>When this limit is exceeded, the oldest deactivated alarms are deleted to cap the total number.</br>",
            "example": 1000,
            "maximum": 3000,
            "minimum": 1,
            "type": "integer"
          },
          "validity_period": {
            "default": "24h",
            "description": "Retention time of deactivated alarms. Alarms are not deleted immediately</br>when deactivated, but after the retention time.</br>",
            "example": "24h",
            "type": "string"
          }
        },
        "type": "object"
      },
      "connector-mqtt.replayq": {
        "properties": {
          "dir": {
            "description": "</br>The dir where the replayq file saved.</br>Set to 'false' disables the replayq feature.</br>",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "boolean"
              }
            ]
          },
          "seg_bytes": {
            "default": "100MB",
            "description": "</br>The size in bytes of a single segment.</br>A segment is mapping to a file in the replayq dir. If the current segment is full, a new segment</br>(file) will be opened to write.</br>",
            "example": "32MB",
            "type": "string"
          },
          "offload": {
            "default": false,
            "description": "</br>In offload mode, the disk queue is only used to offload queue tail segments.</br>The messages are cached in the memory first, then it writes to the replayq files after the size of</br>the memory cache reaches 'seg_bytes'.</br>",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "emqx_authz_api_schema.mongo_rs": {
        "required": [
          "database",
          "replica_set_name",
          "servers",
          "mongo_type",
          "collection",
          "type"
        ],
        "properties": {
          "enable": {
            "default": true,
            "description": "Set to <code>true</code> or <code>false</code> to disable this ACL provider",
            "type": "boolean"
          },
          "type": {
            "default": "mongodb",
            "description": "Backend type.",
            "enum": [
              "mongodb"
            ],
            "type": "string"
          },
          "collection": {
            "description": "`MongoDB` collection containing the authorization data.",
            "type": "string"
          },
          "filter": {
            "default": {},
            "description": "</br>Conditional expression that defines the filter condition in the query.</br>Filter supports the following placeholders:</br> - <code>${username}</code>: Will be replaced at runtime with <code>Username</code> used by the client when connecting</br> - <code>${clientid}</code>: Will be replaced at runtime with <code>Client ID</code> used by the client when connecting</br>",
            "example": {},
            "type": "object"
          },
          "mongo_type": {
            "default": "rs",
            "description": "Replica set.",
            "enum": [
              "rs"
            ],
            "type": "string"
          },
          "servers": {
            "description": "</br>A Node list for Cluster to connect to. The nodes should be separated with commas, such as: `Node[,Node].`</br>For each Node should be: The IPv4 or IPv6 address or the hostname to connect to.</br>A host entry has the following form: `Host[:Port]`.</br>The MongoDB default port 27017 is used if `[:Port]` is not specified.</br>",
            "items": {
              "example": "any",
              "type": "string"
            },
            "type": "array"
          },
          "w_mode": {
            "default": "unsafe",
            "description": "Write mode.",
            "enum": [
              "unsafe",
              "safe"
            ],
            "type": "string"
          },
          "r_mode": {
            "default": "master",
            "description": "Read mode.",
            "enum": [
              "master",
              "slave_ok"
            ],
            "type": "string"
          },
          "replica_set_name": {
            "description": "Name of the replica set.",
            "type": "string"
          },
          "srv_record": {
            "default": false,
            "description": "Use DNS SRV record.",
            "type": "boolean"
          },
          "pool_size": {
            "default": 8,
            "description": "Size of the connection pool.",
            "minimum": 1,
            "type": "integer"
          },
          "username": {
            "description": "EMQX's username in the external database.",
            "type": "string"
          },
          "password": {
            "description": "EMQX's password in the external database.",
            "type": "string"
          },
          "auth_source": {
            "description": "Database name associated with the user's credentials.",
            "type": "string"
          },
          "database": {
            "description": "Database name.",
            "type": "string"
          },
          "topology": {
            "$ref": "#/components/schemas/emqx_connector_mongo.topology"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/broker.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "gateway.exproto_grpc_handler": {
        "required": [
          "address"
        ],
        "properties": {
          "address": {
            "description": "gRPC server address.",
            "type": "string"
          },
          "ssl_options": {
            "description": "SSL configuration for the gRPC client.",
            "$ref": "#/components/schemas/broker.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "broker.persistent_session_store": {
        "properties": {
          "enabled": {
            "default": false,
            "description": "Use the database to store information about persistent sessions.</br>This makes it possible to migrate a client connection to another</br>cluster node if a node is stopped.</br>",
            "type": "boolean"
          },
          "on_disc": {
            "default": true,
            "description": "Save information about the persistent sessions on disc.</br>If this option is enabled, persistent sessions will survive full restart of the cluster.</br>Otherwise, all the data will be stored in RAM, and it will be lost when all the nodes in the cluster are stopped.",
            "type": "boolean"
          },
          "ram_cache": {
            "default": false,
            "description": "Maintain a copy of the data in RAM for faster access.",
            "type": "boolean"
          },
          "backend": {
            "default": {
              "messages": {
                "ram_cache": "false"
              },
              "session": {
                "ram_cache": "true"
              },
              "session_messages": {
                "ram_cache": "true"
              },
              "type": "builtin"
            },
            "description": "Database management system used to store information about persistent sessions and messages.</br>- `builtin`: Use the embedded database (mria)",
            "oneOf": [
              {
                "$ref": "#/components/schemas/broker.persistent_session_builtin"
              }
            ]
          },
          "max_retain_undelivered": {
            "default": "1h",
            "description": "The time messages that was not delivered to a persistent session</br>is stored before being garbage collected if the node the previous</br>session was handled on restarts of is stopped.</br>",
            "example": "12m",
            "type": "string"
          },
          "message_gc_interval": {
            "default": "1h",
            "description": "The starting interval for garbage collection of undelivered messages to</br>a persistent session. This affects how often the \"max_retain_undelivered\"</br>is checked for removal.</br>",
            "example": "12m",
            "type": "string"
          },
          "session_message_gc_interval": {
            "default": "1m",
            "description": "The starting interval for garbage collection of transient data for</br>persistent session messages. This does not affect the lifetime length</br>of persistent session messages.</br>",
            "example": "12m",
            "type": "string"
          }
        },
        "type": "object"
      },
      "authn-http.get": {
        "required": [
          "url",
          "backend",
          "mechanism",
          "method"
        ],
        "properties": {
          "method": {
            "default": "get",
            "description": "HTTP request method.",
            "enum": [
              "get"
            ],
            "type": "string"
          },
          "headers": {
            "default": {
              "accept": "application/json",
              "cache-control": "no-cache",
              "connection": "keep-alive",
              "keep-alive": "timeout=30, max=1000"
            },
            "description": "List of HTTP headers (without <code>content-type</code>).",
            "example": {},
            "type": "object"
          },
          "mechanism": {
            "description": "Authentication mechanism.",
            "enum": [
              "password_based"
            ],
            "type": "string"
          },
          "backend": {
            "description": "Backend type.",
            "enum": [
              "http"
            ],
            "type": "string"
          },
          "url": {
            "description": "URL of the HTTP server.",
            "type": "string"
          },
          "body": {
            "description": "HTTP request body.",
            "example": {},
            "type": "object"
          },
          "request_timeout": {
            "default": "5s",
            "description": "HTTP request timeout.",
            "example": "32s",
            "type": "string"
          },
          "enable": {
            "default": true,
            "description": "Set to <code>true</code> or <code>false</code> to disable this auth provider.",
            "type": "boolean"
          },
          "connect_timeout": {
            "default": "15s",
            "description": "The timeout when connecting to the HTTP server.",
            "example": "32s",
            "type": "string"
          },
          "enable_pipelining": {
            "default": 100,
            "description": "Whether to send HTTP requests continuously, when set to 0, it means that after each HTTP request is sent, you need to wait for the server to return and then continue to send the next request.",
            "minimum": 1,
            "type": "integer"
          },
          "max_retries": {
            "default": 5,
            "description": "Max retry times if error on sending request.",
            "minimum": 0,
            "type": "integer"
          },
          "pool_size": {
            "default": 8,
            "description": "The pool size.",
            "minimum": 1,
            "type": "integer"
          },
          "request": {
            "description": "</br>If the request is provided, the caller can send HTTP requests via</br><code>emqx_resource:query(ResourceId, {send_message, BridgeId, Message})</code></br>",
            "$ref": "#/components/schemas/connector-http.request"
          },
          "retry_interval": {
            "default": "1s",
            "description": "Interval between retries.",
            "example": "12m",
            "type": "string"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/broker.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "broker.broker": {
        "properties": {
          "enable_session_registry": {
            "default": true,
            "description": "Enable session registry",
            "type": "boolean"
          },
          "session_locking_strategy": {
            "default": "quorum",
            "description": "Session locking strategy in a cluster.</br>  - `local`: only lock the session on the current node</br>  - `one`: select only one remote node to lock the session</br>  - `quorum`: select some nodes to lock the session</br>  - `all`: lock the session on all the nodes in the cluster</br>",
            "enum": [
              "local",
              "leader",
              "quorum",
              "all"
            ],
            "type": "string"
          },
          "shared_subscription_strategy": {
            "default": "round_robin",
            "description": "Dispatch strategy for shared subscription.</br>  - `random`: dispatch the message to a random selected subscriber</br>  - `round_robin`: select the subscribers in a round-robin manner</br>  - `sticky`: always use the last selected subscriber to dispatch, until the subscriber disconnects.</br>  - `hash`: select the subscribers by the hash of `clientIds`</br>",
            "enum": [
              "random",
              "round_robin",
              "sticky",
              "local",
              "hash_topic",
              "hash_clientid"
            ],
            "type": "string"
          },
          "shared_dispatch_ack_enabled": {
            "default": false,
            "description": "Enable/disable shared dispatch acknowledgement for QoS 1 and QoS 2 messages.</br>This should allow messages to be dispatched to a different subscriber in the group in case the picked (based on `shared_subscription_strategy`) subscriber is offline.</br>",
            "type": "boolean"
          },
          "route_batch_clean": {
            "default": true,
            "description": "Enable batch clean for deleted routes.",
            "type": "boolean"
          },
          "perf": {
            "$ref": "#/components/schemas/broker.broker_perf"
          },
          "shared_subscription_group": {
            "description": "Per group dispatch strategy for shared subscription.</br>This config is a map from shared subscription group name to the strategy</br>name. The group name should be of format `[A-Za-z0-9]`. i.e. no</br>special characters are allowed.</br>",
            "example": {
              "example_group": {
                "strategy": "random"
              }
            },
            "properties": {
              "$name": {
                "$ref": "#/components/schemas/broker.shared_subscription_group"
              }
            },
            "type": "object"
          }
        },
        "type": "object"
      },
      "emqx_connector_mqtt.put": {
        "required": [
          "server"
        ],
        "properties": {
          "mode": {
            "default": "cluster_shareload",
            "description": "</br>The mode of the MQTT Bridge.</br></br>- cluster_shareload: create an MQTT connection on each node in the emqx cluster.</br>In 'cluster_shareload' mode, the incoming load from the remote broker is shared by</br>using shared subscription.</br>Note that the 'clientid' is suffixed by the node name, this is to avoid</br>clientid conflicts between different nodes. And we can only use shared subscription</br>topic filters for 'remote_topic' of ingress connections.</br>",
            "enum": [
              "cluster_shareload"
            ],
            "type": "string"
          },
          "server": {
            "description": "The host and port of the remote MQTT broker",
            "example": "127.0.0.1:80",
            "type": "string"
          },
          "reconnect_interval": {
            "default": "15s",
            "description": "Reconnect interval. Delay for the MQTT bridge to retry establishing the connection in case of transportation failure. Time interval is a string that contains a number followed by time unit:</br>- `ms` for milliseconds,</br>- `s` for seconds,</br>- `m` for minutes,</br>- `h` for hours;</br></br>or combination of whereof: `1h5m0s`",
            "type": "string"
          },
          "proto_ver": {
            "default": "v4",
            "description": "The MQTT protocol version",
            "enum": [
              "v3",
              "v4",
              "v5"
            ],
            "type": "string"
          },
          "bridge_mode": {
            "default": false,
            "description": "</br>If enable bridge mode.</br>NOTE: This setting is only for MQTT protocol version older than 5.0, and the remote MQTT</br>broker MUST support this feature.</br>    ",
            "type": "boolean"
          },
          "username": {
            "default": "emqx",
            "description": "The username of the MQTT protocol",
            "type": "string"
          },
          "password": {
            "default": "emqx",
            "description": "The password of the MQTT protocol",
            "type": "string"
          },
          "clean_start": {
            "default": true,
            "description": "The clean-start or the clean-session of the MQTT protocol",
            "type": "boolean"
          },
          "keepalive": {
            "default": "300s",
            "description": "MQTT Keepalive. Time interval is a string that contains a number followed by time unit:</br>- `ms` for milliseconds,</br>- `s` for seconds,</br>- `m` for minutes,</br>- `h` for hours;</br></br>or combination of whereof: `1h5m0s`",
            "type": "string"
          },
          "retry_interval": {
            "default": "15s",
            "description": "Message retry interval. Delay for the MQTT bridge to retry sending the QoS1/QoS2 messages in case of ACK not received. Time interval is a string that contains a number followed by time unit:</br>- `ms` for milliseconds,</br>- `s` for seconds,</br>- `m` for minutes,</br>- `h` for hours;</br></br>or combination of whereof: `1h5m0s`",
            "type": "string"
          },
          "max_inflight": {
            "default": 32,
            "description": "Max inflight (sent, but un-acked) messages of the MQTT protocol",
            "minimum": 0,
            "type": "integer"
          },
          "replayq": {
            "$ref": "#/components/schemas/connector-mqtt.replayq"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/broker.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "authn-postgresql.authentication": {
        "required": [
          "database",
          "server",
          "query",
          "backend",
          "mechanism"
        ],
        "properties": {
          "mechanism": {
            "description": "Authentication mechanism.",
            "enum": [
              "password_based"
            ],
            "type": "string"
          },
          "backend": {
            "description": "Backend type.",
            "enum": [
              "postgresql"
            ],
            "type": "string"
          },
          "password_hash_algorithm": {
            "default": {
              "name": "sha256",
              "salt_position": "prefix"
            },
            "description": "Options for password hash verification.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/authn-hash.other_algorithms"
              },
              {
                "$ref": "#/components/schemas/authn-hash.pbkdf2"
              },
              {
                "$ref": "#/components/schemas/authn-hash.bcrypt"
              }
            ]
          },
          "query": {
            "description": "SQL used to query data for authentication, such as password hash.",
            "type": "string"
          },
          "enable": {
            "default": true,
            "description": "Set to <code>true</code> or <code>false</code> to disable this auth provider.",
            "type": "boolean"
          },
          "server": {
            "description": "</br>The IPv4 or IPv6 address or the hostname to connect to.</br>A host entry has the following form: `Host[:Port]`.</br>The PostgreSQL default port 5432 is used if `[:Port]` is not specified.</br>",
            "example": "127.0.0.1:80",
            "type": "string"
          },
          "database": {
            "description": "Database name.",
            "type": "string"
          },
          "pool_size": {
            "default": 8,
            "description": "Size of the connection pool.",
            "minimum": 1,
            "type": "integer"
          },
          "username": {
            "description": "EMQX's username in the external database.",
            "type": "string"
          },
          "password": {
            "description": "EMQX's password in the external database.",
            "type": "string"
          },
          "auto_reconnect": {
            "default": true,
            "description": "Enable automatic reconnect to the database.",
            "type": "boolean"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/broker.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "emqx_authn_schema.resource_metrics": {
        "properties": {
          "matched": {
            "description": "Count of this resource is queried.",
            "type": "integer"
          },
          "success": {
            "description": "Count of query success.",
            "type": "integer"
          },
          "failed": {
            "description": "Count of query failed.",
            "type": "integer"
          },
          "rate": {
            "description": "The rate of matched, times/second.",
            "type": "number"
          },
          "rate_max": {
            "description": "The max rate of matched, times/second.",
            "type": "number"
          },
          "rate_last5m": {
            "description": "The average rate of matched in the last 5 minutes, times/second.",
            "type": "number"
          }
        },
        "type": "object"
      },
      "exhook.list_hook_info": {
        "properties": {
          "name": {
            "description": "The hook's name",
            "type": "string"
          },
          "params": {
            "description": "The parameters used when the hook is registered",
            "properties": {
              "$name": {
                "type": "string"
              }
            },
            "type": "object"
          },
          "metrics": {
            "description": "Metrics information of this hook in the current node",
            "$ref": "#/components/schemas/exhook.metrics"
          },
          "node_metrics": {
            "description": "Metrics information of this hook in all nodes",
            "items": {
              "$ref": "#/components/schemas/exhook.node_metrics"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "emqx_gateway_api_listeners.udp_listener": {
        "properties": {
          "id": {
            "description": "Listener ID",
            "type": "string"
          },
          "type": {
            "description": "Listener Type",
            "enum": [
              "udp"
            ],
            "type": "string"
          },
          "name": {
            "description": "Listener Name",
            "type": "string"
          },
          "running": {
            "description": "Listener Running status",
            "type": "boolean"
          },
          "udp_options": {
            "$ref": "#/components/schemas/gateway.udp_opts"
          },
          "enable": {
            "default": true,
            "description": "Enable the listener.",
            "type": "boolean"
          },
          "bind": {
            "description": "The IP address and port that the listener will bind.",
            "oneOf": [
              {
                "type": "integer"
              },
              {
                "example": "127.0.0.1:80",
                "type": "string"
              }
            ]
          },
          "max_connections": {
            "default": 1024,
            "description": "Maximum number of concurrent connections.",
            "type": "integer"
          },
          "max_conn_rate": {
            "default": 1000,
            "description": "Maximum connections per second.",
            "type": "integer"
          },
          "authentication": {
            "description": "Default authentication configs for all the gateway listeners. For per-listener overrides see <code>authentication</code></br> in listener configs",
            "oneOf": [
              {
                "$ref": "#/components/schemas/authn-scram-builtin_db.authentication"
              },
              {
                "$ref": "#/components/schemas/authn-jwt.jwks"
              },
              {
                "$ref": "#/components/schemas/authn-jwt.public-key"
              },
              {
                "$ref": "#/components/schemas/authn-jwt.hmac-based"
              },
              {
                "$ref": "#/components/schemas/authn-http.post"
              },
              {
                "$ref": "#/components/schemas/authn-http.get"
              },
              {
                "$ref": "#/components/schemas/authn-redis.sentinel"
              },
              {
                "$ref": "#/components/schemas/authn-redis.cluster"
              },
              {
                "$ref": "#/components/schemas/authn-redis.standalone"
              },
              {
                "$ref": "#/components/schemas/authn-mongodb.sharded-cluster"
              },
              {
                "$ref": "#/components/schemas/authn-mongodb.replica-set"
              },
              {
                "$ref": "#/components/schemas/authn-mongodb.standalone"
              },
              {
                "$ref": "#/components/schemas/authn-postgresql.authentication"
              },
              {
                "$ref": "#/components/schemas/authn-mysql.authentication"
              },
              {
                "$ref": "#/components/schemas/authn-builtin_db.authentication"
              }
            ]
          },
          "enable_authn": {
            "default": true,
            "description": "Set <code>true</code> (default) to enable client authentication on this listener. </br>When set to <code>false</code> clients will be allowed to connect without authentication.",
            "type": "boolean"
          },
          "mountpoint": {
            "description": "When publishing or subscribing, prefix all topics with a mountpoint string.</br>The prefixed string will be removed from the topic name when the message is delivered to the subscriber. The mountpoint is a way that users can use to implement isolation of message routing between different listeners.</br>For example if a client A subscribes to `t` with `listeners.tcp.\\<name>.mountpoint` set to `some_tenant`, then the client actually subscribes to the topic `some_tenant/t`. Similarly, if another client B (connected to the same listener as the client A) sends a message to topic `t`, the message is routed to all the clients subscribed `some_tenant/t`, so client A will receive the message, with topic name `t`. Set to `\"\"` to disable the feature.</br>Variables in mountpoint string:</br>  - <code>${clientid}</code>: clientid</br>  - <code>${username}</code>: username</br>",
            "type": "string"
          },
          "access_rules": {
            "default": "",
            "description": "The access control rules for this listener.</br>See: https://github.com/emqtt/esockd#allowdeny",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "current_connections": {
            "description": "Current Connections",
            "minimum": 0,
            "type": "integer"
          },
          "node_status": {
            "description": "listener status of each node in the cluster",
            "items": {
              "$ref": "#/components/schemas/listeners.node_status"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "emqx_authz_api_mnesia.rule_item": {
        "required": [
          "action",
          "permission",
          "topic"
        ],
        "properties": {
          "topic": {
            "description": "Rule on specific topic",
            "example": "test/topic/1",
            "type": "string"
          },
          "permission": {
            "description": "Permission",
            "enum": [
              "allow",
              "deny"
            ],
            "example": "allow",
            "type": "string"
          },
          "action": {
            "description": "Authorized action (pub/sub/all)",
            "enum": [
              "publish",
              "subscribe",
              "all"
            ],
            "example": "publish",
            "type": "string"
          }
        },
        "type": "object"
      },
      "authn-jwt.jwks": {
        "required": [
          "mechanism",
          "endpoint",
          "use_jwks"
        ],
        "properties": {
          "use_jwks": {
            "description": "Whether to use JWKS.",
            "enum": [
              true
            ],
            "type": "string"
          },
          "endpoint": {
            "description": "JWKS endpoint, it's a read-only endpoint that returns the server's public key set in the JWKS format.",
            "type": "string"
          },
          "pool_size": {
            "default": 8,
            "description": "Size of the connection pool.",
            "minimum": 1,
            "type": "integer"
          },
          "refresh_interval": {
            "default": 300,
            "description": "JWKS refresh interval.",
            "type": "integer"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL options.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/authn-jwt.ssl_disable"
              },
              {
                "$ref": "#/components/schemas/authn-jwt.ssl_enable"
              }
            ]
          },
          "mechanism": {
            "description": "Authentication mechanism.",
            "enum": [
              "jwt"
            ],
            "type": "string"
          },
          "acl_claim_name": {
            "default": "acl",
            "description": "JWT claim name to use for getting ACL rules.",
            "type": "string"
          },
          "verify_claims": {
            "default": {},
            "description": "</br>A list of custom claims to validate, which is a list of name/value pairs.</br>Values can use the following placeholders:</br>- <code>${username}</code>: Will be replaced at runtime with <code>Username</code> used by the client when connecting</br>- <code>${clientid}</code>: Will be replaced at runtime with <code>Client ID</code> used by the client when connecting</br>Authentication will verify that the value of claims in the JWT (taken from the Password field) matches what is required in <code>verify_claims</code>.</br>",
            "items": {
              "example": "any",
              "type": "string"
            },
            "type": "array"
          },
          "from": {
            "default": "password",
            "description": "Field to take JWT from.",
            "enum": [
              "username",
              "password"
            ],
            "type": "string"
          },
          "enable": {
            "default": true,
            "description": "Set to <code>true</code> or <code>false</code> to disable this auth provider.",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "trace.trace": {
        "required": [
          "type",
          "name"
        ],
        "properties": {
          "name": {
            "description": "Unique and format by [a-zA-Z0-9-_]",
            "example": "EMQX-TRACE-1",
            "type": "string"
          },
          "type": {
            "description": "Filter type",
            "enum": [
              "clientid",
              "topic",
              "ip_address"
            ],
            "example": "clientid",
            "type": "string"
          },
          "topic": {
            "description": "support mqtt wildcard topic.",
            "example": "/dev/#",
            "type": "string"
          },
          "clientid": {
            "description": "mqtt clientid.",
            "example": "dev-001",
            "type": "string"
          },
          "ip_address": {
            "description": "client ip address",
            "example": "127.0.0.1",
            "type": "string"
          },
          "status": {
            "description": "trace status",
            "enum": [
              "running",
              "stopped",
              "waiting"
            ],
            "example": "running",
            "type": "string"
          },
          "start_at": {
            "description": "rfc3339 timestamp or epoch second",
            "example": "2021-11-04T18:17:38+08:00",
            "oneOf": [
              {
                "description": "epoch-second",
                "example": 1640995200,
                "type": "integer"
              },
              {
                "example": "2022-01-01T00:00:00.000Z",
                "format": "date-time",
                "type": "string"
              }
            ]
          },
          "end_at": {
            "description": "rfc3339 timestamp or epoch second",
            "example": "2021-11-05T18:17:38+08:00",
            "oneOf": [
              {
                "description": "epoch-second",
                "example": 1640995200,
                "type": "integer"
              },
              {
                "example": "2022-01-01T00:00:00.000Z",
                "format": "date-time",
                "type": "string"
              }
            ]
          },
          "log_size": {
            "description": "trace log size",
            "example": [
              {
                "node": "emqx@127.0.0.1",
                "size": 1024
              }
            ],
            "items": {
              "example": {},
              "type": "object"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "gateway.udp_opts": {
        "properties": {
          "active_n": {
            "default": 100,
            "description": "Specify the {active, N} option for the socket.</br>See: https://erlang.org/doc/man/inet.html#setopts-2",
            "type": "integer"
          },
          "recbuf": {
            "description": "Size of the kernel-space receive buffer for the socket.",
            "example": "32MB",
            "type": "string"
          },
          "sndbuf": {
            "description": "Size of the kernel-space send buffer for the socket.",
            "example": "32MB",
            "type": "string"
          },
          "buffer": {
            "description": "Size of the user-space buffer for the socket.",
            "example": "32MB",
            "type": "string"
          },
          "reuseaddr": {
            "default": true,
            "description": "Allow local reuse of port numbers.",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "emqx_gateway_api.coap": {
        "properties": {
          "name": {
            "description": "Gateway Name",
            "enum": [
              "coap"
            ],
            "type": "string"
          },
          "heartbeat": {
            "default": "30s",
            "description": "The gateway server required minimum heartbeat interval.</br>When connection mode is enabled, this parameter is used to set the minimum heartbeat interval for the connection to be alive",
            "example": "12m",
            "type": "string"
          },
          "connection_required": {
            "default": false,
            "description": "Enable or disable connection mode.</br>Connection mode is a feature of non-standard protocols. When connection mode is enabled, it is necessary to maintain the creation, authentication and alive of connection resources",
            "type": "boolean"
          },
          "notify_type": {
            "default": "qos",
            "description": "The Notification Message will be delivered to the CoAP client if a new message received on an observed topic.</br>The type of delivered coap message can be set to:</br>  - non: Non-confirmable;</br>  - con: Confirmable;</br>  - qos: Mapping from QoS type of received message, QoS0 -> non, QoS1,2 -> con</br>",
            "enum": [
              "non",
              "con",
              "qos"
            ],
            "type": "string"
          },
          "subscribe_qos": {
            "default": "coap",
            "description": "The Default QoS Level indicator for subscribe request.</br>This option specifies the QoS level for the CoAP Client when establishing a subscription membership, if the subscribe request is not carried `qos` option. The indicator can be set to:</br>  - qos0, qos1, qos2: Fixed default QoS level</br>  - coap: Dynamic QoS level by the message type of subscribe request</br>    * qos0: If the subscribe request is non-confirmable</br>    * qos1: If the subscribe request is confirmable</br>",
            "enum": [
              "qos0",
              "qos1",
              "qos2",
              "coap"
            ],
            "type": "string"
          },
          "publish_qos": {
            "default": "coap",
            "description": "The Default QoS Level indicator for publish request.</br>This option specifies the QoS level for the CoAP Client when publishing a message to EMQX PUB/SUB system, if the publish request is not carried `qos` option. The indicator can be set to:</br>  - qos0, qos1, qos2: Fixed default QoS level</br>  - coap: Dynamic QoS level by the message type of publish request</br>    * qos0: If the publish request is non-confirmable</br>    * qos1: If the publish request is confirmable",
            "enum": [
              "qos0",
              "qos1",
              "qos2",
              "coap"
            ],
            "type": "string"
          },
          "mountpoint": {
            "default": "",
            "description": " ",
            "type": "string"
          },
          "enable": {
            "default": true,
            "description": "Whether to enable this gateway",
            "type": "boolean"
          },
          "enable_stats": {
            "default": true,
            "description": "Whether to enable client process statistic",
            "type": "boolean"
          },
          "idle_timeout": {
            "default": "30s",
            "description": "The idle time of the client connection process. It has two purposes:</br>  1. A newly created client process that does not receive any client requests after that time will be closed directly.</br>  2. A running client process that does not receive any client requests after this time will go into hibernation to save resources.",
            "example": "12m",
            "type": "string"
          },
          "clientinfo_override": {
            "description": "ClientInfo override.",
            "$ref": "#/components/schemas/gateway.clientinfo_override"
          },
          "authentication": {
            "description": "Default authentication configs for all the gateway listeners. For per-listener overrides see <code>authentication</code></br> in listener configs",
            "oneOf": [
              {
                "$ref": "#/components/schemas/authn-scram-builtin_db.authentication"
              },
              {
                "$ref": "#/components/schemas/authn-jwt.jwks"
              },
              {
                "$ref": "#/components/schemas/authn-jwt.public-key"
              },
              {
                "$ref": "#/components/schemas/authn-jwt.hmac-based"
              },
              {
                "$ref": "#/components/schemas/authn-http.post"
              },
              {
                "$ref": "#/components/schemas/authn-http.get"
              },
              {
                "$ref": "#/components/schemas/authn-redis.sentinel"
              },
              {
                "$ref": "#/components/schemas/authn-redis.cluster"
              },
              {
                "$ref": "#/components/schemas/authn-redis.standalone"
              },
              {
                "$ref": "#/components/schemas/authn-mongodb.sharded-cluster"
              },
              {
                "$ref": "#/components/schemas/authn-mongodb.replica-set"
              },
              {
                "$ref": "#/components/schemas/authn-mongodb.standalone"
              },
              {
                "$ref": "#/components/schemas/authn-postgresql.authentication"
              },
              {
                "$ref": "#/components/schemas/authn-mysql.authentication"
              },
              {
                "$ref": "#/components/schemas/authn-builtin_db.authentication"
              }
            ]
          },
          "listeners": {
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/emqx_gateway_api.dtls_listener"
                },
                {
                  "$ref": "#/components/schemas/emqx_gateway_api.udp_listener"
                }
              ]
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "emqx_authn_schema.node_error": {
        "properties": {
          "node": {
            "description": "Node name.",
            "example": "emqx@127.0.0.1",
            "type": "string"
          },
          "error": {
            "description": "The error of node.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "authn-mongodb.standalone": {
        "required": [
          "database",
          "server",
          "mongo_type",
          "collection",
          "backend",
          "mechanism"
        ],
        "properties": {
          "mechanism": {
            "description": "Authentication mechanism.",
            "enum": [
              "password_based"
            ],
            "type": "string"
          },
          "backend": {
            "description": "Backend type.",
            "enum": [
              "mongodb"
            ],
            "type": "string"
          },
          "collection": {
            "description": "Collection used to store authentication data.",
            "type": "string"
          },
          "filter": {
            "default": {},
            "description": "</br>Conditional expression that defines the filter condition in the query.</br>Filter supports the following placeholders:</br>- <code>${username}</code>: Will be replaced at runtime with <code>Username</code> used by the client when connecting</br>- <code>${clientid}</code>: Will be replaced at runtime with <code>Client ID</code> used by the client when connecting</br>",
            "example": {},
            "type": "object"
          },
          "password_hash_field": {
            "default": "password_hash",
            "description": "Document field that contains password hash.",
            "type": "string"
          },
          "salt_field": {
            "default": "salt",
            "description": "Document field that contains the password salt.",
            "type": "string"
          },
          "is_superuser_field": {
            "default": "is_superuser",
            "description": "Document field that defines if the user has superuser privileges.",
            "type": "string"
          },
          "password_hash_algorithm": {
            "default": {
              "name": "sha256",
              "salt_position": "prefix"
            },
            "description": "Options for password hash verification.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/authn-hash.other_algorithms"
              },
              {
                "$ref": "#/components/schemas/authn-hash.pbkdf2"
              },
              {
                "$ref": "#/components/schemas/authn-hash.bcrypt"
              }
            ]
          },
          "enable": {
            "default": true,
            "description": "Set to <code>true</code> or <code>false</code> to disable this auth provider.",
            "type": "boolean"
          },
          "mongo_type": {
            "default": "single",
            "description": "Standalone instance.",
            "enum": [
              "single"
            ],
            "type": "string"
          },
          "server": {
            "description": "</br>The IPv4 or IPv6 address or the hostname to connect to.</br>A host entry has the following form: `Host[:Port]`.</br>The MongoDB default port 27017 is used if `[:Port]` is not specified.</br>",
            "example": "127.0.0.1:80",
            "type": "string"
          },
          "w_mode": {
            "default": "unsafe",
            "description": "Write mode.",
            "enum": [
              "unsafe",
              "safe"
            ],
            "type": "string"
          },
          "srv_record": {
            "default": false,
            "description": "Use DNS SRV record.",
            "type": "boolean"
          },
          "pool_size": {
            "default": 8,
            "description": "Size of the connection pool.",
            "minimum": 1,
            "type": "integer"
          },
          "username": {
            "description": "EMQX's username in the external database.",
            "type": "string"
          },
          "password": {
            "description": "EMQX's password in the external database.",
            "type": "string"
          },
          "auth_source": {
            "description": "Database name associated with the user's credentials.",
            "type": "string"
          },
          "database": {
            "description": "Database name.",
            "type": "string"
          },
          "topology": {
            "$ref": "#/components/schemas/emqx_connector_mongo.topology"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/broker.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "emqx_gateway_api_listeners.dtls_listener": {
        "properties": {
          "id": {
            "description": "Listener ID",
            "type": "string"
          },
          "type": {
            "description": "Listener Type",
            "enum": [
              "dtls"
            ],
            "type": "string"
          },
          "name": {
            "description": "Listener Name",
            "type": "string"
          },
          "running": {
            "description": "Listener Running status",
            "type": "boolean"
          },
          "acceptors": {
            "default": 16,
            "description": "Size of the acceptor pool.",
            "type": "integer"
          },
          "udp_options": {
            "$ref": "#/components/schemas/gateway.udp_opts"
          },
          "enable": {
            "default": true,
            "description": "Enable the listener.",
            "type": "boolean"
          },
          "bind": {
            "description": "The IP address and port that the listener will bind.",
            "oneOf": [
              {
                "type": "integer"
              },
              {
                "example": "127.0.0.1:80",
                "type": "string"
              }
            ]
          },
          "max_connections": {
            "default": 1024,
            "description": "Maximum number of concurrent connections.",
            "type": "integer"
          },
          "max_conn_rate": {
            "default": 1000,
            "description": "Maximum connections per second.",
            "type": "integer"
          },
          "authentication": {
            "description": "Default authentication configs for all the gateway listeners. For per-listener overrides see <code>authentication</code></br> in listener configs",
            "oneOf": [
              {
                "$ref": "#/components/schemas/authn-scram-builtin_db.authentication"
              },
              {
                "$ref": "#/components/schemas/authn-jwt.jwks"
              },
              {
                "$ref": "#/components/schemas/authn-jwt.public-key"
              },
              {
                "$ref": "#/components/schemas/authn-jwt.hmac-based"
              },
              {
                "$ref": "#/components/schemas/authn-http.post"
              },
              {
                "$ref": "#/components/schemas/authn-http.get"
              },
              {
                "$ref": "#/components/schemas/authn-redis.sentinel"
              },
              {
                "$ref": "#/components/schemas/authn-redis.cluster"
              },
              {
                "$ref": "#/components/schemas/authn-redis.standalone"
              },
              {
                "$ref": "#/components/schemas/authn-mongodb.sharded-cluster"
              },
              {
                "$ref": "#/components/schemas/authn-mongodb.replica-set"
              },
              {
                "$ref": "#/components/schemas/authn-mongodb.standalone"
              },
              {
                "$ref": "#/components/schemas/authn-postgresql.authentication"
              },
              {
                "$ref": "#/components/schemas/authn-mysql.authentication"
              },
              {
                "$ref": "#/components/schemas/authn-builtin_db.authentication"
              }
            ]
          },
          "enable_authn": {
            "default": true,
            "description": "Set <code>true</code> (default) to enable client authentication on this listener. </br>When set to <code>false</code> clients will be allowed to connect without authentication.",
            "type": "boolean"
          },
          "mountpoint": {
            "description": "When publishing or subscribing, prefix all topics with a mountpoint string.</br>The prefixed string will be removed from the topic name when the message is delivered to the subscriber. The mountpoint is a way that users can use to implement isolation of message routing between different listeners.</br>For example if a client A subscribes to `t` with `listeners.tcp.\\<name>.mountpoint` set to `some_tenant`, then the client actually subscribes to the topic `some_tenant/t`. Similarly, if another client B (connected to the same listener as the client A) sends a message to topic `t`, the message is routed to all the clients subscribed `some_tenant/t`, so client A will receive the message, with topic name `t`. Set to `\"\"` to disable the feature.</br>Variables in mountpoint string:</br>  - <code>${clientid}</code>: clientid</br>  - <code>${username}</code>: username</br>",
            "type": "string"
          },
          "access_rules": {
            "default": "",
            "description": "The access control rules for this listener.</br>See: https://github.com/emqtt/esockd#allowdeny",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "dtls_options": {
            "description": "DTLS socket options",
            "$ref": "#/components/schemas/gateway.dtls_opts"
          },
          "current_connections": {
            "description": "Current Connections",
            "minimum": 0,
            "type": "integer"
          },
          "node_status": {
            "description": "listener status of each node in the cluster",
            "items": {
              "$ref": "#/components/schemas/listeners.node_status"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "emqx_rule_api_schema.ctx_connack": {
        "required": [
          "event_type"
        ],
        "properties": {
          "event_type": {
            "description": "Event Type",
            "enum": [
              "client_connack"
            ],
            "type": "string"
          },
          "reason_code": {
            "description": "The reason code",
            "type": "string"
          },
          "clientid": {
            "description": "The Client ID",
            "type": "string"
          },
          "clean_start": {
            "default": true,
            "description": "Clean Start",
            "type": "boolean"
          },
          "username": {
            "description": "The User Name",
            "type": "string"
          },
          "peername": {
            "description": "The IP Address and Port of the Peer Client",
            "type": "string"
          },
          "sockname": {
            "description": "The IP Address and Port of the Local Listener",
            "type": "string"
          },
          "proto_name": {
            "description": "Protocol Name",
            "type": "string"
          },
          "proto_ver": {
            "description": "Protocol Version",
            "type": "string"
          },
          "keepalive": {
            "description": "KeepAlive",
            "type": "integer"
          },
          "expiry_interval": {
            "description": "Expiry Interval",
            "type": "integer"
          },
          "connected_at": {
            "description": "The Time that this Client is Connected",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "emqx_authz_api_schema.redis_single": {
        "required": [
          "database",
          "redis_type",
          "server",
          "cmd",
          "type"
        ],
        "properties": {
          "enable": {
            "default": true,
            "description": "Set to <code>true</code> or <code>false</code> to disable this ACL provider",
            "type": "boolean"
          },
          "type": {
            "default": "redis",
            "description": "Backend type.",
            "enum": [
              "redis"
            ],
            "type": "string"
          },
          "cmd": {
            "description": "Database query used to retrieve authorization data.",
            "example": "HGETALL mqtt_authz",
            "type": "string"
          },
          "server": {
            "description": "</br>The IPv4 or IPv6 address or the hostname to connect to.</br>A host entry has the following form: `Host[:Port]`.</br>The Redis default port 6379 is used if `[:Port]` is not specified.</br>",
            "example": "127.0.0.1:80",
            "type": "string"
          },
          "redis_type": {
            "description": "Single mode",
            "enum": [
              "single"
            ],
            "type": "string"
          },
          "pool_size": {
            "default": 8,
            "description": "Size of the connection pool.",
            "minimum": 1,
            "type": "integer"
          },
          "password": {
            "description": "EMQX's password in the external database.",
            "type": "string"
          },
          "database": {
            "default": 0,
            "description": "Redis database ID.",
            "type": "integer"
          },
          "auto_reconnect": {
            "default": true,
            "description": "Enable automatic reconnect to the database.",
            "type": "boolean"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/broker.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "prometheus.prometheus": {
        "required": [
          "enable",
          "interval",
          "push_gateway_server"
        ],
        "properties": {
          "push_gateway_server": {
            "default": "http://127.0.0.1:9091",
            "description": "URL of Prometheus server",
            "type": "string"
          },
          "interval": {
            "default": "15s",
            "description": "Data reporting interval, in milliseconds.",
            "example": "32s",
            "type": "string"
          },
          "enable": {
            "default": false,
            "description": "Turn Prometheus data pushing on or off",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "authz.metrics": {
        "properties": {
          "total": {
            "description": "The total number of times the authorization rule was triggered.",
            "type": "integer"
          },
          "allow": {
            "description": "The number of times the authentication was successful.",
            "type": "integer"
          },
          "deny": {
            "description": "The number of authentication failures.",
            "type": "integer"
          },
          "nomatch": {
            "description": "The number of times that no authorization rules were matched.",
            "type": "number"
          },
          "rate": {
            "description": "The rate of matched, times/second.",
            "type": "number"
          },
          "rate_max": {
            "description": "The max rate of matched, times/second.",
            "type": "number"
          },
          "rate_last5m": {
            "description": "The average rate of matched in the last 5 minutes, times/second.",
            "type": "number"
          }
        },
        "type": "object"
      },
      "emqx_gateway_api.mqttsn": {
        "required": [
          "gateway_id"
        ],
        "properties": {
          "name": {
            "description": "Gateway Name",
            "enum": [
              "mqttsn"
            ],
            "type": "string"
          },
          "gateway_id": {
            "default": 1,
            "description": "MQTT-SN Gateway ID.</br>When the <code>broadcast</code> option is enabled, the gateway will broadcast ADVERTISE message with this value",
            "type": "integer"
          },
          "broadcast": {
            "default": false,
            "description": "Whether to periodically broadcast ADVERTISE messages",
            "type": "boolean"
          },
          "enable_qos3": {
            "default": true,
            "description": "Allows connectionless clients to publish messages with a Qos of -1.</br>This feature is defined for very simple client implementations which do not support any other features except this one. There is no connection setup nor tear down, no registration nor subscription. The client just sends its 'PUBLISH' messages to a GW",
            "type": "boolean"
          },
          "subs_resume": {
            "default": false,
            "description": "Whether to initiate all subscribed topic name registration messages to the client after the Session has been taken over by a new channel",
            "type": "boolean"
          },
          "predefined": {
            "default": "",
            "description": "The pre-defined topic IDs and topic names.</br>A 'pre-defined' topic ID is a topic ID whose mapping to a topic name is known in advance by both the client's application and the gateway",
            "items": {
              "$ref": "#/components/schemas/gateway.mqttsn_predefined"
            },
            "type": "array"
          },
          "mountpoint": {
            "default": "",
            "description": " ",
            "type": "string"
          },
          "enable": {
            "default": true,
            "description": "Whether to enable this gateway",
            "type": "boolean"
          },
          "enable_stats": {
            "default": true,
            "description": "Whether to enable client process statistic",
            "type": "boolean"
          },
          "idle_timeout": {
            "default": "30s",
            "description": "The idle time of the client connection process. It has two purposes:</br>  1. A newly created client process that does not receive any client requests after that time will be closed directly.</br>  2. A running client process that does not receive any client requests after this time will go into hibernation to save resources.",
            "example": "12m",
            "type": "string"
          },
          "clientinfo_override": {
            "description": "ClientInfo override.",
            "$ref": "#/components/schemas/gateway.clientinfo_override"
          },
          "authentication": {
            "description": "Default authentication configs for all the gateway listeners. For per-listener overrides see <code>authentication</code></br> in listener configs",
            "oneOf": [
              {
                "$ref": "#/components/schemas/authn-scram-builtin_db.authentication"
              },
              {
                "$ref": "#/components/schemas/authn-jwt.jwks"
              },
              {
                "$ref": "#/components/schemas/authn-jwt.public-key"
              },
              {
                "$ref": "#/components/schemas/authn-jwt.hmac-based"
              },
              {
                "$ref": "#/components/schemas/authn-http.post"
              },
              {
                "$ref": "#/components/schemas/authn-http.get"
              },
              {
                "$ref": "#/components/schemas/authn-redis.sentinel"
              },
              {
                "$ref": "#/components/schemas/authn-redis.cluster"
              },
              {
                "$ref": "#/components/schemas/authn-redis.standalone"
              },
              {
                "$ref": "#/components/schemas/authn-mongodb.sharded-cluster"
              },
              {
                "$ref": "#/components/schemas/authn-mongodb.replica-set"
              },
              {
                "$ref": "#/components/schemas/authn-mongodb.standalone"
              },
              {
                "$ref": "#/components/schemas/authn-postgresql.authentication"
              },
              {
                "$ref": "#/components/schemas/authn-mysql.authentication"
              },
              {
                "$ref": "#/components/schemas/authn-builtin_db.authentication"
              }
            ]
          },
          "listeners": {
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/emqx_gateway_api.dtls_listener"
                },
                {
                  "$ref": "#/components/schemas/emqx_gateway_api.udp_listener"
                }
              ]
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "rule_engine.builtin_action_console": {
        "properties": {
          "function": {
            "description": "Print the actions to the console",
            "enum": [
              "console"
            ],
            "type": "string"
          }
        },
        "type": "object"
      },
      "authn-hash.bcrypt": {
        "required": [
          "name"
        ],
        "properties": {
          "name": {
            "description": "BCRYPT password hashing.",
            "enum": [
              "bcrypt"
            ],
            "type": "string"
          }
        },
        "type": "object"
      },
      "exhook.ssl_conf": {
        "properties": {
          "cacertfile": {
            "description": "</br>Trusted PEM format CA certificates bundle file.</br>The certificates in this file are used to verify the TLS peer's certificates.</br>Append new certificates to the file if new CAs are to be trusted.</br>There is no need to restart EMQX to have the updated file loaded, because</br>the system regularly checks if file has been updated (and reload).</br>NOTE: invalidating (deleting) a certificate from the file will not affect</br>already established connections.</br>",
            "type": "string"
          },
          "certfile": {
            "description": "</br>PEM format certificates chain file.</br>The certificates in this file should be in reversed order of the certificate</br>issue chain. That is, the host's certificate should be placed in the beginning</br>of the file, followed by the immediate issuer certificate and so on.</br>Although the root CA certificate is optional, it should be placed at the end of</br>the file if it is to be added.</br>",
            "type": "string"
          },
          "keyfile": {
            "description": "</br>PEM format private key file.</br>",
            "type": "string"
          },
          "verify": {
            "default": "verify_none",
            "description": "</br>Enable or disable peer verification.</br>",
            "enum": [
              "verify_peer",
              "verify_none"
            ],
            "type": "string"
          },
          "reuse_sessions": {
            "default": true,
            "description": "</br>Enable TLS session reuse.</br>",
            "type": "boolean"
          },
          "depth": {
            "default": 10,
            "description": "</br>Maximum number of non-self-issued intermediate certificates that can follow the peer certificate in a valid certification path. So, if depth is 0 the PEER must be signed by the trusted ROOT-CA directly; if 1 the path can be PEER, CA, ROOT-CA; if 2 the path can be PEER, CA, CA, ROOT-CA, and so on. The default value is 10.</br>",
            "type": "integer"
          },
          "password": {
            "description": "</br>String containing the user's password.</br>Only used if the private key file is password-protected.</br>",
            "example": "",
            "type": "string"
          },
          "versions": {
            "default": [
              "tlsv1.3",
              "tlsv1.2",
              "tlsv1.1",
              "tlsv1"
            ],
            "description": "</br>All TLS/DTLS versions to be supported.</br>NOTE: PSK ciphers are suppressed by 'tlsv1.3' version config.</br>In case PSK cipher suites are intended, make sure to configured</br><code>['tlsv1.2', 'tlsv1.1']</code> here.</br>",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "ciphers": {
            "default": [
              "TLS_AES_256_GCM_SHA384",
              "TLS_AES_128_GCM_SHA256",
              "TLS_CHACHA20_POLY1305_SHA256",
              "TLS_AES_128_CCM_SHA256",
              "TLS_AES_128_CCM_8_SHA256",
              "ECDHE-ECDSA-AES256-GCM-SHA384",
              "ECDHE-RSA-AES256-GCM-SHA384",
              "ECDHE-ECDSA-AES256-SHA384",
              "ECDHE-RSA-AES256-SHA384",
              "ECDH-ECDSA-AES256-GCM-SHA384",
              "ECDH-RSA-AES256-GCM-SHA384",
              "ECDH-ECDSA-AES256-SHA384",
              "ECDH-RSA-AES256-SHA384",
              "DHE-DSS-AES256-GCM-SHA384",
              "DHE-DSS-AES256-SHA256",
              "AES256-GCM-SHA384",
              "AES256-SHA256",
              "ECDHE-ECDSA-AES128-GCM-SHA256",
              "ECDHE-RSA-AES128-GCM-SHA256",
              "ECDHE-ECDSA-AES128-SHA256",
              "ECDHE-RSA-AES128-SHA256",
              "ECDH-ECDSA-AES128-GCM-SHA256",
              "ECDH-RSA-AES128-GCM-SHA256",
              "ECDH-ECDSA-AES128-SHA256",
              "ECDH-RSA-AES128-SHA256",
              "DHE-DSS-AES128-GCM-SHA256",
              "DHE-DSS-AES128-SHA256",
              "AES128-GCM-SHA256",
              "AES128-SHA256",
              "ECDHE-ECDSA-AES256-SHA",
              "ECDHE-RSA-AES256-SHA",
              "DHE-DSS-AES256-SHA",
              "ECDH-ECDSA-AES256-SHA",
              "ECDH-RSA-AES256-SHA",
              "ECDHE-ECDSA-AES128-SHA",
              "ECDHE-RSA-AES128-SHA",
              "DHE-DSS-AES128-SHA",
              "ECDH-ECDSA-AES128-SHA",
              "ECDH-RSA-AES128-SHA",
              "RSA-PSK-AES256-GCM-SHA384",
              "RSA-PSK-AES256-CBC-SHA384",
              "RSA-PSK-AES128-GCM-SHA256",
              "RSA-PSK-AES128-CBC-SHA256",
              "RSA-PSK-AES256-CBC-SHA",
              "RSA-PSK-AES128-CBC-SHA"
            ],
            "description": "</br>This config holds TLS cipher suite names separated by comma,</br>or as an array of strings. e.g.</br><code>\"TLS_AES_256_GCM_SHA384,TLS_AES_128_GCM_SHA256\"</code> or</br><code>[\"TLS_AES_256_GCM_SHA384\",\"TLS_AES_128_GCM_SHA256\"]</code>.</br></br>Ciphers (and their ordering) define the way in which the</br>client and server encrypts information over the network connection.</br>Selecting a good cipher suite is critical for the</br>application's data security, confidentiality and performance.</br></br>The names should be in OpenSSL string format (not RFC format).</br>All default values and examples provided by EMQX config</br>documentation are all in OpenSSL format.</br></br>NOTE: Certain cipher suites are only compatible with</br>specific TLS <code>versions</code> ('tlsv1.1', 'tlsv1.2' or 'tlsv1.3')</br>incompatible cipher suites will be silently dropped.</br>For instance, if only 'tlsv1.3' is given in the <code>versions</code>,</br>configuring cipher suites for other versions will have no effect.</br></br></br>NOTE: PSK ciphers are suppressed by 'tlsv1.3' version config</br>If PSK cipher suites are intended, 'tlsv1.3' should be disabled from <code>versions</code>.</br>PSK cipher suites: <code>\"RSA-PSK-AES256-GCM-SHA384,RSA-PSK-AES256-CBC-SHA384,</br>RSA-PSK-AES128-GCM-SHA256,RSA-PSK-AES128-CBC-SHA256,</br>RSA-PSK-AES256-CBC-SHA,RSA-PSK-AES128-CBC-SHA,</br>RSA-PSK-DES-CBC3-SHA,RSA-PSK-RC4-SHA\"</code></br>",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "secure_renegotiate": {
            "default": true,
            "description": "</br>SSL parameter renegotiation is a feature that allows a client and a server</br>to renegotiate the parameters of the SSL connection on the fly.</br>RFC 5746 defines a more secure way of doing this. By enabling secure renegotiation,</br>you drop support for the insecure renegotiation, prone to MitM attacks.</br>",
            "type": "boolean"
          },
          "enable": {
            "default": false,
            "description": "</br>Enable TLS.</br>",
            "type": "boolean"
          },
          "server_name_indication": {
            "description": "</br>Specify the host name to be used in TLS Server Name Indication extension.</br>For instance, when connecting to \"server.example.net\", the genuine server</br>which accepts the connection and performs TLS handshake may differ from the</br>host the TLS client initially connects to, e.g. when connecting to an IP address</br>or when the host has multiple resolvable DNS records </br>If not specified, it will default to the host name string which is used</br>to establish the connection, unless it is IP addressed used.</br>The host name is then also used in the host name verification of the peer</br>certificate.</br> The special value 'disable' prevents the Server Name</br>Indication extension from being sent and disables the hostname</br>verification check.</br>",
            "example": "disable",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "enum": [
                  "disable"
                ],
                "type": "string"
              }
            ]
          }
        },
        "type": "object"
      },
      "lwm2m.resource": {
        "properties": {
          "operations": {
            "description": "Resource Operations",
            "example": "E",
            "type": "string"
          },
          "dataType": {
            "description": "Data Type",
            "enum": [
              "Integer",
              "Float",
              "Time",
              "String",
              "Boolean",
              "Opaque",
              "Objlnk"
            ],
            "example": "Integer",
            "type": "string"
          },
          "path": {
            "description": "Resource Path",
            "example": "urn:oma:lwm2m:oma:2",
            "type": "string"
          },
          "name": {
            "description": "Resource Name",
            "example": "lwm2m-test",
            "type": "string"
          }
        },
        "type": "object"
      },
      "gateway.lwm2m_translators": {
        "required": [
          "update",
          "register",
          "notify",
          "response",
          "command"
        ],
        "properties": {
          "command": {
            "description": "The topic for receiving downstream commands.</br>For each new LwM2M client that succeeds in going online, the gateway creates a subscription relationship to receive downstream commands and send it to the LwM2M client",
            "$ref": "#/components/schemas/gateway.translator"
          },
          "response": {
            "description": "The topic for gateway to publish the acknowledge events from LwM2M client",
            "$ref": "#/components/schemas/gateway.translator"
          },
          "notify": {
            "description": "The topic for gateway to publish the notify events from LwM2M client.</br>After succeed observe a resource of LwM2M client, Gateway will send the notify events via this topic, if the client reports any resource changes",
            "$ref": "#/components/schemas/gateway.translator"
          },
          "register": {
            "description": "The topic for gateway to publish the register events from LwM2M client.",
            "$ref": "#/components/schemas/gateway.translator"
          },
          "update": {
            "description": "The topic for gateway to publish the update events from LwM2M client",
            "$ref": "#/components/schemas/gateway.translator"
          }
        },
        "type": "object"
      },
      "listeners.ssl_required_bind": {
        "required": [
          "bind",
          "id",
          "type"
        ],
        "properties": {
          "type": {
            "description": "Listener type",
            "enum": [
              "ssl"
            ],
            "type": "string"
          },
          "running": {
            "description": "Listener status",
            "type": "boolean"
          },
          "id": {
            "description": "Listener id",
            "type": "string"
          },
          "current_connections": {
            "description": "Current connections",
            "minimum": 0,
            "type": "integer"
          },
          "enabled": {
            "default": true,
            "description": "</br>Enable listener.</br>",
            "type": "boolean"
          },
          "bind": {
            "default": 8883,
            "description": "</br>IP address and port for the listening socket.</br>",
            "oneOf": [
              {
                "type": "integer"
              },
              {
                "example": "127.0.0.1:80",
                "type": "string"
              }
            ]
          },
          "acceptors": {
            "default": 16,
            "description": "</br>The size of the listener's receiving pool.</br>",
            "minimum": 1,
            "type": "integer"
          },
          "max_connections": {
            "default": "infinity",
            "description": "</br>The maximum number of concurrent connections allowed by the listener.</br>",
            "oneOf": [
              {
                "minimum": 1,
                "type": "integer"
              },
              {
                "enum": [
                  "infinity"
                ],
                "type": "string"
              }
            ]
          },
          "mountpoint": {
            "default": "",
            "description": "</br>When publishing or subscribing, prefix all topics with a mountpoint string.</br>The prefixed string will be removed from the topic name when the message</br>is delivered to the subscriber. The mountpoint is a way that users can use</br>to implement isolation of message routing between different listeners.</br>For example if a client A subscribes to `t` with `listeners.tcp.\\<name>.mountpoint`</br>set to `some_tenant`, then the client actually subscribes to the topic</br>`some_tenant/t`. Similarly, if another client B (connected to the same listener</br>as the client A) sends a message to topic `t`, the message is routed</br>to all the clients subscribed `some_tenant/t`, so client A will receive the</br>message, with topic name `t`.</br>Set to `\"\"` to disable the feature.</br></br>Variables in mountpoint string:</br>  - <code>${clientid}</code>: clientid</br>  - <code>${username}</code>: username</br>",
            "type": "string"
          },
          "zone": {
            "default": "default",
            "description": "</br>The configuration zone to which the listener belongs.</br>",
            "type": "string"
          },
          "limiter": {
            "default": {
              "connection": "default"
            },
            "description": "</br>Type of the rate limit.</br>",
            "properties": {
              "$ratelimit_name": {
                "example": "retainer",
                "type": "string"
              }
            },
            "type": "object"
          },
          "enable_authn": {
            "default": true,
            "description": "</br>Set <code>true</code> (default) to enable client authentication on this listener.</br>When set to <code>false</code> clients will be allowed to connect without authentication.</br>",
            "type": "boolean"
          },
          "access_rules": {
            "default": [
              "allow all"
            ],
            "description": "</br>The access control rules for this listener.</br>See: https://github.com/emqtt/esockd#allowdeny</br>",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "proxy_protocol": {
            "default": false,
            "description": "</br>Enable the Proxy Protocol V1/2 if the EMQX cluster is deployed behind HAProxy or Nginx.</br>See: https://www.haproxy.com/blog/haproxy/proxy-protocol/</br>",
            "type": "boolean"
          },
          "proxy_protocol_timeout": {
            "default": "3s",
            "description": "</br>Timeout for proxy protocol. EMQX will close the TCP connection if proxy protocol packet is not received within the timeout.</br>",
            "example": "12m",
            "type": "string"
          },
          "tcp_options": {
            "$ref": "#/components/schemas/broker.tcp_opts"
          },
          "ssl_options": {
            "$ref": "#/components/schemas/broker.listener_ssl_opts"
          }
        },
        "type": "object"
      },
      "gateway.stomp_frame": {
        "properties": {
          "max_headers": {
            "default": 10,
            "description": "The maximum number of Header",
            "minimum": 0,
            "type": "integer"
          },
          "max_headers_length": {
            "default": 1024,
            "description": "The maximum string length of the Header Value",
            "minimum": 0,
            "type": "integer"
          },
          "max_body_length": {
            "default": 65536,
            "description": "Maximum number of bytes of Body allowed per Stomp packet",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "retainer.message_summary": {
        "properties": {
          "msgid": {
            "description": "Message ID.",
            "type": "string"
          },
          "topic": {
            "description": "Topic.",
            "type": "string"
          },
          "qos": {
            "description": "QoS.",
            "enum": [
              0,
              1,
              2
            ],
            "type": "string"
          },
          "publish_at": {
            "description": "Message publish time, RFC 3339 format.",
            "type": "string"
          },
          "from_clientid": {
            "description": "The clientid of publisher.",
            "type": "string"
          },
          "from_username": {
            "description": "The username of publisher.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "authn-jwt.ssl_disable": {
        "properties": {
          "enable": {
            "description": "Enable/disable SSL.",
            "enum": [
              false
            ],
            "type": "string"
          }
        },
        "type": "object"
      },
      "broker.broker_perf": {
        "properties": {
          "route_lock_type": {
            "default": "key",
            "description": "Performance tuning for subscribing/unsubscribing a wildcard topic.</br>Change this parameter only when there are many wildcard topics.</br></br>NOTE: when changing from/to `global` lock, it requires all nodes in the cluster to be stopped before the change.</br>  - `key`: mnesia transactional updates with per-key locks. Recommended for a single-node setup.</br>  - `tab`: mnesia transactional updates with table lock. Recommended for a cluster setup.</br>  - `global`: updates are protected with a global lock. Recommended for large clusters.</br>",
            "enum": [
              "key",
              "tab",
              "global"
            ],
            "type": "string"
          },
          "trie_compaction": {
            "default": true,
            "description": "Enable trie path compaction.</br>Enabling it significantly improves wildcard topic subscribe rate, if wildcard topics have unique prefixes like: 'sensor/{{id}}/+/', where ID is unique per subscriber.</br>Topic match performance (when publishing) may degrade if messages are mostly published to topics with large number of levels.</br></br>NOTE: This is a cluster-wide configuration. It requires all nodes to be stopped before changing it.</br>",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "emqx_mgmt_api_topics.topic": {
        "required": [
          "node",
          "topic"
        ],
        "properties": {
          "topic": {
            "description": "Topic Name",
            "type": "string"
          },
          "node": {
            "description": "Node",
            "type": "string"
          }
        },
        "type": "object"
      },
      "emqx_rule_api_schema.ctx_connected": {
        "required": [
          "event_type"
        ],
        "properties": {
          "event_type": {
            "description": "Event Type",
            "enum": [
              "client_connected"
            ],
            "type": "string"
          },
          "clientid": {
            "description": "The Client ID",
            "type": "string"
          },
          "username": {
            "description": "The User Name",
            "type": "string"
          },
          "mountpoint": {
            "description": "The Mountpoint",
            "type": "string"
          },
          "peername": {
            "description": "The IP Address and Port of the Peer Client",
            "type": "string"
          },
          "sockname": {
            "description": "The IP Address and Port of the Local Listener",
            "type": "string"
          },
          "proto_name": {
            "description": "Protocol Name",
            "type": "string"
          },
          "proto_ver": {
            "description": "Protocol Version",
            "type": "string"
          },
          "keepalive": {
            "description": "KeepAlive",
            "type": "integer"
          },
          "clean_start": {
            "default": true,
            "description": "Clean Start",
            "type": "boolean"
          },
          "expiry_interval": {
            "description": "Expiry Interval",
            "type": "integer"
          },
          "is_bridge": {
            "default": false,
            "description": "Is Bridge",
            "type": "boolean"
          },
          "connected_at": {
            "description": "The Time that this Client is Connected",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "listeners.listener_id_status": {
        "required": [
          "bind",
          "enable",
          "id"
        ],
        "properties": {
          "id": {
            "description": "Listener id",
            "example": "tcp:demo",
            "type": "string"
          },
          "enable": {
            "description": "Listener enable",
            "type": "boolean"
          },
          "number": {
            "description": "ListenerId counter",
            "minimum": 1,
            "type": "integer"
          },
          "bind": {
            "description": "Listener bind addr",
            "oneOf": [
              {
                "type": "integer"
              },
              {
                "example": "127.0.0.1:80",
                "type": "string"
              }
            ]
          },
          "acceptors": {
            "description": "ListenerId acceptors",
            "minimum": 1,
            "type": "integer"
          },
          "status": {
            "$ref": "#/components/schemas/listeners.status"
          },
          "node_status": {
            "items": {
              "$ref": "#/components/schemas/listeners.node_status"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "emqx_dashboard_monitor_api.sampler_current": {
        "properties": {
          "dropped_msg_rate": {
            "description": "Dropped messages per 10 seconds",
            "type": "integer"
          },
          "received_msg_rate": {
            "description": "Dropped messages per 10 seconds",
            "type": "integer"
          },
          "sent_msg_rate": {
            "description": "Sent messages per 10 seconds",
            "type": "integer"
          },
          "subscriptions": {
            "description": "Subscriptions at the time of sampling. Can only represent the approximate state",
            "type": "integer"
          },
          "topics": {
            "description": "Count topics at the time of sampling. Can only represent the approximate state",
            "type": "integer"
          },
          "connections": {
            "description": "Connections at the time of sampling. Can only represent the approximate state",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "bridge.put": {
        "required": [
          "url"
        ],
        "properties": {
          "enable": {
            "default": true,
            "description": "Enable or disable this bridge",
            "type": "boolean"
          },
          "direction": {
            "default": "egress",
            "description": "The direction of this bridge, MUST be 'egress'",
            "enum": [
              "egress"
            ],
            "type": "string"
          },
          "connect_timeout": {
            "default": "15s",
            "description": "The timeout when connecting to the HTTP server.",
            "example": "32s",
            "type": "string"
          },
          "max_retries": {
            "default": 5,
            "description": "Max retry times if error on sending request.",
            "minimum": 0,
            "type": "integer"
          },
          "retry_interval": {
            "default": "1s",
            "description": "Interval between retries.",
            "example": "12m",
            "type": "string"
          },
          "pool_type": {
            "default": "random",
            "description": "The type of the pool. Can be one of `random`, `hash`.",
            "enum": [
              "random",
              "hash"
            ],
            "type": "string"
          },
          "pool_size": {
            "default": 8,
            "description": "The pool size.",
            "minimum": 1,
            "type": "integer"
          },
          "enable_pipelining": {
            "default": 100,
            "description": "Whether to send HTTP requests continuously, when set to 0, it means that after each HTTP request is sent, you need to wait for the server to return and then continue to send the next request.",
            "minimum": 1,
            "type": "integer"
          },
          "request": {
            "description": "</br>If the request is provided, the caller can send HTTP requests via</br><code>emqx_resource:query(ResourceId, {send_message, BridgeId, Message})</code></br>",
            "$ref": "#/components/schemas/connector-http.request"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/broker.ssl_client_opts"
          },
          "url": {
            "description": "</br>The URL of the HTTP Bridge.</br>Template with variables is allowed in the path, but variables cannot be used in the scheme, host,</br>or port part.</br>For example, <code> http://localhost:9901/${topic} </code> is allowed, but</br><code> http://${host}:9901/message </code> or <code> http://localhost:${port}/message </code></br>is not allowed.</br>",
            "type": "string"
          },
          "local_topic": {
            "description": "</br>The MQTT topic filter to be forwarded to the HTTP server. All MQTT 'PUBLISH' messages with the topic</br>matching the local_topic will be forwarded.</br>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is</br>configured, then both the data got from the rule and the MQTT messages that match local_topic</br>will be forwarded.</br>",
            "type": "string"
          },
          "method": {
            "default": "post",
            "description": "</br>The method of the HTTP request. All the available methods are: post, put, get, delete.</br>Template with variables is allowed.</br>",
            "enum": [
              "post",
              "put",
              "get",
              "delete"
            ],
            "type": "string"
          },
          "headers": {
            "default": {
              "accept": "application/json",
              "cache-control": "no-cache",
              "connection": "keep-alive",
              "content-type": "application/json",
              "keep-alive": "timeout=5"
            },
            "description": "</br>The headers of the HTTP request.</br>Template with variables is allowed.</br>",
            "example": {},
            "type": "object"
          },
          "body": {
            "default": "${payload}",
            "description": "</br>The body of the HTTP request.</br>Template with variables is allowed.</br>",
            "type": "string"
          },
          "request_timeout": {
            "default": "15s",
            "description": "HTTP request timeout.",
            "example": "32s",
            "type": "string"
          }
        },
        "type": "object"
      },
      "emqx_telemetry_api.telemetry": {
        "properties": {
          "emqx_version": {
            "description": "Get emqx version",
            "example": "5.0.0-beta.3-32d1547c",
            "type": "string"
          },
          "license": {
            "description": "Get license information",
            "example": {
              "edition": "opensource"
            },
            "type": "object"
          },
          "os_name": {
            "description": "Get OS name",
            "example": "Linux",
            "type": "string"
          },
          "os_version": {
            "description": "Get OS version",
            "example": "20.04",
            "type": "string"
          },
          "otp_version": {
            "description": "Get Erlang OTP version",
            "example": "24",
            "type": "string"
          },
          "up_time": {
            "description": "Get uptime",
            "example": 20220113,
            "type": "integer"
          },
          "uuid": {
            "description": "Get UUID",
            "example": "AAAAAAAA-BBBB-CCCC-2022-DDDDEEEEFFF",
            "type": "string"
          },
          "nodes_uuid": {
            "description": "Get nodes UUID",
            "example": [
              "AAAAAAAA-BBBB-CCCC-2022-DDDDEEEEFFF",
              "ZZZZZZZZ-CCCC-BBBB-2022-DDDDEEEEFFF"
            ],
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "active_plugins": {
            "description": "Get active plugins",
            "example": [
              "Plugin A",
              "Plugin B"
            ],
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "active_modules": {
            "description": "Get active modules",
            "example": [
              "Module A",
              "Module B"
            ],
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "num_clients": {
            "description": "Get number of clients",
            "example": 20220113,
            "type": "integer"
          },
          "messages_received": {
            "description": "Get number of messages received",
            "example": 2022,
            "type": "integer"
          },
          "messages_sent": {
            "description": "Get number of messages sent",
            "example": 2022,
            "type": "integer"
          }
        },
        "type": "object"
      },
      "broker.mqtt_ws_listener": {
        "required": [
          "bind"
        ],
        "properties": {
          "enabled": {
            "default": true,
            "description": "</br>Enable listener.</br>",
            "type": "boolean"
          },
          "bind": {
            "default": 8083,
            "description": "</br>IP address and port for the listening socket.</br>",
            "oneOf": [
              {
                "type": "integer"
              },
              {
                "example": "127.0.0.1:80",
                "type": "string"
              }
            ]
          },
          "acceptors": {
            "default": 16,
            "description": "</br>The size of the listener's receiving pool.</br>",
            "minimum": 1,
            "type": "integer"
          },
          "max_connections": {
            "default": "infinity",
            "description": "</br>The maximum number of concurrent connections allowed by the listener.</br>",
            "oneOf": [
              {
                "minimum": 1,
                "type": "integer"
              },
              {
                "enum": [
                  "infinity"
                ],
                "type": "string"
              }
            ]
          },
          "mountpoint": {
            "default": "",
            "description": "</br>When publishing or subscribing, prefix all topics with a mountpoint string.</br>The prefixed string will be removed from the topic name when the message</br>is delivered to the subscriber. The mountpoint is a way that users can use</br>to implement isolation of message routing between different listeners.</br>For example if a client A subscribes to `t` with `listeners.tcp.\\<name>.mountpoint`</br>set to `some_tenant`, then the client actually subscribes to the topic</br>`some_tenant/t`. Similarly, if another client B (connected to the same listener</br>as the client A) sends a message to topic `t`, the message is routed</br>to all the clients subscribed `some_tenant/t`, so client A will receive the</br>message, with topic name `t`.</br>Set to `\"\"` to disable the feature.</br></br>Variables in mountpoint string:</br>  - <code>${clientid}</code>: clientid</br>  - <code>${username}</code>: username</br>",
            "type": "string"
          },
          "zone": {
            "default": "default",
            "description": "</br>The configuration zone to which the listener belongs.</br>",
            "type": "string"
          },
          "limiter": {
            "default": {
              "connection": "default"
            },
            "description": "</br>Type of the rate limit.</br>",
            "properties": {
              "$ratelimit_name": {
                "example": "retainer",
                "type": "string"
              }
            },
            "type": "object"
          },
          "enable_authn": {
            "default": true,
            "description": "</br>Set <code>true</code> (default) to enable client authentication on this listener.</br>When set to <code>false</code> clients will be allowed to connect without authentication.</br>",
            "type": "boolean"
          },
          "access_rules": {
            "default": [
              "allow all"
            ],
            "description": "</br>The access control rules for this listener.</br>See: https://github.com/emqtt/esockd#allowdeny</br>",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "proxy_protocol": {
            "default": false,
            "description": "</br>Enable the Proxy Protocol V1/2 if the EMQX cluster is deployed behind HAProxy or Nginx.</br>See: https://www.haproxy.com/blog/haproxy/proxy-protocol/</br>",
            "type": "boolean"
          },
          "proxy_protocol_timeout": {
            "default": "3s",
            "description": "</br>Timeout for proxy protocol. EMQX will close the TCP connection if proxy protocol packet is not received within the timeout.</br>",
            "example": "12m",
            "type": "string"
          },
          "authentication": {
            "description": "</br>Per-listener authentication override.</br>Authentication can be one single authenticator instance or a chain of authenticators as an array.</br>When authenticating a login (username, client ID, etc.) the authenticators are checked in the configured order.</br></br>",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/authn-scram-builtin_db.authentication"
                },
                {
                  "$ref": "#/components/schemas/authn-jwt.jwks"
                },
                {
                  "$ref": "#/components/schemas/authn-jwt.public-key"
                },
                {
                  "$ref": "#/components/schemas/authn-jwt.hmac-based"
                },
                {
                  "$ref": "#/components/schemas/authn-http.post"
                },
                {
                  "$ref": "#/components/schemas/authn-http.get"
                },
                {
                  "$ref": "#/components/schemas/authn-redis.sentinel"
                },
                {
                  "$ref": "#/components/schemas/authn-redis.cluster"
                },
                {
                  "$ref": "#/components/schemas/authn-redis.standalone"
                },
                {
                  "$ref": "#/components/schemas/authn-mongodb.sharded-cluster"
                },
                {
                  "$ref": "#/components/schemas/authn-mongodb.replica-set"
                },
                {
                  "$ref": "#/components/schemas/authn-mongodb.standalone"
                },
                {
                  "$ref": "#/components/schemas/authn-postgresql.authentication"
                },
                {
                  "$ref": "#/components/schemas/authn-mysql.authentication"
                },
                {
                  "$ref": "#/components/schemas/authn-builtin_db.authentication"
                }
              ]
            },
            "type": "array"
          },
          "tcp_options": {
            "$ref": "#/components/schemas/broker.tcp_opts"
          },
          "websocket": {
            "$ref": "#/components/schemas/broker.ws_opts"
          }
        },
        "type": "object"
      },
      "listeners.node_status": {
        "properties": {
          "node": {
            "description": "Node name",
            "example": "emqx@127.0.0.1",
            "type": "string"
          },
          "max_connections": {
            "description": "Max connections",
            "oneOf": [
              {
                "type": "integer"
              },
              {
                "enum": [
                  "infinity"
                ],
                "type": "string"
              }
            ]
          },
          "current_connections": {
            "description": "Current connections",
            "minimum": 0,
            "type": "integer"
          }
        },
        "type": "object"
      },
      "emqx_mgmt_api_clients.client": {
        "properties": {
          "awaiting_rel_cnt": {
            "description": "v4 api name [awaiting_rel] Number of awaiting PUBREC packet",
            "type": "integer"
          },
          "awaiting_rel_max": {
            "description": "v4 api name [max_awaiting_rel]. Maximum allowed number of awaiting PUBREC packet",
            "type": "integer"
          },
          "clean_start": {
            "description": "Indicate whether the client is using a brand new session",
            "type": "boolean"
          },
          "clientid": {
            "description": "Client identifier",
            "type": "string"
          },
          "connected": {
            "description": "Whether the client is connected",
            "type": "boolean"
          },
          "connected_at": {
            "description": "Client connection time, rfc3339 or timestamp(millisecond)",
            "oneOf": [
              {
                "description": "epoch-millisecond",
                "example": 1640995200000,
                "type": "integer"
              },
              {
                "example": "2022-01-01T00:00:00.000Z",
                "format": "date-time",
                "type": "string"
              }
            ]
          },
          "created_at": {
            "description": "Session creation time, rfc3339 or timestamp(millisecond)",
            "oneOf": [
              {
                "description": "epoch-millisecond",
                "example": 1640995200000,
                "type": "integer"
              },
              {
                "example": "2022-01-01T00:00:00.000Z",
                "format": "date-time",
                "type": "string"
              }
            ]
          },
          "disconnected_at": {
            "description": "Client offline time. It's Only valid and returned when connected is false, rfc3339 or timestamp(millisecond)",
            "oneOf": [
              {
                "description": "epoch-millisecond",
                "example": 1640995200000,
                "type": "integer"
              },
              {
                "example": "2022-01-01T00:00:00.000Z",
                "format": "date-time",
                "type": "string"
              }
            ]
          },
          "expiry_interval": {
            "description": "Session expiration interval, with the unit of second",
            "type": "integer"
          },
          "heap_size": {
            "description": "Process heap size with the unit of byte",
            "type": "integer"
          },
          "inflight_cnt": {
            "description": "Current length of inflight",
            "type": "integer"
          },
          "inflight_max": {
            "description": "v4 api name [max_inflight]. Maximum length of inflight",
            "type": "integer"
          },
          "ip_address": {
            "description": "Client's IP address",
            "type": "string"
          },
          "is_bridge": {
            "description": "Indicates whether the client is connectedvia bridge",
            "type": "boolean"
          },
          "keepalive": {
            "description": "keepalive time, with the unit of second",
            "type": "integer"
          },
          "mailbox_len": {
            "description": "Process mailbox size",
            "type": "integer"
          },
          "mqueue_dropped": {
            "description": "Number of messages dropped by the message queue due to exceeding the length",
            "type": "integer"
          },
          "mqueue_len": {
            "description": "Current length of message queue",
            "type": "integer"
          },
          "mqueue_max": {
            "description": "v4 api name [max_mqueue]. Maximum length of message queue",
            "type": "integer"
          },
          "node": {
            "description": "Name of the node to which the client is connected",
            "type": "string"
          },
          "port": {
            "description": "Client's port",
            "type": "integer"
          },
          "proto_name": {
            "description": "Client protocol name",
            "type": "string"
          },
          "proto_ver": {
            "description": "Protocol version used by the client",
            "type": "integer"
          },
          "recv_cnt": {
            "description": "Number of TCP packets received",
            "type": "integer"
          },
          "recv_msg": {
            "description": "Number of PUBLISH packets received",
            "type": "integer"
          },
          "recv_msg.dropped": {
            "description": "Number of dropped PUBLISH packets",
            "type": "integer"
          },
          "recv_msg.dropped.await_pubrel_timeout": {
            "description": "Number of dropped PUBLISH packets due to expired",
            "type": "integer"
          },
          "recv_msg.qos0": {
            "description": "Number of PUBLISH QoS0 packets received",
            "type": "integer"
          },
          "recv_msg.qos1": {
            "description": "Number of PUBLISH QoS1 packets received",
            "type": "integer"
          },
          "recv_msg.qos2": {
            "description": "Number of PUBLISH QoS2 packets received",
            "type": "integer"
          },
          "recv_oct": {
            "description": "Number of bytes received",
            "type": "integer"
          },
          "recv_pkt": {
            "description": "Number of MQTT packets received",
            "type": "integer"
          },
          "reductions": {
            "description": "Erlang reduction",
            "type": "integer"
          },
          "send_cnt": {
            "description": "Number of TCP packets sent",
            "type": "integer"
          },
          "send_msg": {
            "description": "Number of PUBLISH packets sent",
            "type": "integer"
          },
          "send_msg.dropped": {
            "description": "Number of dropped PUBLISH packets",
            "type": "integer"
          },
          "send_msg.dropped.expired": {
            "description": "Number of dropped PUBLISH packets due to expired",
            "type": "integer"
          },
          "send_msg.dropped.queue_full": {
            "description": "Number of dropped PUBLISH packets due to queue full",
            "type": "integer"
          },
          "send_msg.dropped.too_large": {
            "description": "Number of dropped PUBLISH packets due to packet length too large",
            "type": "integer"
          },
          "send_msg.qos0": {
            "description": "Number of PUBLISH QoS0 packets sent",
            "type": "integer"
          },
          "send_msg.qos1": {
            "description": "Number of PUBLISH QoS1 packets sent",
            "type": "integer"
          },
          "send_msg.qos2": {
            "description": "Number of PUBLISH QoS2 packets sent",
            "type": "integer"
          },
          "send_oct": {
            "description": "Number of bytes sent",
            "type": "integer"
          },
          "send_pkt": {
            "description": "Number of MQTT packets sent",
            "type": "integer"
          },
          "subscriptions_cnt": {
            "description": "Number of subscriptions established by this client.",
            "type": "integer"
          },
          "subscriptions_max": {
            "description": "v4 api name [max_subscriptions] Maximum number of subscriptions allowed by this client",
            "type": "integer"
          },
          "username": {
            "description": "User name of client when connecting",
            "type": "string"
          },
          "mountpoint": {
            "description": "Topic mountpoint",
            "type": "string"
          },
          "will_msg": {
            "description": "Client will message",
            "type": "string"
          },
          "zone": {
            "description": "Indicate the configuration group used by the client",
            "type": "string"
          }
        },
        "type": "object"
      },
      "authz.resource_metrics": {
        "properties": {
          "matched": {
            "description": "Count of this resource is queried.",
            "type": "integer"
          },
          "success": {
            "description": "Count of query success.",
            "type": "integer"
          },
          "failed": {
            "description": "Count of query failed.",
            "type": "integer"
          },
          "rate": {
            "description": "The rate of matched, times/second.",
            "type": "number"
          },
          "rate_max": {
            "description": "The max rate of matched, times/second.",
            "type": "number"
          },
          "rate_last5m": {
            "description": "The average rate of matched in the last 5 minutes, times/second.",
            "type": "number"
          }
        },
        "type": "object"
      },
      "emqx_mgmt_api_subscriptions.subscription": {
        "properties": {
          "node": {
            "description": "Access type",
            "type": "string"
          },
          "topic": {
            "description": "Topic name",
            "type": "string"
          },
          "clientid": {
            "description": "Client identifier",
            "type": "string"
          },
          "qos": {
            "description": "QoS",
            "enum": [
              0,
              1,
              2
            ],
            "type": "string"
          },
          "nl": {
            "description": "No Local",
            "type": "integer"
          },
          "rap": {
            "description": "Retain as Published",
            "type": "integer"
          },
          "rh": {
            "description": "Retain Handling",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "emqx_conf_schema.cluster_mcast": {
        "properties": {
          "addr": {
            "default": "239.192.0.1",
            "description": "Multicast IPv4 address.",
            "readOnly": true,
            "type": "string"
          },
          "ports": {
            "default": [
              4369,
              4370
            ],
            "description": "List of UDP ports used for service discovery.</br>Note: probe messages are broadcast to all the specified ports.</br>          ",
            "items": {
              "type": "integer"
            },
            "readOnly": true,
            "type": "array"
          },
          "iface": {
            "default": "0.0.0.0",
            "description": "Local IP address the node discovery service needs to bind to.",
            "readOnly": true,
            "type": "string"
          },
          "ttl": {
            "default": 255,
            "description": "Time-to-live (TTL) for the outgoing UDP datagrams.",
            "maximum": 255,
            "minimum": 0,
            "readOnly": true,
            "type": "integer"
          },
          "loop": {
            "default": true,
            "description": "If <code>true</code>, loop UDP datagrams back to the local socket.",
            "readOnly": true,
            "type": "boolean"
          },
          "sndbuf": {
            "default": "16KB",
            "description": "Size of the kernel-level buffer for outgoing datagrams.",
            "example": "32MB",
            "readOnly": true,
            "type": "string"
          },
          "recbuf": {
            "default": "16KB",
            "description": "Size of the kernel-level buffer for incoming datagrams.",
            "example": "32MB",
            "readOnly": true,
            "type": "string"
          },
          "buffer": {
            "default": "32KB",
            "description": "Size of the user-level buffer.",
            "example": "32MB",
            "readOnly": true,
            "type": "string"
          }
        },
        "type": "object"
      },
      "emqx_gateway_api_listeners.ssl_listener": {
        "properties": {
          "id": {
            "description": "Listener ID",
            "type": "string"
          },
          "type": {
            "description": "Listener Type",
            "enum": [
              "ssl"
            ],
            "type": "string"
          },
          "name": {
            "description": "Listener Name",
            "type": "string"
          },
          "running": {
            "description": "Listener Running status",
            "type": "boolean"
          },
          "acceptors": {
            "default": 16,
            "description": "Size of the acceptor pool.",
            "type": "integer"
          },
          "tcp_options": {
            "description": "Setting the TCP socket options.",
            "$ref": "#/components/schemas/broker.tcp_opts"
          },
          "proxy_protocol": {
            "default": false,
            "description": "Enable the Proxy Protocol V1/2 if the EMQX cluster is deployed behind HAProxy or Nginx.</br>See: https://www.haproxy.com/blog/haproxy/proxy-protocol/",
            "type": "boolean"
          },
          "proxy_protocol_timeout": {
            "default": "15s",
            "description": "Timeout for proxy protocol.</br>EMQX will close the TCP connection if proxy protocol packet is not received within the timeout.",
            "example": "12m",
            "type": "string"
          },
          "enable": {
            "default": true,
            "description": "Enable the listener.",
            "type": "boolean"
          },
          "bind": {
            "description": "The IP address and port that the listener will bind.",
            "oneOf": [
              {
                "type": "integer"
              },
              {
                "example": "127.0.0.1:80",
                "type": "string"
              }
            ]
          },
          "max_connections": {
            "default": 1024,
            "description": "Maximum number of concurrent connections.",
            "type": "integer"
          },
          "max_conn_rate": {
            "default": 1000,
            "description": "Maximum connections per second.",
            "type": "integer"
          },
          "authentication": {
            "description": "Default authentication configs for all the gateway listeners. For per-listener overrides see <code>authentication</code></br> in listener configs",
            "oneOf": [
              {
                "$ref": "#/components/schemas/authn-scram-builtin_db.authentication"
              },
              {
                "$ref": "#/components/schemas/authn-jwt.jwks"
              },
              {
                "$ref": "#/components/schemas/authn-jwt.public-key"
              },
              {
                "$ref": "#/components/schemas/authn-jwt.hmac-based"
              },
              {
                "$ref": "#/components/schemas/authn-http.post"
              },
              {
                "$ref": "#/components/schemas/authn-http.get"
              },
              {
                "$ref": "#/components/schemas/authn-redis.sentinel"
              },
              {
                "$ref": "#/components/schemas/authn-redis.cluster"
              },
              {
                "$ref": "#/components/schemas/authn-redis.standalone"
              },
              {
                "$ref": "#/components/schemas/authn-mongodb.sharded-cluster"
              },
              {
                "$ref": "#/components/schemas/authn-mongodb.replica-set"
              },
              {
                "$ref": "#/components/schemas/authn-mongodb.standalone"
              },
              {
                "$ref": "#/components/schemas/authn-postgresql.authentication"
              },
              {
                "$ref": "#/components/schemas/authn-mysql.authentication"
              },
              {
                "$ref": "#/components/schemas/authn-builtin_db.authentication"
              }
            ]
          },
          "enable_authn": {
            "default": true,
            "description": "Set <code>true</code> (default) to enable client authentication on this listener. </br>When set to <code>false</code> clients will be allowed to connect without authentication.",
            "type": "boolean"
          },
          "mountpoint": {
            "description": "When publishing or subscribing, prefix all topics with a mountpoint string.</br>The prefixed string will be removed from the topic name when the message is delivered to the subscriber. The mountpoint is a way that users can use to implement isolation of message routing between different listeners.</br>For example if a client A subscribes to `t` with `listeners.tcp.\\<name>.mountpoint` set to `some_tenant`, then the client actually subscribes to the topic `some_tenant/t`. Similarly, if another client B (connected to the same listener as the client A) sends a message to topic `t`, the message is routed to all the clients subscribed `some_tenant/t`, so client A will receive the message, with topic name `t`. Set to `\"\"` to disable the feature.</br>Variables in mountpoint string:</br>  - <code>${clientid}</code>: clientid</br>  - <code>${username}</code>: username</br>",
            "type": "string"
          },
          "access_rules": {
            "default": "",
            "description": "The access control rules for this listener.</br>See: https://github.com/emqtt/esockd#allowdeny",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "ssl_options": {
            "description": "SSL Socket options.",
            "$ref": "#/components/schemas/broker.listener_ssl_opts"
          },
          "current_connections": {
            "description": "Current Connections",
            "minimum": 0,
            "type": "integer"
          },
          "node_status": {
            "description": "listener status of each node in the cluster",
            "items": {
              "$ref": "#/components/schemas/listeners.node_status"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "zone.mqtt": {
        "properties": {
          "idle_timeout": {
            "description": "After the TCP connection is established, if the MQTT CONNECT packet from the client is not received within the time specified by <code>idle_timeout</code>, the connection will be disconnected.",
            "oneOf": [
              {
                "example": "12m",
                "type": "string"
              },
              {
                "enum": [
                  "infinity"
                ],
                "type": "string"
              }
            ]
          },
          "max_packet_size": {
            "description": "Maximum MQTT packet size allowed.",
            "example": "32MB",
            "type": "string"
          },
          "max_clientid_len": {
            "description": "Maximum allowed length of MQTT Client ID.",
            "maximum": 65535,
            "minimum": 23,
            "type": "integer"
          },
          "max_topic_levels": {
            "description": "Maximum topic levels allowed.",
            "maximum": 65535,
            "minimum": 1,
            "type": "integer"
          },
          "max_qos_allowed": {
            "description": "Maximum QoS allowed.",
            "enum": [
              0,
              1,
              2
            ],
            "type": "string"
          },
          "max_topic_alias": {
            "description": "Maximum topic alias, 0 means no topic alias supported.",
            "maximum": 65535,
            "minimum": 0,
            "type": "integer"
          },
          "retain_available": {
            "description": "Whether to enable support for MQTT retained message.",
            "type": "boolean"
          },
          "wildcard_subscription": {
            "description": "Whether to enable support for MQTT wildcard subscription.",
            "type": "boolean"
          },
          "shared_subscription": {
            "description": "Whether to enable support for MQTT shared subscription.",
            "type": "boolean"
          },
          "exclusive_subscription": {
            "description": "Whether to enable support for MQTT exclusive subscription.",
            "type": "boolean"
          },
          "ignore_loop_deliver": {
            "description": "Ignore loop delivery of messages for MQTT v3.1.1/v3.1.0, similar to <code>No Local</code> subscription option in MQTT 5.0",
            "type": "boolean"
          },
          "strict_mode": {
            "description": "Parse MQTT messages in strict mode.</br>When set to true, invalid utf8 strings in for example client ID, topic name, etc. will cause the client to be disconnected",
            "type": "boolean"
          },
          "response_information": {
            "description": "Specify the response information returned to the client. This feature is disabled if is set to \"\". Applies only to clients using MQTT 5.0.",
            "type": "string"
          },
          "server_keepalive": {
            "description": "The keep alive that EMQX requires the client to use. If configured as <code>disabled</code>, it means that the keep alive specified by the client will be used. Requires <code>Server Keep Alive</code> in MQTT 5.0, so it is only applicable to clients using MQTT 5.0 protocol.",
            "oneOf": [
              {
                "enum": [
                  "disabled"
                ],
                "type": "string"
              },
              {
                "type": "integer"
              }
            ]
          },
          "keepalive_backoff": {
            "description": "The backoff multiplier used by the broker to determine the client keep alive timeout. If EMQX doesn't receive any packet in <code>Keep Alive * Backoff * 2</code> seconds, EMQX will close the current connection.",
            "type": "number"
          },
          "max_subscriptions": {
            "description": "Maximum number of subscriptions allowed per client.",
            "oneOf": [
              {
                "enum": [
                  "infinity"
                ],
                "type": "string"
              },
              {
                "minimum": 1,
                "type": "integer"
              }
            ]
          },
          "upgrade_qos": {
            "description": "Force upgrade of QoS level according to subscription.",
            "type": "boolean"
          },
          "max_inflight": {
            "description": "Maximum number of QoS 1 and QoS 2 messages that are allowed to be delivered simultaneously before completing the acknowledgment.",
            "maximum": 65535,
            "minimum": 1,
            "type": "integer"
          },
          "retry_interval": {
            "description": "Retry interval for QoS 1/2 message delivering.",
            "example": "12m",
            "type": "string"
          },
          "max_awaiting_rel": {
            "description": "Maximum QoS 2 packets (Client -> Broker) awaiting PUBREL.",
            "oneOf": [
              {
                "enum": [
                  "infinity"
                ],
                "type": "string"
              },
              {
                "type": "integer"
              }
            ]
          },
          "await_rel_timeout": {
            "description": "The QoS 2 messages (Client -> Broker) will be dropped if awaiting PUBREL timeout.",
            "example": "12m",
            "type": "string"
          },
          "session_expiry_interval": {
            "description": "Specifies how long the session will expire after the connection is disconnected, only for non-MQTT 5.0 connections.",
            "example": "12m",
            "type": "string"
          },
          "max_mqueue_len": {
            "description": "Maximum queue length. Enqueued messages when persistent client disconnected, or inflight window is full.",
            "oneOf": [
              {
                "enum": [
                  "infinity"
                ],
                "type": "string"
              },
              {
                "minimum": 0,
                "type": "integer"
              }
            ]
          },
          "mqueue_priorities": {
            "description": "Topic priorities. Priority number [1-255]</br>There's no priority table by default, hence all messages are treated equal.</br></br>**NOTE**: Comma and equal signs are not allowed for priority topic names.</br>**NOTE**: Messages for topics not in the priority table are treated as either highest or lowest priority depending on the configured value for <code>mqtt.mqueue_default_priority</code>.</br></br>**Examples**:</br>To configure <code>\"topic/1\" > \"topic/2\"</code>:</br><code>mqueue_priorities: {\"topic/1\": 10, \"topic/2\": 8}</code></br>",
            "oneOf": [
              {
                "enum": [
                  "disabled"
                ],
                "type": "string"
              },
              {
                "example": {},
                "type": "object"
              }
            ]
          },
          "mqueue_default_priority": {
            "description": "Default topic priority, which will be used by topics not in <code>Topic Priorities</code> (<code>mqueue_priorities</code>).",
            "enum": [
              "highest",
              "lowest"
            ],
            "type": "string"
          },
          "mqueue_store_qos0": {
            "description": "Specifies whether to store QoS 0 messages in the message queue while the connection is down but the session remains.",
            "type": "boolean"
          },
          "use_username_as_clientid": {
            "description": "Whether to user Client ID as Username.</br>This setting takes effect later than <code>Use Peer Certificate as Username</code> (<code>peer_cert_as_username</code>) and <code>Use peer certificate as Client ID</code> (<code>peer_cert_as_clientid</code>).</br>",
            "type": "boolean"
          },
          "peer_cert_as_username": {
            "description": "Use the CN, DN field in the peer certificate or the entire certificate content as Username. Only works for the TLS connection.</br>Supported configurations are the following:</br>- <code>cn</code>: Take the CN field of the certificate as Username</br>- <code>dn</code>: Take the DN field of the certificate as Username</br>- <code>crt</code>: Take the content of the <code>DER</code> or <code>PEM</code> certificate as Username</br>- <code>pem</code>: Convert <code>DER</code> certificate content to <code>PEM</code> format as Username</br>- <code>md5</code>: Take the MD5 value of the content of the <code>DER</code> or <code>PEM</code> certificate as Username</br>",
            "enum": [
              "disabled",
              "cn",
              "dn",
              "crt",
              "pem",
              "md5"
            ],
            "type": "string"
          },
          "peer_cert_as_clientid": {
            "description": "Use the CN, DN field in the peer certificate or the entire certificate content as Client ID. Only works for the TLS connection.</br>Supported configurations are the following:</br>- <code>cn</code>: Take the CN field of the certificate as Client ID</br>- <code>dn</code>: Take the DN field of the certificate as Client ID</br>- <code>crt</code>: Take the content of the <code>DER</code> or <code>PEM</code> certificate as Client ID</br>- <code>pem</code>: Convert <code>DER</code> certificate content to <code>PEM</code> format as Client ID</br>- <code>md5</code>: Take the MD5 value of the content of the <code>DER</code> or <code>PEM</code> certificate as Client ID</br>",
            "enum": [
              "disabled",
              "cn",
              "dn",
              "crt",
              "pem",
              "md5"
            ],
            "type": "string"
          }
        },
        "type": "object"
      },
      "emqx_authn_api.request_move": {
        "required": [
          "position"
        ],
        "properties": {
          "position": {
            "type": "string"
          }
        },
        "type": "object"
      },
      "emqx_topic_metrics_api.topic_metrics": {
        "required": [
          "metrics",
          "create_time",
          "topic"
        ],
        "properties": {
          "topic": {
            "description": "Topic",
            "example": "testtopic/1",
            "type": "string"
          },
          "create_time": {
            "description": "Create time",
            "example": "2022-01-14T21:48:47+08:00",
            "oneOf": [
              {
                "description": "epoch-second",
                "example": 1640995200,
                "type": "integer"
              },
              {
                "example": "2022-01-01T00:00:00.000Z",
                "format": "date-time",
                "type": "string"
              }
            ]
          },
          "reset_time": {
            "description": "Reset time. In rfc3339. Nullable if never reset",
            "example": "2022-01-14T21:48:47+08:00",
            "oneOf": [
              {
                "description": "epoch-second",
                "example": 1640995200,
                "type": "integer"
              },
              {
                "example": "2022-01-01T00:00:00.000Z",
                "format": "date-time",
                "type": "string"
              }
            ]
          },
          "metrics": {
            "description": "Metrics",
            "$ref": "#/components/schemas/emqx_topic_metrics_api.metrics"
          }
        },
        "type": "object"
      },
      "listeners.quic_required_bind": {
        "required": [
          "bind",
          "id",
          "type"
        ],
        "properties": {
          "type": {
            "description": "Listener type",
            "enum": [
              "quic"
            ],
            "type": "string"
          },
          "running": {
            "description": "Listener status",
            "type": "boolean"
          },
          "id": {
            "description": "Listener id",
            "type": "string"
          },
          "current_connections": {
            "description": "Current connections",
            "minimum": 0,
            "type": "integer"
          },
          "certfile": {
            "description": "</br>Path to the certificate file.</br>",
            "type": "string"
          },
          "keyfile": {
            "description": "</br>Path to the secret key file.</br>",
            "type": "string"
          },
          "ciphers": {
            "default": [
              "TLS_AES_256_GCM_SHA384",
              "TLS_AES_128_GCM_SHA256",
              "TLS_CHACHA20_POLY1305_SHA256"
            ],
            "description": "</br>This config holds TLS cipher suite names separated by comma,</br>or as an array of strings. e.g.</br><code>\"TLS_AES_256_GCM_SHA384,TLS_AES_128_GCM_SHA256\"</code> or</br><code>[\"TLS_AES_256_GCM_SHA384\",\"TLS_AES_128_GCM_SHA256\"]</code>.</br></br>Ciphers (and their ordering) define the way in which the</br>client and server encrypts information over the network connection.</br>Selecting a good cipher suite is critical for the</br>application's data security, confidentiality and performance.</br></br>The names should be in OpenSSL string format (not RFC format).</br>All default values and examples provided by EMQX config</br>documentation are all in OpenSSL format.</br></br>NOTE: Certain cipher suites are only compatible with</br>specific TLS <code>versions</code> ('tlsv1.1', 'tlsv1.2' or 'tlsv1.3')</br>incompatible cipher suites will be silently dropped.</br>For instance, if only 'tlsv1.3' is given in the <code>versions</code>,</br>configuring cipher suites for other versions will have no effect.</br></br></br>NOTE: PSK ciphers are suppressed by 'tlsv1.3' version config</br>If PSK cipher suites are intended, 'tlsv1.3' should be disabled from <code>versions</code>.</br>PSK cipher suites: <code>\"RSA-PSK-AES256-GCM-SHA384,RSA-PSK-AES256-CBC-SHA384,</br>RSA-PSK-AES128-GCM-SHA256,RSA-PSK-AES128-CBC-SHA256,</br>RSA-PSK-AES256-CBC-SHA,RSA-PSK-AES128-CBC-SHA,</br>RSA-PSK-DES-CBC3-SHA,RSA-PSK-RC4-SHA\"</code></br></br>NOTE: QUIC listener supports only 'tlsv1.3' ciphers</br>",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "idle_timeout": {
            "default": "15s",
            "description": "</br>Close transport-layer connections from the clients that have not sent MQTT CONNECT</br>message within this interval.</br>",
            "example": "12m",
            "type": "string"
          },
          "enabled": {
            "default": true,
            "description": "</br>Enable listener.</br>",
            "type": "boolean"
          },
          "bind": {
            "default": 14567,
            "description": "</br>IP address and port for the listening socket.</br>",
            "oneOf": [
              {
                "type": "integer"
              },
              {
                "example": "127.0.0.1:80",
                "type": "string"
              }
            ]
          },
          "acceptors": {
            "default": 16,
            "description": "</br>The size of the listener's receiving pool.</br>",
            "minimum": 1,
            "type": "integer"
          },
          "max_connections": {
            "default": "infinity",
            "description": "</br>The maximum number of concurrent connections allowed by the listener.</br>",
            "oneOf": [
              {
                "minimum": 1,
                "type": "integer"
              },
              {
                "enum": [
                  "infinity"
                ],
                "type": "string"
              }
            ]
          },
          "mountpoint": {
            "default": "",
            "description": "</br>When publishing or subscribing, prefix all topics with a mountpoint string.</br>The prefixed string will be removed from the topic name when the message</br>is delivered to the subscriber. The mountpoint is a way that users can use</br>to implement isolation of message routing between different listeners.</br>For example if a client A subscribes to `t` with `listeners.tcp.\\<name>.mountpoint`</br>set to `some_tenant`, then the client actually subscribes to the topic</br>`some_tenant/t`. Similarly, if another client B (connected to the same listener</br>as the client A) sends a message to topic `t`, the message is routed</br>to all the clients subscribed `some_tenant/t`, so client A will receive the</br>message, with topic name `t`.</br>Set to `\"\"` to disable the feature.</br></br>Variables in mountpoint string:</br>  - <code>${clientid}</code>: clientid</br>  - <code>${username}</code>: username</br>",
            "type": "string"
          },
          "zone": {
            "default": "default",
            "description": "</br>The configuration zone to which the listener belongs.</br>",
            "type": "string"
          },
          "limiter": {
            "default": {
              "connection": "default"
            },
            "description": "</br>Type of the rate limit.</br>",
            "properties": {
              "$ratelimit_name": {
                "example": "retainer",
                "type": "string"
              }
            },
            "type": "object"
          },
          "enable_authn": {
            "default": true,
            "description": "</br>Set <code>true</code> (default) to enable client authentication on this listener.</br>When set to <code>false</code> clients will be allowed to connect without authentication.</br>",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "emqx_authz_api_mnesia.username_response_data": {
        "properties": {
          "data": {
            "items": {
              "$ref": "#/components/schemas/emqx_authz_api_mnesia.rules_for_username"
            },
            "type": "array"
          },
          "meta": {
            "$ref": "#/components/schemas/public.meta"
          }
        },
        "type": "object"
      },
      "authn-scram-builtin_db.authentication": {
        "required": [
          "backend",
          "mechanism"
        ],
        "properties": {
          "mechanism": {
            "description": "Authentication mechanism.",
            "enum": [
              "scram"
            ],
            "type": "string"
          },
          "backend": {
            "description": "Backend type.",
            "enum": [
              "built_in_database"
            ],
            "type": "string"
          },
          "algorithm": {
            "default": "sha256",
            "description": "Hashing algorithm.",
            "enum": [
              "sha256",
              "sha512"
            ],
            "type": "string"
          },
          "iteration_count": {
            "default": 4096,
            "description": "Iteration count.",
            "minimum": 0,
            "type": "integer"
          },
          "enable": {
            "default": true,
            "description": "Set to <code>true</code> or <code>false</code> to disable this auth provider.",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "plugins.plugin": {
        "required": [
          "running_status",
          "description",
          "rel_apps",
          "rel_vsn",
          "name"
        ],
        "properties": {
          "name": {
            "description": "Name-Vsn: without .tar.gz",
            "example": "emqx_plugin_template-5.0-rc.1",
            "type": "string"
          },
          "author": {
            "example": [
              "EMQX Team"
            ],
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "builder": {
            "$ref": "#/components/schemas/plugins.builder"
          },
          "built_on_otp_release": {
            "example": "24",
            "type": "string"
          },
          "compatibility": {
            "example": {
              "emqx": "~>5.0"
            },
            "type": "object"
          },
          "git_commit_or_build_date": {
            "description": "Last git commit date by `git log -1 --pretty=format:'%cd' --date=format:'%Y-%m-%d`.</br> If the last commit date is not available, the build date will be presented.",
            "example": "2021-12-25",
            "type": "string"
          },
          "functionality": {
            "example": [
              "Demo"
            ],
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "git_ref": {
            "example": "ddab50fafeed6b1faea70fc9ffd8c700d7e26ec1",
            "type": "string"
          },
          "metadata_vsn": {
            "example": "0.1.0",
            "type": "string"
          },
          "rel_vsn": {
            "description": "Plugins release version",
            "example": "5.0-rc.1",
            "type": "string"
          },
          "rel_apps": {
            "description": "Aplications in plugin.",
            "example": [
              "emqx_plugin_template-5.0.0",
              "map_sets-1.1.0"
            ],
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "repo": {
            "example": "https://github.com/emqx/emqx-plugin-template",
            "type": "string"
          },
          "description": {
            "description": "Plugin description.",
            "example": "This is an demo plugin description",
            "type": "string"
          },
          "running_status": {
            "items": {
              "$ref": "#/components/schemas/plugins.running_status"
            },
            "type": "array"
          },
          "readme": {
            "description": "only return when `GET /plugins/{name}`.",
            "example": "This is an demo plugin.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "zone.conn_congestion": {
        "properties": {
          "enable_alarm": {
            "description": "Enable or disable connection congestion alarm.",
            "type": "boolean"
          },
          "min_alarm_sustain_duration": {
            "description": "Minimal time before clearing the alarm.</br></br>The alarm is cleared only when there's no pending data in</br>the queue, and at least `min_alarm_sustain_duration`</br>milliseconds passed since the last time we considered the connection \"congested\".</br></br>This is to avoid clearing and raising the alarm again too often.",
            "example": "12m",
            "type": "string"
          }
        },
        "type": "object"
      },
      "emqx_authz_api_mnesia.rules_for_clientid": {
        "required": [
          "clientid"
        ],
        "properties": {
          "rules": {
            "items": {
              "$ref": "#/components/schemas/emqx_authz_api_mnesia.rule_item"
            },
            "type": "array"
          },
          "clientid": {
            "description": "ClientID",
            "example": "client1",
            "type": "string"
          }
        },
        "type": "object"
      },
      "broker.mqtt_quic_listener": {
        "required": [
          "bind"
        ],
        "properties": {
          "certfile": {
            "description": "</br>Path to the certificate file.</br>",
            "type": "string"
          },
          "keyfile": {
            "description": "</br>Path to the secret key file.</br>",
            "type": "string"
          },
          "ciphers": {
            "default": [
              "TLS_AES_256_GCM_SHA384",
              "TLS_AES_128_GCM_SHA256",
              "TLS_CHACHA20_POLY1305_SHA256"
            ],
            "description": "</br>This config holds TLS cipher suite names separated by comma,</br>or as an array of strings. e.g.</br><code>\"TLS_AES_256_GCM_SHA384,TLS_AES_128_GCM_SHA256\"</code> or</br><code>[\"TLS_AES_256_GCM_SHA384\",\"TLS_AES_128_GCM_SHA256\"]</code>.</br></br>Ciphers (and their ordering) define the way in which the</br>client and server encrypts information over the network connection.</br>Selecting a good cipher suite is critical for the</br>application's data security, confidentiality and performance.</br></br>The names should be in OpenSSL string format (not RFC format).</br>All default values and examples provided by EMQX config</br>documentation are all in OpenSSL format.</br></br>NOTE: Certain cipher suites are only compatible with</br>specific TLS <code>versions</code> ('tlsv1.1', 'tlsv1.2' or 'tlsv1.3')</br>incompatible cipher suites will be silently dropped.</br>For instance, if only 'tlsv1.3' is given in the <code>versions</code>,</br>configuring cipher suites for other versions will have no effect.</br></br></br>NOTE: PSK ciphers are suppressed by 'tlsv1.3' version config</br>If PSK cipher suites are intended, 'tlsv1.3' should be disabled from <code>versions</code>.</br>PSK cipher suites: <code>\"RSA-PSK-AES256-GCM-SHA384,RSA-PSK-AES256-CBC-SHA384,</br>RSA-PSK-AES128-GCM-SHA256,RSA-PSK-AES128-CBC-SHA256,</br>RSA-PSK-AES256-CBC-SHA,RSA-PSK-AES128-CBC-SHA,</br>RSA-PSK-DES-CBC3-SHA,RSA-PSK-RC4-SHA\"</code></br></br>NOTE: QUIC listener supports only 'tlsv1.3' ciphers</br>",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "idle_timeout": {
            "default": "15s",
            "description": "</br>Close transport-layer connections from the clients that have not sent MQTT CONNECT</br>message within this interval.</br>",
            "example": "12m",
            "type": "string"
          },
          "enabled": {
            "default": true,
            "description": "</br>Enable listener.</br>",
            "type": "boolean"
          },
          "bind": {
            "default": 14567,
            "description": "</br>IP address and port for the listening socket.</br>",
            "oneOf": [
              {
                "type": "integer"
              },
              {
                "example": "127.0.0.1:80",
                "type": "string"
              }
            ]
          },
          "acceptors": {
            "default": 16,
            "description": "</br>The size of the listener's receiving pool.</br>",
            "minimum": 1,
            "type": "integer"
          },
          "max_connections": {
            "default": "infinity",
            "description": "</br>The maximum number of concurrent connections allowed by the listener.</br>",
            "oneOf": [
              {
                "minimum": 1,
                "type": "integer"
              },
              {
                "enum": [
                  "infinity"
                ],
                "type": "string"
              }
            ]
          },
          "mountpoint": {
            "default": "",
            "description": "</br>When publishing or subscribing, prefix all topics with a mountpoint string.</br>The prefixed string will be removed from the topic name when the message</br>is delivered to the subscriber. The mountpoint is a way that users can use</br>to implement isolation of message routing between different listeners.</br>For example if a client A subscribes to `t` with `listeners.tcp.\\<name>.mountpoint`</br>set to `some_tenant`, then the client actually subscribes to the topic</br>`some_tenant/t`. Similarly, if another client B (connected to the same listener</br>as the client A) sends a message to topic `t`, the message is routed</br>to all the clients subscribed `some_tenant/t`, so client A will receive the</br>message, with topic name `t`.</br>Set to `\"\"` to disable the feature.</br></br>Variables in mountpoint string:</br>  - <code>${clientid}</code>: clientid</br>  - <code>${username}</code>: username</br>",
            "type": "string"
          },
          "zone": {
            "default": "default",
            "description": "</br>The configuration zone to which the listener belongs.</br>",
            "type": "string"
          },
          "limiter": {
            "default": {
              "connection": "default"
            },
            "description": "</br>Type of the rate limit.</br>",
            "properties": {
              "$ratelimit_name": {
                "example": "retainer",
                "type": "string"
              }
            },
            "type": "object"
          },
          "enable_authn": {
            "default": true,
            "description": "</br>Set <code>true</code> (default) to enable client authentication on this listener.</br>When set to <code>false</code> clients will be allowed to connect without authentication.</br>",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "emqx_rule_api_schema.ctx_pub": {
        "required": [
          "event_type"
        ],
        "properties": {
          "event_type": {
            "description": "Event Type",
            "enum": [
              "message_publish"
            ],
            "type": "string"
          },
          "id": {
            "description": "Message ID",
            "type": "string"
          },
          "clientid": {
            "description": "The Client ID",
            "type": "string"
          },
          "username": {
            "description": "The User Name",
            "type": "string"
          },
          "payload": {
            "description": "The Message Payload",
            "type": "string"
          },
          "peerhost": {
            "description": "The IP Address of the Peer Client",
            "type": "string"
          },
          "topic": {
            "description": "Message Topic",
            "type": "string"
          },
          "publish_received_at": {
            "description": "The Time that this Message is Received",
            "type": "integer"
          },
          "qos": {
            "description": "The Message QoS",
            "enum": [
              0,
              1,
              2
            ],
            "type": "string"
          }
        },
        "type": "object"
      },
      "emqx_gateway_api_clients.coap_client": {
        "properties": {
          "node": {
            "description": "Name of the node to which the client is connected",
            "type": "string"
          },
          "clientid": {
            "description": "Client ID",
            "type": "string"
          },
          "username": {
            "description": "Username of client when connecting",
            "type": "string"
          },
          "mountpoint": {
            "description": "Topic mountpoint",
            "type": "string"
          },
          "proto_name": {
            "description": "Client protocol name",
            "type": "string"
          },
          "proto_ver": {
            "description": "Protocol version used by the client",
            "type": "string"
          },
          "ip_address": {
            "description": "Client's IP address",
            "type": "string"
          },
          "port": {
            "description": "Client's port",
            "type": "integer"
          },
          "is_bridge": {
            "description": "Indicates whether the client is connected via bridge",
            "type": "boolean"
          },
          "connected_at": {
            "description": "Client connection time",
            "oneOf": [
              {
                "description": "epoch-millisecond",
                "example": 1640995200000,
                "type": "integer"
              },
              {
                "example": "2022-01-01T00:00:00.000Z",
                "format": "date-time",
                "type": "string"
              }
            ]
          },
          "disconnected_at": {
            "description": "Client offline time, This field is only valid and returned when connected is false",
            "oneOf": [
              {
                "description": "epoch-millisecond",
                "example": 1640995200000,
                "type": "integer"
              },
              {
                "example": "2022-01-01T00:00:00.000Z",
                "format": "date-time",
                "type": "string"
              }
            ]
          },
          "connected": {
            "description": "Whether the client is connected",
            "type": "boolean"
          },
          "keepalive": {
            "description": "Keepalive time, with the unit of second",
            "type": "integer"
          },
          "clean_start": {
            "description": "Indicate whether the client is using a brand new session",
            "type": "boolean"
          },
          "expiry_interval": {
            "description": "Session expiration interval, with the unit of second",
            "type": "integer"
          },
          "created_at": {
            "description": "Session creation time",
            "oneOf": [
              {
                "description": "epoch-millisecond",
                "example": 1640995200000,
                "type": "integer"
              },
              {
                "example": "2022-01-01T00:00:00.000Z",
                "format": "date-time",
                "type": "string"
              }
            ]
          },
          "subscriptions_cnt": {
            "description": "Number of subscriptions established by this client",
            "type": "integer"
          },
          "subscriptions_max": {
            "description": "Maximum number of subscriptions allowed by this client",
            "type": "integer"
          },
          "inflight_cnt": {
            "description": "Current length of inflight",
            "type": "integer"
          },
          "inflight_max": {
            "description": "Maximum length of inflight",
            "type": "integer"
          },
          "mqueue_len": {
            "description": "Current length of message queue",
            "type": "integer"
          },
          "mqueue_max": {
            "description": "Maximum length of message queue",
            "type": "integer"
          },
          "mqueue_dropped": {
            "description": "Number of messages dropped by the message queue due to exceeding the length",
            "type": "integer"
          },
          "awaiting_rel_cnt": {
            "description": "Number of awaiting acknowledge packet",
            "type": "integer"
          },
          "awaiting_rel_max": {
            "description": "Maximum allowed number of awaiting PUBREC packet",
            "type": "integer"
          },
          "recv_oct": {
            "description": "Number of bytes received",
            "type": "integer"
          },
          "recv_cnt": {
            "description": "Number of socket packets received",
            "type": "integer"
          },
          "recv_pkt": {
            "description": "Number of protocol packets received",
            "type": "integer"
          },
          "recv_msg": {
            "description": "Number of message packets received",
            "type": "integer"
          },
          "send_oct": {
            "description": "Number of bytes sent",
            "type": "integer"
          },
          "send_cnt": {
            "description": "Number of socket packets sent",
            "type": "integer"
          },
          "send_pkt": {
            "description": "Number of protocol packets sent",
            "type": "integer"
          },
          "send_msg": {
            "description": "Number of message packets sent",
            "type": "integer"
          },
          "mailbox_len": {
            "description": "Process mailbox size",
            "type": "integer"
          },
          "heap_size": {
            "description": "Process heap size with the unit of byte",
            "type": "integer"
          },
          "reductions": {
            "description": "Erlang reduction",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "emqx_mgmt_api_clients.authz_cache": {
        "properties": {
          "access": {
            "description": "Access type",
            "type": "string"
          },
          "result": {
            "description": "Allow or deny",
            "type": "string"
          },
          "topic": {
            "description": "Topic name",
            "type": "string"
          },
          "updated_time": {
            "description": "Update time",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "emqx_rule_api_schema.rule_test": {
        "required": [
          "sql"
        ],
        "properties": {
          "context": {
            "default": {},
            "description": "The context of the event for testing",
            "oneOf": [
              {
                "$ref": "#/components/schemas/emqx_rule_api_schema.ctx_bridge_mqtt"
              },
              {
                "$ref": "#/components/schemas/emqx_rule_api_schema.ctx_check_authz_complete"
              },
              {
                "$ref": "#/components/schemas/emqx_rule_api_schema.ctx_connack"
              },
              {
                "$ref": "#/components/schemas/emqx_rule_api_schema.ctx_disconnected"
              },
              {
                "$ref": "#/components/schemas/emqx_rule_api_schema.ctx_connected"
              },
              {
                "$ref": "#/components/schemas/emqx_rule_api_schema.ctx_dropped"
              },
              {
                "$ref": "#/components/schemas/emqx_rule_api_schema.ctx_acked"
              },
              {
                "$ref": "#/components/schemas/emqx_rule_api_schema.ctx_delivered"
              },
              {
                "$ref": "#/components/schemas/emqx_rule_api_schema.ctx_unsub"
              },
              {
                "$ref": "#/components/schemas/emqx_rule_api_schema.ctx_sub"
              },
              {
                "$ref": "#/components/schemas/emqx_rule_api_schema.ctx_pub"
              }
            ]
          },
          "sql": {
            "description": "The SQL of the rule for testing",
            "type": "string"
          }
        },
        "type": "object"
      },
      "slow_subs.slow_subs": {
        "properties": {
          "enable": {
            "default": false,
            "description": "Enable this feature",
            "type": "boolean"
          },
          "threshold": {
            "default": "500ms",
            "description": "The latency threshold for statistics",
            "example": "32s",
            "type": "string"
          },
          "expire_interval": {
            "default": "300s",
            "description": "The eviction time of the record, which in the statistics record table",
            "example": "32s",
            "type": "string"
          },
          "top_k_num": {
            "default": 10,
            "description": "The maximum number of records in the slow subscription statistics record table",
            "minimum": 1,
            "type": "integer"
          },
          "stats_type": {
            "default": "whole",
            "description": "The method to calculate the latency",
            "enum": [
              "whole",
              "internal",
              "response"
            ],
            "type": "string"
          }
        },
        "type": "object"
      },
      "emqx_rule_api_schema.ctx_dropped": {
        "required": [
          "event_type"
        ],
        "properties": {
          "event_type": {
            "description": "Event Type",
            "enum": [
              "message_dropped"
            ],
            "type": "string"
          },
          "id": {
            "description": "Message ID",
            "type": "string"
          },
          "reason": {
            "description": "The Reason for Dropping",
            "type": "string"
          },
          "clientid": {
            "description": "The Client ID",
            "type": "string"
          },
          "username": {
            "description": "The User Name",
            "type": "string"
          },
          "payload": {
            "description": "The Message Payload",
            "type": "string"
          },
          "peerhost": {
            "description": "The IP Address of the Peer Client",
            "type": "string"
          },
          "topic": {
            "description": "Message Topic",
            "type": "string"
          },
          "publish_received_at": {
            "description": "The Time that this Message is Received",
            "type": "integer"
          },
          "qos": {
            "description": "The Message QoS",
            "enum": [
              0,
              1,
              2
            ],
            "type": "string"
          }
        },
        "type": "object"
      },
      "broker.ws_opts": {
        "properties": {
          "mqtt_path": {
            "default": "/mqtt",
            "description": "</br>WebSocket's MQTT protocol path. So the address of EMQX Broker's WebSocket is:</br><code>ws://{ip}:{port}/mqtt</code></br>",
            "type": "string"
          },
          "mqtt_piggyback": {
            "default": "multiple",
            "description": "</br>Whether a WebSocket message is allowed to contain multiple MQTT packets.</br>",
            "enum": [
              "single",
              "multiple"
            ],
            "type": "string"
          },
          "compress": {
            "default": false,
            "description": "</br>If <code>true</code>, compress WebSocket messages using <code>zlib</code>.</br>The configuration items under <code>deflate_opts</code> belong to the compression-related parameter configuration.</br>",
            "type": "boolean"
          },
          "idle_timeout": {
            "default": "7200s",
            "description": "</br>Close transport-layer connections from the clients that have not sent MQTT CONNECT</br>message within this interval.</br>",
            "example": "12m",
            "type": "string"
          },
          "max_frame_size": {
            "default": "infinity",
            "description": "</br>The maximum length of a single MQTT packet.</br>",
            "oneOf": [
              {
                "type": "integer"
              },
              {
                "enum": [
                  "infinity"
                ],
                "type": "string"
              }
            ]
          },
          "fail_if_no_subprotocol": {
            "default": true,
            "description": "</br>If <code>true</code>, the server will return an error when</br> the client does not carry the <code>Sec-WebSocket-Protocol</code> field.</br> </br>Note: WeChat applet needs to disable this verification.</br>",
            "type": "boolean"
          },
          "supported_subprotocols": {
            "default": "mqtt, mqtt-v3, mqtt-v3.1.1, mqtt-v5",
            "description": "</br>Comma-separated list of supported subprotocols.</br>",
            "example": "item1,item2",
            "type": "string"
          },
          "check_origin_enable": {
            "default": false,
            "description": "</br>If <code>true</code>, <code>origin</code> HTTP header will be</br> validated against the list of allowed origins configured in <code>check_origins</code></br> parameter.</br>",
            "type": "boolean"
          },
          "allow_origin_absence": {
            "default": true,
            "description": "</br>If <code>false</code> and <code>check_origin_enable</code> is</br> <code>true</code>, the server will reject requests that don't have <code>origin</code></br> HTTP header.</br>",
            "type": "boolean"
          },
          "check_origins": {
            "default": "http://localhost:18083, http://127.0.0.1:18083",
            "description": "</br>List of allowed origins.</br>See <code>check_origin_enable</code>.</br>",
            "example": "item1,item2",
            "type": "string"
          },
          "proxy_address_header": {
            "default": "x-forwarded-for",
            "description": "</br>HTTP header used to pass information about the client IP address.</br>Relevant when the EMQX cluster is deployed behind a load-balancer.</br>",
            "type": "string"
          },
          "proxy_port_header": {
            "default": "x-forwarded-port",
            "description": "</br>HTTP header used to pass information about the client port.</br>Relevant when the EMQX cluster is deployed behind a load-balancer.</br>",
            "type": "string"
          },
          "deflate_opts": {
            "$ref": "#/components/schemas/broker.deflate_opts"
          }
        },
        "type": "object"
      },
      "dashboard.https": {
        "required": [
          "bind",
          "enable"
        ],
        "properties": {
          "enable": {
            "default": false,
            "description": "Ignore or enable this listener",
            "type": "boolean"
          },
          "bind": {
            "default": 18084,
            "description": "Port without IP(18083) or port with specified IP(127.0.0.1:18083).",
            "example": "0.0.0.0:18084",
            "oneOf": [
              {
                "example": "127.0.0.1:80",
                "type": "string"
              },
              {
                "minimum": 0,
                "type": "integer"
              }
            ]
          },
          "num_acceptors": {
            "default": 4,
            "description": "Socket acceptor pool size for TCP protocols.",
            "type": "integer"
          },
          "max_connections": {
            "default": 512,
            "description": "Maximum number of simultaneous connections.",
            "type": "integer"
          },
          "backlog": {
            "default": 1024,
            "description": "Defines the maximum length that the queue of pending connections can grow to.",
            "type": "integer"
          },
          "send_timeout": {
            "default": "5s",
            "description": "Send timeout for the socket.",
            "example": "12m",
            "type": "string"
          },
          "inet6": {
            "default": false,
            "description": "Enable IPv6 support, default is false, which means IPv4 only.",
            "type": "boolean"
          },
          "ipv6_v6only": {
            "default": false,
            "description": "Disable IPv4-to-IPv6 mapping for the listener.",
            "type": "boolean"
          },
          "cacertfile": {
            "description": "</br>Trusted PEM format CA certificates bundle file.</br>The certificates in this file are used to verify the TLS peer's certificates.</br>Append new certificates to the file if new CAs are to be trusted.</br>There is no need to restart EMQX to have the updated file loaded, because</br>the system regularly checks if file has been updated (and reload).</br>NOTE: invalidating (deleting) a certificate from the file will not affect</br>already established connections.</br>",
            "type": "string"
          },
          "certfile": {
            "description": "</br>PEM format certificates chain file.</br>The certificates in this file should be in reversed order of the certificate</br>issue chain. That is, the host's certificate should be placed in the beginning</br>of the file, followed by the immediate issuer certificate and so on.</br>Although the root CA certificate is optional, it should be placed at the end of</br>the file if it is to be added.</br>",
            "type": "string"
          },
          "keyfile": {
            "description": "</br>PEM format private key file.</br>",
            "type": "string"
          },
          "verify": {
            "default": "verify_none",
            "description": "</br>Enable or disable peer verification.</br>",
            "enum": [
              "verify_peer",
              "verify_none"
            ],
            "type": "string"
          },
          "reuse_sessions": {
            "default": true,
            "description": "</br>Enable TLS session reuse.</br>",
            "type": "boolean"
          },
          "depth": {
            "default": 10,
            "description": "</br>Maximum number of non-self-issued intermediate certificates that can follow the peer certificate in a valid certification path. So, if depth is 0 the PEER must be signed by the trusted ROOT-CA directly; if 1 the path can be PEER, CA, ROOT-CA; if 2 the path can be PEER, CA, CA, ROOT-CA, and so on. The default value is 10.</br>",
            "type": "integer"
          },
          "password": {
            "description": "</br>String containing the user's password.</br>Only used if the private key file is password-protected.</br>",
            "example": "",
            "type": "string"
          },
          "versions": {
            "default": [
              "tlsv1.3",
              "tlsv1.2",
              "tlsv1.1",
              "tlsv1"
            ],
            "description": "</br>All TLS/DTLS versions to be supported.</br>NOTE: PSK ciphers are suppressed by 'tlsv1.3' version config.</br>In case PSK cipher suites are intended, make sure to configured</br><code>['tlsv1.2', 'tlsv1.1']</code> here.</br>",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "ciphers": {
            "default": [
              "TLS_AES_256_GCM_SHA384",
              "TLS_AES_128_GCM_SHA256",
              "TLS_CHACHA20_POLY1305_SHA256",
              "TLS_AES_128_CCM_SHA256",
              "TLS_AES_128_CCM_8_SHA256",
              "ECDHE-ECDSA-AES256-GCM-SHA384",
              "ECDHE-RSA-AES256-GCM-SHA384",
              "ECDHE-ECDSA-AES256-SHA384",
              "ECDHE-RSA-AES256-SHA384",
              "ECDH-ECDSA-AES256-GCM-SHA384",
              "ECDH-RSA-AES256-GCM-SHA384",
              "ECDH-ECDSA-AES256-SHA384",
              "ECDH-RSA-AES256-SHA384",
              "DHE-DSS-AES256-GCM-SHA384",
              "DHE-DSS-AES256-SHA256",
              "AES256-GCM-SHA384",
              "AES256-SHA256",
              "ECDHE-ECDSA-AES128-GCM-SHA256",
              "ECDHE-RSA-AES128-GCM-SHA256",
              "ECDHE-ECDSA-AES128-SHA256",
              "ECDHE-RSA-AES128-SHA256",
              "ECDH-ECDSA-AES128-GCM-SHA256",
              "ECDH-RSA-AES128-GCM-SHA256",
              "ECDH-ECDSA-AES128-SHA256",
              "ECDH-RSA-AES128-SHA256",
              "DHE-DSS-AES128-GCM-SHA256",
              "DHE-DSS-AES128-SHA256",
              "AES128-GCM-SHA256",
              "AES128-SHA256",
              "ECDHE-ECDSA-AES256-SHA",
              "ECDHE-RSA-AES256-SHA",
              "DHE-DSS-AES256-SHA",
              "ECDH-ECDSA-AES256-SHA",
              "ECDH-RSA-AES256-SHA",
              "ECDHE-ECDSA-AES128-SHA",
              "ECDHE-RSA-AES128-SHA",
              "DHE-DSS-AES128-SHA",
              "ECDH-ECDSA-AES128-SHA",
              "ECDH-RSA-AES128-SHA",
              "RSA-PSK-AES256-GCM-SHA384",
              "RSA-PSK-AES256-CBC-SHA384",
              "RSA-PSK-AES128-GCM-SHA256",
              "RSA-PSK-AES128-CBC-SHA256",
              "RSA-PSK-AES256-CBC-SHA",
              "RSA-PSK-AES128-CBC-SHA"
            ],
            "description": "</br>This config holds TLS cipher suite names separated by comma,</br>or as an array of strings. e.g.</br><code>\"TLS_AES_256_GCM_SHA384,TLS_AES_128_GCM_SHA256\"</code> or</br><code>[\"TLS_AES_256_GCM_SHA384\",\"TLS_AES_128_GCM_SHA256\"]</code>.</br></br>Ciphers (and their ordering) define the way in which the</br>client and server encrypts information over the network connection.</br>Selecting a good cipher suite is critical for the</br>application's data security, confidentiality and performance.</br></br>The names should be in OpenSSL string format (not RFC format).</br>All default values and examples provided by EMQX config</br>documentation are all in OpenSSL format.</br></br>NOTE: Certain cipher suites are only compatible with</br>specific TLS <code>versions</code> ('tlsv1.1', 'tlsv1.2' or 'tlsv1.3')</br>incompatible cipher suites will be silently dropped.</br>For instance, if only 'tlsv1.3' is given in the <code>versions</code>,</br>configuring cipher suites for other versions will have no effect.</br></br></br>NOTE: PSK ciphers are suppressed by 'tlsv1.3' version config</br>If PSK cipher suites are intended, 'tlsv1.3' should be disabled from <code>versions</code>.</br>PSK cipher suites: <code>\"RSA-PSK-AES256-GCM-SHA384,RSA-PSK-AES256-CBC-SHA384,</br>RSA-PSK-AES128-GCM-SHA256,RSA-PSK-AES128-CBC-SHA256,</br>RSA-PSK-AES256-CBC-SHA,RSA-PSK-AES128-CBC-SHA,</br>RSA-PSK-DES-CBC3-SHA,RSA-PSK-RC4-SHA\"</code></br>",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "user_lookup_fun": {
            "default": "emqx_tls_psk:lookup",
            "description": "</br>EMQX-internal callback that is used to lookup pre-shared key (PSK) identity.</br>",
            "type": "string"
          },
          "secure_renegotiate": {
            "default": true,
            "description": "</br>SSL parameter renegotiation is a feature that allows a client and a server</br>to renegotiate the parameters of the SSL connection on the fly.</br>RFC 5746 defines a more secure way of doing this. By enabling secure renegotiation,</br>you drop support for the insecure renegotiation, prone to MitM attacks.</br>",
            "type": "boolean"
          },
          "dhfile": {
            "description": "</br>Path to a file containing PEM-encoded Diffie-Hellman parameters</br>to be used by the server if a cipher suite using Diffie-Hellman</br>key exchange is negotiated. If not specified, default parameters</br>are used.</br>NOTE: The <code>dhfile</code> option is not supported by TLS 1.3.</br>",
            "type": "string"
          },
          "honor_cipher_order": {
            "default": true,
            "description": "</br>An important security setting, it forces the cipher to be set based</br> on the server-specified order instead of the client-specified order,</br> hence enforcing the (usually more properly configured) security</br> ordering of the server administrator.</br>",
            "type": "boolean"
          },
          "client_renegotiation": {
            "default": true,
            "description": "</br>In protocols that support client-initiated renegotiation,</br>the cost of resources of such an operation is higher for the server than the client.</br>This can act as a vector for denial of service attacks.</br>The SSL application already takes measures to counter-act such attempts,</br>but client-initiated renegotiation can be strictly disabled by setting this option to false.</br>The default value is true. Note that disabling renegotiation can result in</br>long-lived connections becoming unusable due to limits on</br>the number of messages the underlying cipher suite can encipher.</br>",
            "type": "boolean"
          },
          "handshake_timeout": {
            "default": "15s",
            "description": "</br>Maximum time duration allowed for the handshake to complete</br>",
            "example": "12m",
            "type": "string"
          }
        },
        "type": "object"
      },
      "gateway.exproto_grpc_server": {
        "required": [
          "bind"
        ],
        "properties": {
          "bind": {
            "description": "Listening address and port for the gRPC server.",
            "oneOf": [
              {
                "type": "integer"
              },
              {
                "example": "127.0.0.1:80",
                "type": "string"
              }
            ]
          },
          "ssl_options": {
            "description": "SSL configuration for the gRPC server.",
            "$ref": "#/components/schemas/gateway.ssl_server_opts"
          }
        },
        "type": "object"
      },
      "emqx_conf_schema.log_rotation": {
        "properties": {
          "enable": {
            "default": true,
            "description": "Enable log rotation feature.",
            "type": "boolean"
          },
          "count": {
            "default": 10,
            "description": "Maximum number of log files.",
            "maximum": 2048,
            "minimum": 1,
            "type": "integer"
          }
        },
        "type": "object"
      },
      "emqx_authz_api_schema.mongo_single": {
        "required": [
          "database",
          "server",
          "mongo_type",
          "collection",
          "type"
        ],
        "properties": {
          "enable": {
            "default": true,
            "description": "Set to <code>true</code> or <code>false</code> to disable this ACL provider",
            "type": "boolean"
          },
          "type": {
            "default": "mongodb",
            "description": "Backend type.",
            "enum": [
              "mongodb"
            ],
            "type": "string"
          },
          "collection": {
            "description": "`MongoDB` collection containing the authorization data.",
            "type": "string"
          },
          "filter": {
            "default": {},
            "description": "</br>Conditional expression that defines the filter condition in the query.</br>Filter supports the following placeholders:</br> - <code>${username}</code>: Will be replaced at runtime with <code>Username</code> used by the client when connecting</br> - <code>${clientid}</code>: Will be replaced at runtime with <code>Client ID</code> used by the client when connecting</br>",
            "example": {},
            "type": "object"
          },
          "mongo_type": {
            "default": "single",
            "description": "Standalone instance.",
            "enum": [
              "single"
            ],
            "type": "string"
          },
          "server": {
            "description": "</br>The IPv4 or IPv6 address or the hostname to connect to.</br>A host entry has the following form: `Host[:Port]`.</br>The MongoDB default port 27017 is used if `[:Port]` is not specified.</br>",
            "example": "127.0.0.1:80",
            "type": "string"
          },
          "w_mode": {
            "default": "unsafe",
            "description": "Write mode.",
            "enum": [
              "unsafe",
              "safe"
            ],
            "type": "string"
          },
          "srv_record": {
            "default": false,
            "description": "Use DNS SRV record.",
            "type": "boolean"
          },
          "pool_size": {
            "default": 8,
            "description": "Size of the connection pool.",
            "minimum": 1,
            "type": "integer"
          },
          "username": {
            "description": "EMQX's username in the external database.",
            "type": "string"
          },
          "password": {
            "description": "EMQX's password in the external database.",
            "type": "string"
          },
          "auth_source": {
            "description": "Database name associated with the user's credentials.",
            "type": "string"
          },
          "database": {
            "description": "Database name.",
            "type": "string"
          },
          "topology": {
            "$ref": "#/components/schemas/emqx_connector_mongo.topology"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/broker.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "emqx_authn_schema.node_metrics": {
        "properties": {
          "node": {
            "description": "Node name.",
            "example": "emqx@127.0.0.1",
            "type": "string"
          },
          "metrics": {
            "description": "The metrics of the resource.",
            "$ref": "#/components/schemas/emqx_authn_schema.metrics"
          }
        },
        "type": "object"
      },
      "broker.mqtt_wss_listener": {
        "required": [
          "bind"
        ],
        "properties": {
          "enabled": {
            "default": true,
            "description": "</br>Enable listener.</br>",
            "type": "boolean"
          },
          "bind": {
            "default": 8084,
            "description": "</br>IP address and port for the listening socket.</br>",
            "oneOf": [
              {
                "type": "integer"
              },
              {
                "example": "127.0.0.1:80",
                "type": "string"
              }
            ]
          },
          "acceptors": {
            "default": 16,
            "description": "</br>The size of the listener's receiving pool.</br>",
            "minimum": 1,
            "type": "integer"
          },
          "max_connections": {
            "default": "infinity",
            "description": "</br>The maximum number of concurrent connections allowed by the listener.</br>",
            "oneOf": [
              {
                "minimum": 1,
                "type": "integer"
              },
              {
                "enum": [
                  "infinity"
                ],
                "type": "string"
              }
            ]
          },
          "mountpoint": {
            "default": "",
            "description": "</br>When publishing or subscribing, prefix all topics with a mountpoint string.</br>The prefixed string will be removed from the topic name when the message</br>is delivered to the subscriber. The mountpoint is a way that users can use</br>to implement isolation of message routing between different listeners.</br>For example if a client A subscribes to `t` with `listeners.tcp.\\<name>.mountpoint`</br>set to `some_tenant`, then the client actually subscribes to the topic</br>`some_tenant/t`. Similarly, if another client B (connected to the same listener</br>as the client A) sends a message to topic `t`, the message is routed</br>to all the clients subscribed `some_tenant/t`, so client A will receive the</br>message, with topic name `t`.</br>Set to `\"\"` to disable the feature.</br></br>Variables in mountpoint string:</br>  - <code>${clientid}</code>: clientid</br>  - <code>${username}</code>: username</br>",
            "type": "string"
          },
          "zone": {
            "default": "default",
            "description": "</br>The configuration zone to which the listener belongs.</br>",
            "type": "string"
          },
          "limiter": {
            "default": {
              "connection": "default"
            },
            "description": "</br>Type of the rate limit.</br>",
            "properties": {
              "$ratelimit_name": {
                "example": "retainer",
                "type": "string"
              }
            },
            "type": "object"
          },
          "enable_authn": {
            "default": true,
            "description": "</br>Set <code>true</code> (default) to enable client authentication on this listener.</br>When set to <code>false</code> clients will be allowed to connect without authentication.</br>",
            "type": "boolean"
          },
          "access_rules": {
            "default": [
              "allow all"
            ],
            "description": "</br>The access control rules for this listener.</br>See: https://github.com/emqtt/esockd#allowdeny</br>",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "proxy_protocol": {
            "default": false,
            "description": "</br>Enable the Proxy Protocol V1/2 if the EMQX cluster is deployed behind HAProxy or Nginx.</br>See: https://www.haproxy.com/blog/haproxy/proxy-protocol/</br>",
            "type": "boolean"
          },
          "proxy_protocol_timeout": {
            "default": "3s",
            "description": "</br>Timeout for proxy protocol. EMQX will close the TCP connection if proxy protocol packet is not received within the timeout.</br>",
            "example": "12m",
            "type": "string"
          },
          "authentication": {
            "description": "</br>Per-listener authentication override.</br>Authentication can be one single authenticator instance or a chain of authenticators as an array.</br>When authenticating a login (username, client ID, etc.) the authenticators are checked in the configured order.</br></br>",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/authn-scram-builtin_db.authentication"
                },
                {
                  "$ref": "#/components/schemas/authn-jwt.jwks"
                },
                {
                  "$ref": "#/components/schemas/authn-jwt.public-key"
                },
                {
                  "$ref": "#/components/schemas/authn-jwt.hmac-based"
                },
                {
                  "$ref": "#/components/schemas/authn-http.post"
                },
                {
                  "$ref": "#/components/schemas/authn-http.get"
                },
                {
                  "$ref": "#/components/schemas/authn-redis.sentinel"
                },
                {
                  "$ref": "#/components/schemas/authn-redis.cluster"
                },
                {
                  "$ref": "#/components/schemas/authn-redis.standalone"
                },
                {
                  "$ref": "#/components/schemas/authn-mongodb.sharded-cluster"
                },
                {
                  "$ref": "#/components/schemas/authn-mongodb.replica-set"
                },
                {
                  "$ref": "#/components/schemas/authn-mongodb.standalone"
                },
                {
                  "$ref": "#/components/schemas/authn-postgresql.authentication"
                },
                {
                  "$ref": "#/components/schemas/authn-mysql.authentication"
                },
                {
                  "$ref": "#/components/schemas/authn-builtin_db.authentication"
                }
              ]
            },
            "type": "array"
          },
          "tcp_options": {
            "$ref": "#/components/schemas/broker.tcp_opts"
          },
          "ssl_options": {
            "$ref": "#/components/schemas/broker.listener_wss_opts"
          },
          "websocket": {
            "$ref": "#/components/schemas/broker.ws_opts"
          }
        },
        "type": "object"
      },
      "emqx_gateway_api.dtls_listener": {
        "properties": {
          "id": {
            "description": "Listener ID",
            "type": "string"
          },
          "type": {
            "description": "Listener Type",
            "enum": [
              "dtls"
            ],
            "type": "string"
          },
          "name": {
            "description": "Listener Name",
            "type": "string"
          },
          "running": {
            "description": "Listener Running status",
            "type": "boolean"
          },
          "acceptors": {
            "default": 16,
            "description": "Size of the acceptor pool.",
            "type": "integer"
          },
          "udp_options": {
            "$ref": "#/components/schemas/gateway.udp_opts"
          },
          "enable": {
            "default": true,
            "description": "Enable the listener.",
            "type": "boolean"
          },
          "bind": {
            "description": "The IP address and port that the listener will bind.",
            "oneOf": [
              {
                "type": "integer"
              },
              {
                "example": "127.0.0.1:80",
                "type": "string"
              }
            ]
          },
          "max_connections": {
            "default": 1024,
            "description": "Maximum number of concurrent connections.",
            "type": "integer"
          },
          "max_conn_rate": {
            "default": 1000,
            "description": "Maximum connections per second.",
            "type": "integer"
          },
          "authentication": {
            "description": "Default authentication configs for all the gateway listeners. For per-listener overrides see <code>authentication</code></br> in listener configs",
            "oneOf": [
              {
                "$ref": "#/components/schemas/authn-scram-builtin_db.authentication"
              },
              {
                "$ref": "#/components/schemas/authn-jwt.jwks"
              },
              {
                "$ref": "#/components/schemas/authn-jwt.public-key"
              },
              {
                "$ref": "#/components/schemas/authn-jwt.hmac-based"
              },
              {
                "$ref": "#/components/schemas/authn-http.post"
              },
              {
                "$ref": "#/components/schemas/authn-http.get"
              },
              {
                "$ref": "#/components/schemas/authn-redis.sentinel"
              },
              {
                "$ref": "#/components/schemas/authn-redis.cluster"
              },
              {
                "$ref": "#/components/schemas/authn-redis.standalone"
              },
              {
                "$ref": "#/components/schemas/authn-mongodb.sharded-cluster"
              },
              {
                "$ref": "#/components/schemas/authn-mongodb.replica-set"
              },
              {
                "$ref": "#/components/schemas/authn-mongodb.standalone"
              },
              {
                "$ref": "#/components/schemas/authn-postgresql.authentication"
              },
              {
                "$ref": "#/components/schemas/authn-mysql.authentication"
              },
              {
                "$ref": "#/components/schemas/authn-builtin_db.authentication"
              }
            ]
          },
          "enable_authn": {
            "default": true,
            "description": "Set <code>true</code> (default) to enable client authentication on this listener. </br>When set to <code>false</code> clients will be allowed to connect without authentication.",
            "type": "boolean"
          },
          "mountpoint": {
            "description": "When publishing or subscribing, prefix all topics with a mountpoint string.</br>The prefixed string will be removed from the topic name when the message is delivered to the subscriber. The mountpoint is a way that users can use to implement isolation of message routing between different listeners.</br>For example if a client A subscribes to `t` with `listeners.tcp.\\<name>.mountpoint` set to `some_tenant`, then the client actually subscribes to the topic `some_tenant/t`. Similarly, if another client B (connected to the same listener as the client A) sends a message to topic `t`, the message is routed to all the clients subscribed `some_tenant/t`, so client A will receive the message, with topic name `t`. Set to `\"\"` to disable the feature.</br>Variables in mountpoint string:</br>  - <code>${clientid}</code>: clientid</br>  - <code>${username}</code>: username</br>",
            "type": "string"
          },
          "access_rules": {
            "default": "",
            "description": "The access control rules for this listener.</br>See: https://github.com/emqtt/esockd#allowdeny",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "dtls_options": {
            "description": "DTLS socket options",
            "$ref": "#/components/schemas/gateway.dtls_opts"
          }
        },
        "type": "object"
      },
      "bridge.post": {
        "required": [
          "url",
          "name",
          "type"
        ],
        "properties": {
          "type": {
            "description": "The Bridge Type",
            "enum": [
              "webhook"
            ],
            "type": "string"
          },
          "name": {
            "description": "Bridge name, used as a human-readable description of the bridge.",
            "type": "string"
          },
          "enable": {
            "default": true,
            "description": "Enable or disable this bridge",
            "type": "boolean"
          },
          "direction": {
            "default": "egress",
            "description": "The direction of this bridge, MUST be 'egress'",
            "enum": [
              "egress"
            ],
            "type": "string"
          },
          "connect_timeout": {
            "default": "15s",
            "description": "The timeout when connecting to the HTTP server.",
            "example": "32s",
            "type": "string"
          },
          "max_retries": {
            "default": 5,
            "description": "Max retry times if error on sending request.",
            "minimum": 0,
            "type": "integer"
          },
          "retry_interval": {
            "default": "1s",
            "description": "Interval between retries.",
            "example": "12m",
            "type": "string"
          },
          "pool_type": {
            "default": "random",
            "description": "The type of the pool. Can be one of `random`, `hash`.",
            "enum": [
              "random",
              "hash"
            ],
            "type": "string"
          },
          "pool_size": {
            "default": 8,
            "description": "The pool size.",
            "minimum": 1,
            "type": "integer"
          },
          "enable_pipelining": {
            "default": 100,
            "description": "Whether to send HTTP requests continuously, when set to 0, it means that after each HTTP request is sent, you need to wait for the server to return and then continue to send the next request.",
            "minimum": 1,
            "type": "integer"
          },
          "request": {
            "description": "</br>If the request is provided, the caller can send HTTP requests via</br><code>emqx_resource:query(ResourceId, {send_message, BridgeId, Message})</code></br>",
            "$ref": "#/components/schemas/connector-http.request"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/broker.ssl_client_opts"
          },
          "url": {
            "description": "</br>The URL of the HTTP Bridge.</br>Template with variables is allowed in the path, but variables cannot be used in the scheme, host,</br>or port part.</br>For example, <code> http://localhost:9901/${topic} </code> is allowed, but</br><code> http://${host}:9901/message </code> or <code> http://localhost:${port}/message </code></br>is not allowed.</br>",
            "type": "string"
          },
          "local_topic": {
            "description": "</br>The MQTT topic filter to be forwarded to the HTTP server. All MQTT 'PUBLISH' messages with the topic</br>matching the local_topic will be forwarded.</br>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is</br>configured, then both the data got from the rule and the MQTT messages that match local_topic</br>will be forwarded.</br>",
            "type": "string"
          },
          "method": {
            "default": "post",
            "description": "</br>The method of the HTTP request. All the available methods are: post, put, get, delete.</br>Template with variables is allowed.</br>",
            "enum": [
              "post",
              "put",
              "get",
              "delete"
            ],
            "type": "string"
          },
          "headers": {
            "default": {
              "accept": "application/json",
              "cache-control": "no-cache",
              "connection": "keep-alive",
              "content-type": "application/json",
              "keep-alive": "timeout=5"
            },
            "description": "</br>The headers of the HTTP request.</br>Template with variables is allowed.</br>",
            "example": {},
            "type": "object"
          },
          "body": {
            "default": "${payload}",
            "description": "</br>The body of the HTTP request.</br>Template with variables is allowed.</br>",
            "type": "string"
          },
          "request_timeout": {
            "default": "15s",
            "description": "HTTP request timeout.",
            "example": "32s",
            "type": "string"
          }
        },
        "type": "object"
      },
      "authn-builtin_db.authentication": {
        "required": [
          "user_id_type",
          "backend",
          "mechanism"
        ],
        "properties": {
          "mechanism": {
            "description": "Authentication mechanism.",
            "enum": [
              "password_based"
            ],
            "type": "string"
          },
          "backend": {
            "description": "Backend type.",
            "enum": [
              "built_in_database"
            ],
            "type": "string"
          },
          "user_id_type": {
            "default": "username",
            "description": "Specify whether to use `clientid` or `username` for authentication.",
            "enum": [
              "clientid",
              "username"
            ],
            "type": "string"
          },
          "password_hash_algorithm": {
            "default": {
              "name": "sha256",
              "salt_position": "prefix"
            },
            "description": "Options for password hash creation and verification.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/authn-hash.other_algorithms"
              },
              {
                "$ref": "#/components/schemas/authn-hash.pbkdf2"
              },
              {
                "$ref": "#/components/schemas/authn-hash.bcrypt_rw"
              }
            ]
          },
          "enable": {
            "default": true,
            "description": "Set to <code>true</code> or <code>false</code> to disable this auth provider.",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "authn-jwt.ssl_enable": {
        "properties": {
          "enable": {
            "description": "Enable/disable SSL.",
            "enum": [
              true
            ],
            "type": "string"
          },
          "cacertfile": {
            "description": "Path to a file containing PEM-encoded CA certificates.",
            "type": "string"
          },
          "certfile": {
            "description": "Path to a file containing the user certificate.",
            "type": "string"
          },
          "keyfile": {
            "description": "Path to a file containing the user's private PEM-encoded key.",
            "type": "string"
          },
          "verify": {
            "default": "verify_none",
            "description": "Enable or disable SSL peer verification.",
            "enum": [
              "verify_peer",
              "verify_none"
            ],
            "type": "string"
          },
          "server_name_indication": {
            "description": "Server Name Indication (SNI).",
            "type": "string"
          }
        },
        "type": "object"
      },
      "dashboard.user": {
        "properties": {
          "username": {
            "description": "Dashboard Username",
            "example": "admin",
            "maxLength": 100,
            "type": "string"
          },
          "description": {
            "description": "Dashboard User Description",
            "example": "administrator",
            "type": "string"
          }
        },
        "type": "object"
      },
      "emqx_gateway_api_clients.lwm2m_client": {
        "properties": {
          "endpoint_name": {
            "description": "The LwM2M client endpoint name",
            "type": "string"
          },
          "lifetime": {
            "description": "LwM2M Life time",
            "type": "integer"
          },
          "node": {
            "description": "Name of the node to which the client is connected",
            "type": "string"
          },
          "clientid": {
            "description": "Client ID",
            "type": "string"
          },
          "username": {
            "description": "Username of client when connecting",
            "type": "string"
          },
          "mountpoint": {
            "description": "Topic mountpoint",
            "type": "string"
          },
          "proto_name": {
            "description": "Client protocol name",
            "type": "string"
          },
          "proto_ver": {
            "description": "Protocol version used by the client",
            "type": "string"
          },
          "ip_address": {
            "description": "Client's IP address",
            "type": "string"
          },
          "port": {
            "description": "Client's port",
            "type": "integer"
          },
          "is_bridge": {
            "description": "Indicates whether the client is connected via bridge",
            "type": "boolean"
          },
          "connected_at": {
            "description": "Client connection time",
            "oneOf": [
              {
                "description": "epoch-millisecond",
                "example": 1640995200000,
                "type": "integer"
              },
              {
                "example": "2022-01-01T00:00:00.000Z",
                "format": "date-time",
                "type": "string"
              }
            ]
          },
          "disconnected_at": {
            "description": "Client offline time, This field is only valid and returned when connected is false",
            "oneOf": [
              {
                "description": "epoch-millisecond",
                "example": 1640995200000,
                "type": "integer"
              },
              {
                "example": "2022-01-01T00:00:00.000Z",
                "format": "date-time",
                "type": "string"
              }
            ]
          },
          "connected": {
            "description": "Whether the client is connected",
            "type": "boolean"
          },
          "keepalive": {
            "description": "Keepalive time, with the unit of second",
            "type": "integer"
          },
          "clean_start": {
            "description": "Indicate whether the client is using a brand new session",
            "type": "boolean"
          },
          "expiry_interval": {
            "description": "Session expiration interval, with the unit of second",
            "type": "integer"
          },
          "created_at": {
            "description": "Session creation time",
            "oneOf": [
              {
                "description": "epoch-millisecond",
                "example": 1640995200000,
                "type": "integer"
              },
              {
                "example": "2022-01-01T00:00:00.000Z",
                "format": "date-time",
                "type": "string"
              }
            ]
          },
          "subscriptions_cnt": {
            "description": "Number of subscriptions established by this client",
            "type": "integer"
          },
          "subscriptions_max": {
            "description": "Maximum number of subscriptions allowed by this client",
            "type": "integer"
          },
          "inflight_cnt": {
            "description": "Current length of inflight",
            "type": "integer"
          },
          "inflight_max": {
            "description": "Maximum length of inflight",
            "type": "integer"
          },
          "mqueue_len": {
            "description": "Current length of message queue",
            "type": "integer"
          },
          "mqueue_max": {
            "description": "Maximum length of message queue",
            "type": "integer"
          },
          "mqueue_dropped": {
            "description": "Number of messages dropped by the message queue due to exceeding the length",
            "type": "integer"
          },
          "awaiting_rel_cnt": {
            "description": "Number of awaiting acknowledge packet",
            "type": "integer"
          },
          "awaiting_rel_max": {
            "description": "Maximum allowed number of awaiting PUBREC packet",
            "type": "integer"
          },
          "recv_oct": {
            "description": "Number of bytes received",
            "type": "integer"
          },
          "recv_cnt": {
            "description": "Number of socket packets received",
            "type": "integer"
          },
          "recv_pkt": {
            "description": "Number of protocol packets received",
            "type": "integer"
          },
          "recv_msg": {
            "description": "Number of message packets received",
            "type": "integer"
          },
          "send_oct": {
            "description": "Number of bytes sent",
            "type": "integer"
          },
          "send_cnt": {
            "description": "Number of socket packets sent",
            "type": "integer"
          },
          "send_pkt": {
            "description": "Number of protocol packets sent",
            "type": "integer"
          },
          "send_msg": {
            "description": "Number of message packets sent",
            "type": "integer"
          },
          "mailbox_len": {
            "description": "Process mailbox size",
            "type": "integer"
          },
          "heap_size": {
            "description": "Process heap size with the unit of byte",
            "type": "integer"
          },
          "reductions": {
            "description": "Erlang reduction",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "emqx_conf_schema.node": {
        "required": [
          "data_dir"
        ],
        "properties": {
          "name": {
            "default": "emqx@127.0.0.1",
            "description": "Unique name of the EMQX node. It must follow <code>%name%@FQDN</code> or</br><code>%name%@IPv4</code> format.</br>          ",
            "readOnly": true,
            "type": "string"
          },
          "cookie": {
            "default": "emqxsecretcookie",
            "description": "Secret cookie is a random string that should be the same on all nodes in</br>the given EMQX cluster, but unique per EMQX cluster. It is used to prevent EMQX nodes that</br>belong to different clusters from accidentally connecting to each other.",
            "readOnly": true,
            "type": "string"
          },
          "process_limit": {
            "default": 2097152,
            "description": "Maximum number of simultaneously existing processes for this Erlang system.</br>The actual maximum chosen may be much larger than the Number passed.</br>For more information, see: https://www.erlang.org/doc/man/erl.html</br>          ",
            "maximum": 134217727,
            "minimum": 1024,
            "readOnly": true,
            "type": "integer"
          },
          "max_ports": {
            "default": 1048576,
            "description": "Maximum number of simultaneously existing ports for this Erlang system.</br>The actual maximum chosen may be much larger than the Number passed.</br>For more information, see: https://www.erlang.org/doc/man/erl.html</br>          ",
            "maximum": 134217727,
            "minimum": 1024,
            "readOnly": true,
            "type": "integer"
          },
          "dist_buffer_size": {
            "default": 8192,
            "description": "Erlang's distribution buffer busy limit in kilobytes.",
            "maximum": 2097151,
            "minimum": 1,
            "readOnly": true,
            "type": "integer"
          },
          "max_ets_tables": {
            "default": 262144,
            "description": "Max number of ETS tables",
            "minimum": 1,
            "readOnly": true,
            "type": "integer"
          },
          "data_dir": {
            "description": "</br>Path to the persistent data directory.</br>Possible auto-created subdirectories are:</br>- `mnesia/<node_name>`: EMQX's built-in database directory.</br>For example, `mnesia/emqx@127.0.0.1`.</br>There should be only one such subdirectory.</br>Meaning, in case the node is to be renamed (to e.g. `emqx@10.0.1.1`),</br>the old dir should be deleted first.</br>- `configs`: Generated configs at boot time, and cluster/local override configs.</br>- `patches`: Hot-patch beam files are to be placed here.</br>- `trace`: Trace log files.</br></br>**NOTE**: One data dir cannot be shared by two or more EMQX nodes.</br>",
            "readOnly": true,
            "type": "string"
          },
          "config_files": {
            "description": "List of configuration files that are read during startup. The order is</br>significant: later configuration files override the previous ones.</br>          ",
            "items": {
              "type": "string"
            },
            "readOnly": true,
            "type": "array"
          },
          "global_gc_interval": {
            "default": "15m",
            "description": "Periodic garbage collection interval.",
            "example": "12m",
            "readOnly": true,
            "type": "string"
          },
          "crash_dump_file": {
            "default": "log/erl_crash.dump",
            "description": "Location of the crash dump file.",
            "example": "/path/to/file",
            "readOnly": true,
            "type": "string"
          },
          "crash_dump_seconds": {
            "default": "30s",
            "description": "The number of seconds that the broker is allowed to spend writing a crash dump.",
            "example": "1h",
            "readOnly": true,
            "type": "string"
          },
          "crash_dump_bytes": {
            "default": "100MB",
            "description": "The maximum size of a crash dump file in bytes.",
            "example": "32MB",
            "readOnly": true,
            "type": "string"
          },
          "dist_net_ticktime": {
            "default": "2m",
            "description": "This is the approximate time an EMQX node may be unresponsive until it is considered down and thereby disconnected.",
            "example": "1h",
            "readOnly": true,
            "type": "string"
          },
          "backtrace_depth": {
            "default": 23,
            "description": "Maximum depth of the call stack printed in error messages and</br><code>process_info</code>.</br>          ",
            "readOnly": true,
            "type": "integer"
          },
          "applications": {
            "default": "",
            "description": "List of Erlang applications that shall be rebooted when the EMQX broker joins the cluster.</br>          ",
            "example": "item1,item2",
            "readOnly": true,
            "type": "string"
          },
          "etc_dir": {
            "description": "<code>etc</code> dir for the node",
            "readOnly": true,
            "type": "string"
          },
          "cluster_call": {
            "readOnly": true,
            "$ref": "#/components/schemas/emqx_conf_schema.cluster_call"
          },
          "db_backend": {
            "default": "rlog",
            "description": "</br>Select the backend for the embedded database.</br><code>rlog</code> is the default backend,</br>that is suitable for very large clusters.</br><code>mnesia</code> is a backend that offers decent performance in small clusters.</br>",
            "enum": [
              "mnesia",
              "rlog"
            ],
            "readOnly": true,
            "type": "string"
          },
          "db_role": {
            "default": "core",
            "description": "</br>Select a node role.</br><code>core</code> nodes provide durability of the data, and take care of writes.</br>It is recommended to place core nodes in different racks or different availability zones.</br><code>replicant</code> nodes are ephemeral worker nodes. Removing them from the cluster</br>doesn't affect database redundancy</br>It is recommended to have more replicant nodes than core nodes.</br>Note: this parameter only takes effect when the <code>backend</code> is set</br>to <code>rlog</code>.</br>",
            "enum": [
              "core",
              "replicant"
            ],
            "readOnly": true,
            "type": "string"
          },
          "rpc_module": {
            "default": "gen_rpc",
            "description": "Protocol used for pushing transaction logs to the replicant nodes.",
            "enum": [
              "gen_rpc",
              "rpc"
            ],
            "readOnly": true,
            "type": "string"
          },
          "tlog_push_mode": {
            "default": "async",
            "description": "</br>In sync mode the core node waits for an ack from the replicant nodes before sending the next</br>transaction log entry.</br>",
            "enum": [
              "sync",
              "async"
            ],
            "readOnly": true,
            "type": "string"
          },
          "default_shard_transport": {
            "default": "gen_rpc",
            "description": "Defines the default transport for pushing transaction logs.</br>This may be overridden on a per-shard basis in <code>db.shard_transports</code>.</br><code>gen_rpc</code> uses the <code>gen_rpc</code> library,</br><code>distr</code> uses the Erlang distribution.</br>",
            "enum": [
              "gen_rpc",
              "distr"
            ],
            "type": "string"
          },
          "shard_transports": {
            "default": {},
            "description": "Allows to tune the transport method used for transaction log replication, on a per-shard basis.</br><code>gen_rpc</code> uses the <code>gen_rpc</code> library,</br><code>distr</code> uses the Erlang distribution.</br>If not specified,</br>the default is to use the value set in <code>db.default_shard_transport</code>.",
            "properties": {
              "$shard": {
                "enum": [
                  "gen_rpc",
                  "distr"
                ],
                "type": "string"
              }
            },
            "type": "object"
          }
        },
        "type": "object"
      },
      "auto_subscribe.topic": {
        "required": [
          "topic"
        ],
        "properties": {
          "topic": {
            "description": "Topic name, placeholders are supported. For example: client/${clientid}/username/${username}/host/${host}/port/${port}</br>Required field, and cannot be empty string",
            "example": "/clientid/${clientid}/username/${username}/host/${host}/port/${port}",
            "type": "string"
          },
          "qos": {
            "default": 0,
            "description": "Default value 0. Quality of service.</br>At most once (0)</br>At least once (1)</br>Exactly once (2)",
            "enum": [
              0,
              1,
              2
            ],
            "type": "string"
          },
          "rh": {
            "default": 0,
            "description": "Default value 0. This option is used to specify whether the server forwards the retained message to the client when establishing a subscription.</br>Retain Handling is equal to 0, as long as the client successfully subscribes, the server will send the retained message.</br>Retain Handling is equal to 1, if the client successfully subscribes and this subscription does not exist previously, the server sends the retained message. After all, sometimes the client re-initiate the subscription just to change the QoS, but it does not mean that it wants to receive the reserved messages again.</br>Retain Handling is equal to 2, even if the client successfully subscribes, the server does not send the retained message.",
            "maximum": 2,
            "minimum": 0,
            "type": "integer"
          },
          "rap": {
            "default": 0,
            "description": "Default value 0. This option is used to specify whether the server retains the RETAIN mark when forwarding messages to the client, and this option does not affect the RETAIN mark in the retained message. Therefore, when the option Retain As Publish is set to 0, the client will directly distinguish whether this is a normal forwarded message or a retained message according to the RETAIN mark in the message, instead of judging whether this message is the first received after subscribing(the forwarded message may be sent before the retained message, which depends on the specific implementation of different brokers).",
            "maximum": 1,
            "minimum": 0,
            "type": "integer"
          },
          "nl": {
            "default": 0,
            "description": "Default value 0.</br>MQTT v3.1.1： if you subscribe to the topic published by yourself, you will receive all messages that you published.</br>MQTT v5: if you set this option as 1 when subscribing, the server will not forward the message you published to you.",
            "maximum": 1,
            "minimum": 0,
            "type": "integer"
          }
        },
        "type": "object"
      },
      "broker.listener_ssl_opts": {
        "properties": {
          "cacertfile": {
            "description": "</br>Trusted PEM format CA certificates bundle file.</br>The certificates in this file are used to verify the TLS peer's certificates.</br>Append new certificates to the file if new CAs are to be trusted.</br>There is no need to restart EMQX to have the updated file loaded, because</br>the system regularly checks if file has been updated (and reload).</br>NOTE: invalidating (deleting) a certificate from the file will not affect</br>already established connections.</br>",
            "type": "string"
          },
          "certfile": {
            "description": "</br>PEM format certificates chain file.</br>The certificates in this file should be in reversed order of the certificate</br>issue chain. That is, the host's certificate should be placed in the beginning</br>of the file, followed by the immediate issuer certificate and so on.</br>Although the root CA certificate is optional, it should be placed at the end of</br>the file if it is to be added.</br>",
            "type": "string"
          },
          "keyfile": {
            "description": "</br>PEM format private key file.</br>",
            "type": "string"
          },
          "verify": {
            "default": "verify_none",
            "description": "</br>Enable or disable peer verification.</br>",
            "enum": [
              "verify_peer",
              "verify_none"
            ],
            "type": "string"
          },
          "reuse_sessions": {
            "default": true,
            "description": "</br>Enable TLS session reuse.</br>",
            "type": "boolean"
          },
          "depth": {
            "default": 10,
            "description": "</br>Maximum number of non-self-issued intermediate certificates that can follow the peer certificate in a valid certification path. So, if depth is 0 the PEER must be signed by the trusted ROOT-CA directly; if 1 the path can be PEER, CA, ROOT-CA; if 2 the path can be PEER, CA, CA, ROOT-CA, and so on. The default value is 10.</br>",
            "type": "integer"
          },
          "password": {
            "description": "</br>String containing the user's password.</br>Only used if the private key file is password-protected.</br>",
            "example": "",
            "type": "string"
          },
          "versions": {
            "default": [
              "tlsv1.3",
              "tlsv1.2",
              "tlsv1.1",
              "tlsv1"
            ],
            "description": "</br>All TLS/DTLS versions to be supported.</br>NOTE: PSK ciphers are suppressed by 'tlsv1.3' version config.</br>In case PSK cipher suites are intended, make sure to configured</br><code>['tlsv1.2', 'tlsv1.1']</code> here.</br>",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "ciphers": {
            "default": [
              "TLS_AES_256_GCM_SHA384",
              "TLS_AES_128_GCM_SHA256",
              "TLS_CHACHA20_POLY1305_SHA256",
              "TLS_AES_128_CCM_SHA256",
              "TLS_AES_128_CCM_8_SHA256",
              "ECDHE-ECDSA-AES256-GCM-SHA384",
              "ECDHE-RSA-AES256-GCM-SHA384",
              "ECDHE-ECDSA-AES256-SHA384",
              "ECDHE-RSA-AES256-SHA384",
              "ECDH-ECDSA-AES256-GCM-SHA384",
              "ECDH-RSA-AES256-GCM-SHA384",
              "ECDH-ECDSA-AES256-SHA384",
              "ECDH-RSA-AES256-SHA384",
              "DHE-DSS-AES256-GCM-SHA384",
              "DHE-DSS-AES256-SHA256",
              "AES256-GCM-SHA384",
              "AES256-SHA256",
              "ECDHE-ECDSA-AES128-GCM-SHA256",
              "ECDHE-RSA-AES128-GCM-SHA256",
              "ECDHE-ECDSA-AES128-SHA256",
              "ECDHE-RSA-AES128-SHA256",
              "ECDH-ECDSA-AES128-GCM-SHA256",
              "ECDH-RSA-AES128-GCM-SHA256",
              "ECDH-ECDSA-AES128-SHA256",
              "ECDH-RSA-AES128-SHA256",
              "DHE-DSS-AES128-GCM-SHA256",
              "DHE-DSS-AES128-SHA256",
              "AES128-GCM-SHA256",
              "AES128-SHA256",
              "ECDHE-ECDSA-AES256-SHA",
              "ECDHE-RSA-AES256-SHA",
              "DHE-DSS-AES256-SHA",
              "ECDH-ECDSA-AES256-SHA",
              "ECDH-RSA-AES256-SHA",
              "ECDHE-ECDSA-AES128-SHA",
              "ECDHE-RSA-AES128-SHA",
              "DHE-DSS-AES128-SHA",
              "ECDH-ECDSA-AES128-SHA",
              "ECDH-RSA-AES128-SHA",
              "RSA-PSK-AES256-GCM-SHA384",
              "RSA-PSK-AES256-CBC-SHA384",
              "RSA-PSK-AES128-GCM-SHA256",
              "RSA-PSK-AES128-CBC-SHA256",
              "RSA-PSK-AES256-CBC-SHA",
              "RSA-PSK-AES128-CBC-SHA"
            ],
            "description": "</br>This config holds TLS cipher suite names separated by comma,</br>or as an array of strings. e.g.</br><code>\"TLS_AES_256_GCM_SHA384,TLS_AES_128_GCM_SHA256\"</code> or</br><code>[\"TLS_AES_256_GCM_SHA384\",\"TLS_AES_128_GCM_SHA256\"]</code>.</br></br>Ciphers (and their ordering) define the way in which the</br>client and server encrypts information over the network connection.</br>Selecting a good cipher suite is critical for the</br>application's data security, confidentiality and performance.</br></br>The names should be in OpenSSL string format (not RFC format).</br>All default values and examples provided by EMQX config</br>documentation are all in OpenSSL format.</br></br>NOTE: Certain cipher suites are only compatible with</br>specific TLS <code>versions</code> ('tlsv1.1', 'tlsv1.2' or 'tlsv1.3')</br>incompatible cipher suites will be silently dropped.</br>For instance, if only 'tlsv1.3' is given in the <code>versions</code>,</br>configuring cipher suites for other versions will have no effect.</br></br></br>NOTE: PSK ciphers are suppressed by 'tlsv1.3' version config</br>If PSK cipher suites are intended, 'tlsv1.3' should be disabled from <code>versions</code>.</br>PSK cipher suites: <code>\"RSA-PSK-AES256-GCM-SHA384,RSA-PSK-AES256-CBC-SHA384,</br>RSA-PSK-AES128-GCM-SHA256,RSA-PSK-AES128-CBC-SHA256,</br>RSA-PSK-AES256-CBC-SHA,RSA-PSK-AES128-CBC-SHA,</br>RSA-PSK-DES-CBC3-SHA,RSA-PSK-RC4-SHA\"</code></br>",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "user_lookup_fun": {
            "default": "emqx_tls_psk:lookup",
            "description": "</br>EMQX-internal callback that is used to lookup pre-shared key (PSK) identity.</br>",
            "type": "string"
          },
          "secure_renegotiate": {
            "default": true,
            "description": "</br>SSL parameter renegotiation is a feature that allows a client and a server</br>to renegotiate the parameters of the SSL connection on the fly.</br>RFC 5746 defines a more secure way of doing this. By enabling secure renegotiation,</br>you drop support for the insecure renegotiation, prone to MitM attacks.</br>",
            "type": "boolean"
          },
          "dhfile": {
            "description": "</br>Path to a file containing PEM-encoded Diffie-Hellman parameters</br>to be used by the server if a cipher suite using Diffie-Hellman</br>key exchange is negotiated. If not specified, default parameters</br>are used.</br>NOTE: The <code>dhfile</code> option is not supported by TLS 1.3.</br>",
            "type": "string"
          },
          "fail_if_no_peer_cert": {
            "default": false,
            "description": "</br>Used together with {verify, verify_peer} by an TLS/DTLS server.</br>If set to true, the server fails if the client does not have a</br>certificate to send, that is, sends an empty certificate.</br>If set to false, it fails only if the client sends an invalid</br>certificate (an empty certificate is considered valid).</br>",
            "type": "boolean"
          },
          "honor_cipher_order": {
            "default": true,
            "description": "</br>An important security setting, it forces the cipher to be set based</br> on the server-specified order instead of the client-specified order,</br> hence enforcing the (usually more properly configured) security</br> ordering of the server administrator.</br>",
            "type": "boolean"
          },
          "client_renegotiation": {
            "default": true,
            "description": "</br>In protocols that support client-initiated renegotiation,</br>the cost of resources of such an operation is higher for the server than the client.</br>This can act as a vector for denial of service attacks.</br>The SSL application already takes measures to counter-act such attempts,</br>but client-initiated renegotiation can be strictly disabled by setting this option to false.</br>The default value is true. Note that disabling renegotiation can result in</br>long-lived connections becoming unusable due to limits on</br>the number of messages the underlying cipher suite can encipher.</br>",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "gateway.mqttsn_predefined": {
        "required": [
          "topic",
          "id"
        ],
        "properties": {
          "id": {
            "description": "Topic ID. Range: 1-65535",
            "type": "integer"
          },
          "topic": {
            "description": "Topic Name",
            "type": "string"
          }
        },
        "type": "object"
      },
      "emqx_gateway_api.exproto": {
        "required": [
          "handler",
          "server"
        ],
        "properties": {
          "name": {
            "description": "Gateway Name",
            "enum": [
              "exproto"
            ],
            "type": "string"
          },
          "server": {
            "description": "Configurations for starting the <code>ConnectionAdapter</code> service",
            "$ref": "#/components/schemas/gateway.exproto_grpc_server"
          },
          "handler": {
            "description": "Configurations for request to <code>ConnectionHandler</code> service",
            "$ref": "#/components/schemas/gateway.exproto_grpc_handler"
          },
          "mountpoint": {
            "default": "",
            "description": " ",
            "type": "string"
          },
          "enable": {
            "default": true,
            "description": "Whether to enable this gateway",
            "type": "boolean"
          },
          "enable_stats": {
            "default": true,
            "description": "Whether to enable client process statistic",
            "type": "boolean"
          },
          "idle_timeout": {
            "default": "30s",
            "description": "The idle time of the client connection process. It has two purposes:</br>  1. A newly created client process that does not receive any client requests after that time will be closed directly.</br>  2. A running client process that does not receive any client requests after this time will go into hibernation to save resources.",
            "example": "12m",
            "type": "string"
          },
          "clientinfo_override": {
            "description": "ClientInfo override.",
            "$ref": "#/components/schemas/gateway.clientinfo_override"
          },
          "authentication": {
            "description": "Default authentication configs for all the gateway listeners. For per-listener overrides see <code>authentication</code></br> in listener configs",
            "oneOf": [
              {
                "$ref": "#/components/schemas/authn-scram-builtin_db.authentication"
              },
              {
                "$ref": "#/components/schemas/authn-jwt.jwks"
              },
              {
                "$ref": "#/components/schemas/authn-jwt.public-key"
              },
              {
                "$ref": "#/components/schemas/authn-jwt.hmac-based"
              },
              {
                "$ref": "#/components/schemas/authn-http.post"
              },
              {
                "$ref": "#/components/schemas/authn-http.get"
              },
              {
                "$ref": "#/components/schemas/authn-redis.sentinel"
              },
              {
                "$ref": "#/components/schemas/authn-redis.cluster"
              },
              {
                "$ref": "#/components/schemas/authn-redis.standalone"
              },
              {
                "$ref": "#/components/schemas/authn-mongodb.sharded-cluster"
              },
              {
                "$ref": "#/components/schemas/authn-mongodb.replica-set"
              },
              {
                "$ref": "#/components/schemas/authn-mongodb.standalone"
              },
              {
                "$ref": "#/components/schemas/authn-postgresql.authentication"
              },
              {
                "$ref": "#/components/schemas/authn-mysql.authentication"
              },
              {
                "$ref": "#/components/schemas/authn-builtin_db.authentication"
              }
            ]
          },
          "listeners": {
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/emqx_gateway_api.dtls_listener"
                },
                {
                  "$ref": "#/components/schemas/emqx_gateway_api.udp_listener"
                },
                {
                  "$ref": "#/components/schemas/emqx_gateway_api.ssl_listener"
                },
                {
                  "$ref": "#/components/schemas/emqx_gateway_api.tcp_listener"
                }
              ]
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "rule_engine.user_provided_function": {
        "required": [
          "function"
        ],
        "properties": {
          "function": {
            "description": "</br>The user provided function. Should be in the format: '{module}:{function}'.</br>Where {module} is the Erlang callback module and {function} is the Erlang function.</br></br>To write your own function, checkout the function <code>console</code> and</br><code>republish</code> in the source file:</br><code>apps/emqx_rule_engine/src/emqx_rule_actions.erl</code> as an example.</br>",
            "example": "module:function",
            "type": "string"
          },
          "args": {
            "default": {},
            "description": "</br>The args will be passed as the 3rd argument to module:function/3,</br>checkout the function <code>console</code> and <code>republish</code> in the source file:</br><code>apps/emqx_rule_engine/src/emqx_rule_actions.erl</code> as an example.</br>",
            "example": {},
            "type": "object"
          }
        },
        "type": "object"
      },
      "emqx_authn_schema.node_resource_metrics": {
        "properties": {
          "node": {
            "description": "Node name.",
            "example": "emqx@127.0.0.1",
            "type": "string"
          },
          "metrics": {
            "description": "The metrics of the resource.",
            "$ref": "#/components/schemas/emqx_authn_schema.resource_metrics"
          }
        },
        "type": "object"
      },
      "emqx_gateway_api.udp_listener": {
        "properties": {
          "id": {
            "description": "Listener ID",
            "type": "string"
          },
          "type": {
            "description": "Listener Type",
            "enum": [
              "udp"
            ],
            "type": "string"
          },
          "name": {
            "description": "Listener Name",
            "type": "string"
          },
          "running": {
            "description": "Listener Running status",
            "type": "boolean"
          },
          "udp_options": {
            "$ref": "#/components/schemas/gateway.udp_opts"
          },
          "enable": {
            "default": true,
            "description": "Enable the listener.",
            "type": "boolean"
          },
          "bind": {
            "description": "The IP address and port that the listener will bind.",
            "oneOf": [
              {
                "type": "integer"
              },
              {
                "example": "127.0.0.1:80",
                "type": "string"
              }
            ]
          },
          "max_connections": {
            "default": 1024,
            "description": "Maximum number of concurrent connections.",
            "type": "integer"
          },
          "max_conn_rate": {
            "default": 1000,
            "description": "Maximum connections per second.",
            "type": "integer"
          },
          "authentication": {
            "description": "Default authentication configs for all the gateway listeners. For per-listener overrides see <code>authentication</code></br> in listener configs",
            "oneOf": [
              {
                "$ref": "#/components/schemas/authn-scram-builtin_db.authentication"
              },
              {
                "$ref": "#/components/schemas/authn-jwt.jwks"
              },
              {
                "$ref": "#/components/schemas/authn-jwt.public-key"
              },
              {
                "$ref": "#/components/schemas/authn-jwt.hmac-based"
              },
              {
                "$ref": "#/components/schemas/authn-http.post"
              },
              {
                "$ref": "#/components/schemas/authn-http.get"
              },
              {
                "$ref": "#/components/schemas/authn-redis.sentinel"
              },
              {
                "$ref": "#/components/schemas/authn-redis.cluster"
              },
              {
                "$ref": "#/components/schemas/authn-redis.standalone"
              },
              {
                "$ref": "#/components/schemas/authn-mongodb.sharded-cluster"
              },
              {
                "$ref": "#/components/schemas/authn-mongodb.replica-set"
              },
              {
                "$ref": "#/components/schemas/authn-mongodb.standalone"
              },
              {
                "$ref": "#/components/schemas/authn-postgresql.authentication"
              },
              {
                "$ref": "#/components/schemas/authn-mysql.authentication"
              },
              {
                "$ref": "#/components/schemas/authn-builtin_db.authentication"
              }
            ]
          },
          "enable_authn": {
            "default": true,
            "description": "Set <code>true</code> (default) to enable client authentication on this listener. </br>When set to <code>false</code> clients will be allowed to connect without authentication.",
            "type": "boolean"
          },
          "mountpoint": {
            "description": "When publishing or subscribing, prefix all topics with a mountpoint string.</br>The prefixed string will be removed from the topic name when the message is delivered to the subscriber. The mountpoint is a way that users can use to implement isolation of message routing between different listeners.</br>For example if a client A subscribes to `t` with `listeners.tcp.\\<name>.mountpoint` set to `some_tenant`, then the client actually subscribes to the topic `some_tenant/t`. Similarly, if another client B (connected to the same listener as the client A) sends a message to topic `t`, the message is routed to all the clients subscribed `some_tenant/t`, so client A will receive the message, with topic name `t`. Set to `\"\"` to disable the feature.</br>Variables in mountpoint string:</br>  - <code>${clientid}</code>: clientid</br>  - <code>${username}</code>: username</br>",
            "type": "string"
          },
          "access_rules": {
            "default": "",
            "description": "The access control rules for this listener.</br>See: https://github.com/emqtt/esockd#allowdeny",
            "items": {
              "type": "string"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "emqx_gateway_api_listeners.tcp_listener": {
        "properties": {
          "id": {
            "description": "Listener ID",
            "type": "string"
          },
          "type": {
            "description": "Listener Type",
            "enum": [
              "tcp"
            ],
            "type": "string"
          },
          "name": {
            "description": "Listener Name",
            "type": "string"
          },
          "running": {
            "description": "Listener Running status",
            "type": "boolean"
          },
          "acceptors": {
            "default": 16,
            "description": "Size of the acceptor pool.",
            "type": "integer"
          },
          "tcp_options": {
            "description": "Setting the TCP socket options.",
            "$ref": "#/components/schemas/broker.tcp_opts"
          },
          "proxy_protocol": {
            "default": false,
            "description": "Enable the Proxy Protocol V1/2 if the EMQX cluster is deployed behind HAProxy or Nginx.</br>See: https://www.haproxy.com/blog/haproxy/proxy-protocol/",
            "type": "boolean"
          },
          "proxy_protocol_timeout": {
            "default": "15s",
            "description": "Timeout for proxy protocol.</br>EMQX will close the TCP connection if proxy protocol packet is not received within the timeout.",
            "example": "12m",
            "type": "string"
          },
          "enable": {
            "default": true,
            "description": "Enable the listener.",
            "type": "boolean"
          },
          "bind": {
            "description": "The IP address and port that the listener will bind.",
            "oneOf": [
              {
                "type": "integer"
              },
              {
                "example": "127.0.0.1:80",
                "type": "string"
              }
            ]
          },
          "max_connections": {
            "default": 1024,
            "description": "Maximum number of concurrent connections.",
            "type": "integer"
          },
          "max_conn_rate": {
            "default": 1000,
            "description": "Maximum connections per second.",
            "type": "integer"
          },
          "authentication": {
            "description": "Default authentication configs for all the gateway listeners. For per-listener overrides see <code>authentication</code></br> in listener configs",
            "oneOf": [
              {
                "$ref": "#/components/schemas/authn-scram-builtin_db.authentication"
              },
              {
                "$ref": "#/components/schemas/authn-jwt.jwks"
              },
              {
                "$ref": "#/components/schemas/authn-jwt.public-key"
              },
              {
                "$ref": "#/components/schemas/authn-jwt.hmac-based"
              },
              {
                "$ref": "#/components/schemas/authn-http.post"
              },
              {
                "$ref": "#/components/schemas/authn-http.get"
              },
              {
                "$ref": "#/components/schemas/authn-redis.sentinel"
              },
              {
                "$ref": "#/components/schemas/authn-redis.cluster"
              },
              {
                "$ref": "#/components/schemas/authn-redis.standalone"
              },
              {
                "$ref": "#/components/schemas/authn-mongodb.sharded-cluster"
              },
              {
                "$ref": "#/components/schemas/authn-mongodb.replica-set"
              },
              {
                "$ref": "#/components/schemas/authn-mongodb.standalone"
              },
              {
                "$ref": "#/components/schemas/authn-postgresql.authentication"
              },
              {
                "$ref": "#/components/schemas/authn-mysql.authentication"
              },
              {
                "$ref": "#/components/schemas/authn-builtin_db.authentication"
              }
            ]
          },
          "enable_authn": {
            "default": true,
            "description": "Set <code>true</code> (default) to enable client authentication on this listener. </br>When set to <code>false</code> clients will be allowed to connect without authentication.",
            "type": "boolean"
          },
          "mountpoint": {
            "description": "When publishing or subscribing, prefix all topics with a mountpoint string.</br>The prefixed string will be removed from the topic name when the message is delivered to the subscriber. The mountpoint is a way that users can use to implement isolation of message routing between different listeners.</br>For example if a client A subscribes to `t` with `listeners.tcp.\\<name>.mountpoint` set to `some_tenant`, then the client actually subscribes to the topic `some_tenant/t`. Similarly, if another client B (connected to the same listener as the client A) sends a message to topic `t`, the message is routed to all the clients subscribed `some_tenant/t`, so client A will receive the message, with topic name `t`. Set to `\"\"` to disable the feature.</br>Variables in mountpoint string:</br>  - <code>${clientid}</code>: clientid</br>  - <code>${username}</code>: username</br>",
            "type": "string"
          },
          "access_rules": {
            "default": "",
            "description": "The access control rules for this listener.</br>See: https://github.com/emqtt/esockd#allowdeny",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "current_connections": {
            "description": "Current Connections",
            "minimum": 0,
            "type": "integer"
          },
          "node_status": {
            "description": "listener status of each node in the cluster",
            "items": {
              "$ref": "#/components/schemas/listeners.node_status"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "emqx_delayed_api.message": {
        "properties": {
          "msgid": {
            "description": "Delayed Message ID",
            "type": "integer"
          },
          "node": {
            "description": "The node where message from",
            "type": "string"
          },
          "publish_at": {
            "description": "Clinet publish message time, in RFC 3339 format",
            "type": "string"
          },
          "delayed_interval": {
            "description": "Delayed interval(second)",
            "minimum": 1,
            "type": "integer"
          },
          "delayed_remaining": {
            "description": "Delayed remaining(second)",
            "minimum": 0,
            "type": "integer"
          },
          "expected_at": {
            "description": "Expect publish time, in RFC 3339 format",
            "type": "string"
          },
          "topic": {
            "description": "Topic",
            "example": "/sys/#",
            "type": "string"
          },
          "qos": {
            "description": "QoS",
            "enum": [
              0,
              1,
              2
            ],
            "type": "string"
          },
          "from_clientid": {
            "description": "From ClientID",
            "type": "string"
          },
          "from_username": {
            "description": "From Username",
            "type": "string"
          },
          "payload": {
            "description": "Payload, base64 encoded. Payload will be set to 'PAYLOAD_TO_LARGE' if its length is larger than 2048 bytes",
            "type": "string"
          }
        },
        "type": "object"
      },
      "emqx_bridge_mqtt_schema.post_ingress": {
        "required": [
          "remote_topic",
          "connector",
          "direction",
          "name",
          "type"
        ],
        "properties": {
          "type": {
            "description": "The bridge type.",
            "enum": [
              "mqtt"
            ],
            "type": "string"
          },
          "name": {
            "description": "Bridge name, used as a human-readable description of the bridge.",
            "type": "string"
          },
          "direction": {
            "default": "egress",
            "description": "The direction of the bridge. Can be one of 'ingress' or 'egress'.</br>The ingress config defines how this bridge receive messages from the remote MQTT broker, and then</br>send them to the local broker.</br>Template with variables is allowed in 'local_topic', 'remote_qos', 'qos', 'retain',</br>'payload'.</br>NOTE: if this bridge is used as the input of a rule (emqx rule engine), and also local_topic is</br>configured, then messages got from the remote broker will be sent to both the 'local_topic' and</br>the rule.</br>",
            "enum": [
              "ingress"
            ],
            "type": "string"
          },
          "connector": {
            "description": "</br>The ID or the configs of the connector to be used for this bridge. Connector IDs must be of format:</br><code>{type}:{name}</code>.</br>In config files, you can find the corresponding config entry for a connector by such path:</br>'connectors.{type}.{name}'.</br>",
            "example": "mqtt:my_mqtt_connector",
            "oneOf": [
              {
                "$ref": "#/components/schemas/connector-mqtt.connector"
              },
              {
                "type": "string"
              }
            ]
          },
          "remote_topic": {
            "description": "Receive messages from which topic of the remote broker",
            "type": "string"
          },
          "remote_qos": {
            "default": 1,
            "description": "The QoS level to be used when subscribing to the remote broker",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "enum": [
                  0,
                  1,
                  2
                ],
                "type": "string"
              }
            ]
          },
          "local_topic": {
            "description": "</br>Send messages to which topic of the local broker.</br>Template with variables is allowed.</br>",
            "type": "string"
          },
          "local_qos": {
            "default": "${qos}",
            "description": "</br>The QoS of the MQTT message to be sent.</br>Template with variables is allowed.</br>",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "enum": [
                  0,
                  1,
                  2
                ],
                "type": "string"
              }
            ]
          },
          "retain": {
            "default": "${retain}",
            "description": "</br>The 'retain' flag of the MQTT message to be sent.</br>Template with variables is allowed.</br>",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "boolean"
              }
            ]
          },
          "payload": {
            "default": "${payload}",
            "description": "</br>The payload of the MQTT message to be sent.</br>Template with variables is allowed.</br>",
            "type": "string"
          }
        },
        "type": "object"
      },
      "broker.persistent_table_mria_opts": {
        "properties": {
          "ram_cache": {
            "default": true,
            "description": "Maintain a copy of the data in RAM for faster access.",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "authn-hash.pbkdf2": {
        "required": [
          "iterations",
          "mac_fun",
          "name"
        ],
        "properties": {
          "name": {
            "description": "PBKDF2 password hashing.",
            "enum": [
              "pbkdf2"
            ],
            "type": "string"
          },
          "mac_fun": {
            "description": "Specifies mac_fun for PBKDF2 hashing algorithm.",
            "enum": [
              "md4",
              "md5",
              "ripemd160",
              "sha",
              "sha224",
              "sha256",
              "sha384",
              "sha512"
            ],
            "type": "string"
          },
          "iterations": {
            "description": "Iteration count for PBKDF2 hashing algorithm.",
            "type": "integer"
          },
          "dk_length": {
            "description": "Derived length for PBKDF2 hashing algorithm. If not specified, calculated automatically based on `mac_fun`.",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "authn-mongodb.sharded-cluster": {
        "required": [
          "database",
          "servers",
          "mongo_type",
          "collection",
          "backend",
          "mechanism"
        ],
        "properties": {
          "mechanism": {
            "description": "Authentication mechanism.",
            "enum": [
              "password_based"
            ],
            "type": "string"
          },
          "backend": {
            "description": "Backend type.",
            "enum": [
              "mongodb"
            ],
            "type": "string"
          },
          "collection": {
            "description": "Collection used to store authentication data.",
            "type": "string"
          },
          "filter": {
            "default": {},
            "description": "</br>Conditional expression that defines the filter condition in the query.</br>Filter supports the following placeholders:</br>- <code>${username}</code>: Will be replaced at runtime with <code>Username</code> used by the client when connecting</br>- <code>${clientid}</code>: Will be replaced at runtime with <code>Client ID</code> used by the client when connecting</br>",
            "example": {},
            "type": "object"
          },
          "password_hash_field": {
            "default": "password_hash",
            "description": "Document field that contains password hash.",
            "type": "string"
          },
          "salt_field": {
            "default": "salt",
            "description": "Document field that contains the password salt.",
            "type": "string"
          },
          "is_superuser_field": {
            "default": "is_superuser",
            "description": "Document field that defines if the user has superuser privileges.",
            "type": "string"
          },
          "password_hash_algorithm": {
            "default": {
              "name": "sha256",
              "salt_position": "prefix"
            },
            "description": "Options for password hash verification.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/authn-hash.other_algorithms"
              },
              {
                "$ref": "#/components/schemas/authn-hash.pbkdf2"
              },
              {
                "$ref": "#/components/schemas/authn-hash.bcrypt"
              }
            ]
          },
          "enable": {
            "default": true,
            "description": "Set to <code>true</code> or <code>false</code> to disable this auth provider.",
            "type": "boolean"
          },
          "mongo_type": {
            "default": "sharded",
            "description": "Sharded cluster.",
            "enum": [
              "sharded"
            ],
            "type": "string"
          },
          "servers": {
            "description": "</br>A Node list for Cluster to connect to. The nodes should be separated with commas, such as: `Node[,Node].`</br>For each Node should be: The IPv4 or IPv6 address or the hostname to connect to.</br>A host entry has the following form: `Host[:Port]`.</br>The MongoDB default port 27017 is used if `[:Port]` is not specified.</br>",
            "items": {
              "example": "any",
              "type": "string"
            },
            "type": "array"
          },
          "w_mode": {
            "default": "unsafe",
            "description": "Write mode.",
            "enum": [
              "unsafe",
              "safe"
            ],
            "type": "string"
          },
          "srv_record": {
            "default": false,
            "description": "Use DNS SRV record.",
            "type": "boolean"
          },
          "pool_size": {
            "default": 8,
            "description": "Size of the connection pool.",
            "minimum": 1,
            "type": "integer"
          },
          "username": {
            "description": "EMQX's username in the external database.",
            "type": "string"
          },
          "password": {
            "description": "EMQX's password in the external database.",
            "type": "string"
          },
          "auth_source": {
            "description": "Database name associated with the user's credentials.",
            "type": "string"
          },
          "database": {
            "description": "Database name.",
            "type": "string"
          },
          "topology": {
            "$ref": "#/components/schemas/emqx_connector_mongo.topology"
          },
          "ssl": {
            "default": {
              "enable": false
            },
            "description": "SSL connection settings.",
            "$ref": "#/components/schemas/broker.ssl_client_opts"
          }
        },
        "type": "object"
      },
      "emqx_gateway_api.gateway_overview": {
        "properties": {
          "name": {
            "description": "Gateway Name",
            "type": "string"
          },
          "status": {
            "description": "Gateway Status",
            "enum": [
              "running",
              "stopped",
              "unloaded"
            ],
            "type": "string"
          },
          "created_at": {
            "description": "The Gateway created datetime",
            "type": "string"
          },
          "started_at": {
            "description": "The Gateway started datetime",
            "type": "string"
          },
          "stopped_at": {
            "description": "The Gateway stopped datetime",
            "type": "string"
          },
          "max_connections": {
            "description": "The Gateway allowed maximum connections/clients",
            "minimum": 1,
            "type": "integer"
          },
          "current_connections": {
            "description": "The Gateway current connected connections/clients",
            "minimum": 0,
            "type": "integer"
          },
          "listeners": {
            "description": "The Gateway listeners overview",
            "items": {
              "$ref": "#/components/schemas/emqx_gateway_api.gateway_listener_overview"
            },
            "type": "array"
          },
          "node_status": {
            "description": "The status of the gateway on each node in the cluster",
            "items": {
              "$ref": "#/components/schemas/emqx_gateway_api.gateway_node_status"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "dashboard.dashboard": {
        "required": [
          "default_password",
          "default_username"
        ],
        "properties": {
          "listeners": {
            "description": "HTTP(s) listeners are identified by their protocol type and are</br>used to serve dashboard UI and restful HTTP API.</br>Listeners must have a unique combination of port number and IP address.</br>For example, an HTTP listener can listen on all configured IP addresses</br>on a given port for a machine by specifying the IP address 0.0.0.0.</br>Alternatively, the HTTP listener can specify a unique IP address for each listener,</br>but use the same port.",
            "$ref": "#/components/schemas/dashboard.listeners"
          },
          "default_username": {
            "default": "admin",
            "description": "The default username of the automatically created dashboard user.",
            "readOnly": true,
            "type": "string"
          },
          "default_password": {
            "default": "public",
            "description": "The initial default password for dashboard 'admin' user.</br>For safety, it should be changed as soon as possible.",
            "readOnly": true,
            "type": "string"
          },
          "sample_interval": {
            "default": "10s",
            "description": "How often to update metrics displayed in the dashboard.</br>Note: `sample_interval` should be a divisor of 60.",
            "example": "1h",
            "type": "string"
          },
          "token_expired_time": {
            "default": "60m",
            "description": "JWT token expiration time.",
            "example": "12m",
            "type": "string"
          },
          "cors": {
            "default": false,
            "description": "Support Cross-Origin Resource Sharing (CORS).</br>Allows a server to indicate any origins (domain, scheme, or port) other than</br>its own from which a browser should permit loading resources.",
            "type": "boolean"
          },
          "i18n_lang": {
            "default": "en",
            "description": "Internationalization language support.",
            "enum": [
              "en",
              "zh"
            ],
            "readOnly": true,
            "type": "string"
          }
        },
        "type": "object"
      },
      "broker.sys_topics": {
        "properties": {
          "sys_msg_interval": {
            "default": "1m",
            "description": "Time interval of publishing `$SYS` messages.",
            "oneOf": [
              {
                "example": "12m",
                "type": "string"
              },
              {
                "enum": [
                  "disabled"
                ],
                "type": "string"
              }
            ]
          },
          "sys_heartbeat_interval": {
            "default": "30s",
            "description": "Time interval for publishing following heartbeat messages:</br>  - `$SYS/brokers/<node>/uptime`</br>  - `$SYS/brokers/<node>/datetime`</br>",
            "oneOf": [
              {
                "example": "12m",
                "type": "string"
              },
              {
                "enum": [
                  "disabled"
                ],
                "type": "string"
              }
            ]
          },
          "sys_event_messages": {
            "description": "Client events messages",
            "$ref": "#/components/schemas/broker.event_names"
          }
        },
        "type": "object"
      },
      "authz.node_resource_metrics": {
        "properties": {
          "node": {
            "description": "Node name.",
            "example": "emqx@127.0.0.1",
            "type": "string"
          },
          "metrics": {
            "description": "The metrics of the resource.",
            "$ref": "#/components/schemas/authz.resource_metrics"
          }
        },
        "type": "object"
      },
      "emqx_gateway_api.gateway_node_status": {
        "properties": {
          "node": {
            "description": "Node Name",
            "enum": [
              "emqx@127.0.0.1"
            ],
            "type": "string"
          },
          "status": {
            "description": "Gateway Status",
            "enum": [
              "running",
              "stopped",
              "unloaded"
            ],
            "type": "string"
          },
          "max_connections": {
            "description": "The Gateway allowed maximum connections/clients",
            "minimum": 1,
            "type": "integer"
          },
          "current_connections": {
            "description": "The Gateway current connected connections/clients",
            "minimum": 0,
            "type": "integer"
          }
        },
        "type": "object"
      },
      "emqx_gateway_api.lwm2m": {
        "required": [
          "translators",
          "xml_dir"
        ],
        "properties": {
          "name": {
            "description": "Gateway Name",
            "enum": [
              "lwm2m"
            ],
            "type": "string"
          },
          "xml_dir": {
            "default": "/mnt/code/src/emqx/0/_build/emqx/rel/emqx/etc/lwm2m_xml",
            "description": "The Directory for LwM2M Resource definition",
            "type": "string"
          },
          "lifetime_min": {
            "default": "15s",
            "description": "Minimum value of lifetime allowed to be set by the LwM2M client",
            "example": "12m",
            "type": "string"
          },
          "lifetime_max": {
            "default": "86400s",
            "description": "Maximum value of lifetime allowed to be set by the LwM2M client",
            "example": "12m",
            "type": "string"
          },
          "qmode_time_window": {
            "default": "22s",
            "description": "The value of the time window during which the network link is considered valid by the LwM2M Gateway in QMode mode.</br>For example, after receiving an update message from a client, any messages within this time window are sent directly to the LwM2M client, and all messages beyond this time window are temporarily stored in memory.",
            "example": "1h",
            "type": "string"
          },
          "auto_observe": {
            "default": false,
            "description": "Automatically observe the object list of REGISTER packet",
            "type": "boolean"
          },
          "update_msg_publish_condition": {
            "default": "contains_object_list",
            "description": "Policy for publishing UPDATE event message.</br>  - always: send update events as long as the UPDATE request is received.</br>  - contains_object_list: send update events only if the UPDATE request carries any Object List</br>",
            "enum": [
              "always",
              "contains_object_list"
            ],
            "type": "string"
          },
          "translators": {
            "description": "Topic configuration for LwM2M's gateway publishing and subscription",
            "$ref": "#/components/schemas/gateway.lwm2m_translators"
          },
          "mountpoint": {
            "default": "lwm2m/${endpoint_name}/",
            "description": " ",
            "type": "string"
          },
          "enable": {
            "default": true,
            "description": "Whether to enable this gateway",
            "type": "boolean"
          },
          "enable_stats": {
            "default": true,
            "description": "Whether to enable client process statistic",
            "type": "boolean"
          },
          "idle_timeout": {
            "default": "30s",
            "description": "The idle time of the client connection process. It has two purposes:</br>  1. A newly created client process that does not receive any client requests after that time will be closed directly.</br>  2. A running client process that does not receive any client requests after this time will go into hibernation to save resources.",
            "example": "12m",
            "type": "string"
          },
          "clientinfo_override": {
            "description": "ClientInfo override.",
            "$ref": "#/components/schemas/gateway.clientinfo_override"
          },
          "authentication": {
            "description": "Default authentication configs for all the gateway listeners. For per-listener overrides see <code>authentication</code></br> in listener configs",
            "oneOf": [
              {
                "$ref": "#/components/schemas/authn-scram-builtin_db.authentication"
              },
              {
                "$ref": "#/components/schemas/authn-jwt.jwks"
              },
              {
                "$ref": "#/components/schemas/authn-jwt.public-key"
              },
              {
                "$ref": "#/components/schemas/authn-jwt.hmac-based"
              },
              {
                "$ref": "#/components/schemas/authn-http.post"
              },
              {
                "$ref": "#/components/schemas/authn-http.get"
              },
              {
                "$ref": "#/components/schemas/authn-redis.sentinel"
              },
              {
                "$ref": "#/components/schemas/authn-redis.cluster"
              },
              {
                "$ref": "#/components/schemas/authn-redis.standalone"
              },
              {
                "$ref": "#/components/schemas/authn-mongodb.sharded-cluster"
              },
              {
                "$ref": "#/components/schemas/authn-mongodb.replica-set"
              },
              {
                "$ref": "#/components/schemas/authn-mongodb.standalone"
              },
              {
                "$ref": "#/components/schemas/authn-postgresql.authentication"
              },
              {
                "$ref": "#/components/schemas/authn-mysql.authentication"
              },
              {
                "$ref": "#/components/schemas/authn-builtin_db.authentication"
              }
            ]
          },
          "listeners": {
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/emqx_gateway_api.dtls_listener"
                },
                {
                  "$ref": "#/components/schemas/emqx_gateway_api.udp_listener"
                }
              ]
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "zone.force_shutdown": {
        "properties": {
          "enable": {
            "description": "Enable `force_shutdown` feature.",
            "type": "boolean"
          },
          "max_message_queue_len": {
            "description": "Maximum message queue length.",
            "minimum": 0,
            "type": "integer"
          },
          "max_heap_size": {
            "description": "Total heap size",
            "example": "1024KB",
            "type": "string"
          }
        },
        "type": "object"
      }
    },
    "securitySchemes": {
      "basicAuth": {
        "scheme": "basic",
        "type": "http"
      },
      "bearerAuth": {
        "scheme": "bearer",
        "type": "http"
      }
    }
  },
  "info": {
    "title": "EMQX HTTP API",
    "version": "5.0"
  },
  "openapi": "3.0.0",
  "paths": {
    "/gateway/{name}/authentication/users": {
      "get": {
        "description": "Get the users for the authentication",
        "parameters": [
          {
            "description": "Gateway Name",
            "example": "",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Page number of the results to fetch.",
            "example": 1,
            "in": "query",
            "name": "page",
            "schema": {
              "default": 1,
              "minimum": 1,
              "type": "integer"
            }
          },
          {
            "description": "Results per page(max 1000)",
            "example": 50,
            "in": "query",
            "name": "limit",
            "schema": {
              "default": 100,
              "maximum": 1000,
              "minimum": 1,
              "type": "integer"
            }
          },
          {
            "description": "Fuzzy search by user_id (username or clientid)",
            "example": "username",
            "in": "query",
            "name": "like_user_id",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Is superuser",
            "in": "query",
            "name": "is_superuser",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": {
                  "data": [
                    {
                      "user_id": "user1"
                    },
                    {
                      "is_superuser": true,
                      "user_id": "user2"
                    }
                  ],
                  "meta": {
                    "count": 300,
                    "limit": 20,
                    "page": 0
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/emqx_authn_api.response_users"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "gateway"
        ]
      },
      "post": {
        "description": "Add user for the authentication",
        "parameters": [
          {
            "description": "Gateway Name",
            "example": "",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "regular_user": {
                  "summary": "Regular user",
                  "value": {
                    "password": "secret",
                    "user_id": "user1"
                  }
                },
                "super_user": {
                  "summary": "Superuser",
                  "value": {
                    "is_superuser": true,
                    "password": "secret",
                    "user_id": "user2"
                  }
                }
              },
              "schema": {
                "$ref": "#/components/schemas/emqx_authn_api.request_user_create"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "example": {
                  "regular_user": {
                    "summary": "Regular user",
                    "value": {
                      "user_id": "user1"
                    }
                  },
                  "super_user": {
                    "summary": "Superuser",
                    "value": {
                      "is_superuser": true,
                      "user_id": "user2"
                    }
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/emqx_authn_api.response_user"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "gateway"
        ]
      }
    },
    "/metrics": {
      "get": {
        "description": "EMQX metrics",
        "parameters": [
          {
            "description": "Whether to aggregate all nodes Metrics",
            "in": "query",
            "name": "aggregate",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    {
                      "items": {
                        "$ref": "#/components/schemas/emqx_mgmt_api_metrics.node_metrics"
                      },
                      "type": "array"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_mgmt_api_metrics.aggregated_metrics"
                    }
                  ]
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "metrics"
        ]
      }
    },
    "/authentication/{id}/users/{user_id}": {
      "delete": {
        "description": "Delete user in authenticator in global authentication chain.",
        "parameters": [
          {
            "description": "Authenticator ID.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "User ID.",
            "in": "path",
            "name": "user_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "User deleted"
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "authentication",
          "authentication config(global)"
        ]
      },
      "get": {
        "description": "Get user from authenticator in global authentication chain.",
        "parameters": [
          {
            "description": "Authenticator ID.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "User ID.",
            "in": "path",
            "name": "user_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "regular_user": {
                    "summary": "Regular user",
                    "value": {
                      "user_id": "user1"
                    }
                  },
                  "super_user": {
                    "summary": "Superuser",
                    "value": {
                      "is_superuser": true,
                      "user_id": "user2"
                    }
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/emqx_authn_api.response_user"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "authentication",
          "authentication config(global)"
        ]
      },
      "put": {
        "description": "Update user in authenticator in global authentication chain.",
        "parameters": [
          {
            "description": "Authenticator ID.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "User ID.",
            "in": "path",
            "name": "user_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "regular_user": {
                  "summary": "Update regular user",
                  "value": {
                    "password": "newsecret"
                  }
                },
                "super_user": {
                  "summary": "Update user and promote to superuser",
                  "value": {
                    "is_superuser": true,
                    "password": "newsecret"
                  }
                }
              },
              "schema": {
                "$ref": "#/components/schemas/emqx_authn_api.request_user_update"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": {
                  "regular_user": {
                    "summary": "Regular user",
                    "value": {
                      "user_id": "user1"
                    }
                  },
                  "super_user": {
                    "summary": "Superuser",
                    "value": {
                      "is_superuser": true,
                      "user_id": "user2"
                    }
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/emqx_authn_api.response_user"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad Request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "authentication",
          "authentication config(global)"
        ]
      }
    },
    "/authentication/{id}/import_users": {
      "post": {
        "description": "Import users into authenticator in global authentication chain.",
        "parameters": [
          {
            "description": "Authenticator ID.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "multipart/form-data": {
              "schema": {
                "filename": "file"
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "Users imported"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad Request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "authentication",
          "authentication config(global)"
        ]
      }
    },
    "/mqtt/delayed": {
      "get": {
        "description": "Get delayed status",
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/modules.delayed"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "mqtt"
        ]
      },
      "put": {
        "description": "Enable or disable delayed, set max delayed messages",
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/modules.delayed"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Enable or disable delayed successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/modules.delayed"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Max limit illegality",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "mqtt"
        ]
      }
    },
    "/plugins/{name}": {
      "delete": {
        "description": "Uninstall a plugin package.",
        "parameters": [
          {
            "$ref": "#/components/parameters/plugins.name"
          }
        ],
        "responses": {
          "204": {
            "description": "Uninstall successfully"
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Plugin Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "plugins"
        ]
      },
      "get": {
        "description": "Describe a plugin according `release.json` and `README.md`.",
        "parameters": [
          {
            "$ref": "#/components/parameters/plugins.name"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/plugins.plugin"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Plugin Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "plugins"
        ]
      }
    },
    "/status": {
      "get": {
        "description": "Node running status",
        "parameters": [],
        "responses": {
          "200": {
            "content": {
              "text/plain": {
                "example": "Node emqx@127.0.0.1 is started\nemqx is running",
                "schema": {
                  "type": "string"
                }
              }
            },
            "description": "Node is running"
          }
        },
        "security": [],
        "tags": [
          "status"
        ]
      }
    },
    "/topics/{topic}": {
      "get": {
        "description": "Lookup topic info by name",
        "parameters": [
          {
            "description": "Topic Name",
            "example": "",
            "in": "path",
            "name": "topic",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx_mgmt_api_topics.topic"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "TOPIC_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Topic not found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "topics"
        ]
      }
    },
    "/authorization/sources/built_in_database/clientid/{clientid}": {
      "delete": {
        "description": "Delete one record for clientid",
        "parameters": [
          {
            "$ref": "#/components/parameters/emqx_authz_api_mnesia.clientid"
          }
        ],
        "responses": {
          "204": {
            "description": "Deleted"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad clientid",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "ClientID Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "authorization"
        ]
      },
      "get": {
        "description": "Get record info for clientid",
        "parameters": [
          {
            "$ref": "#/components/parameters/emqx_authz_api_mnesia.clientid"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "password_based:built_in_database": {
                    "summary": "ClientID",
                    "value": {
                      "clientid": "client1",
                      "rules": [
                        {
                          "action": "publish",
                          "permission": "allow",
                          "topic": "test/toopic/1"
                        },
                        {
                          "action": "subscribe",
                          "permission": "allow",
                          "topic": "test/toopic/2"
                        },
                        {
                          "action": "all",
                          "permission": "deny",
                          "topic": "eq test/#"
                        }
                      ]
                    }
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/emqx_authz_api_mnesia.rules_for_clientid"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "authorization"
        ]
      },
      "put": {
        "description": "Set record for clientid",
        "parameters": [
          {
            "$ref": "#/components/parameters/emqx_authz_api_mnesia.clientid"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "password_based:built_in_database": {
                  "summary": "ClientID",
                  "value": {
                    "clientid": "client1",
                    "rules": [
                      {
                        "action": "publish",
                        "permission": "allow",
                        "topic": "test/toopic/1"
                      },
                      {
                        "action": "subscribe",
                        "permission": "allow",
                        "topic": "test/toopic/2"
                      },
                      {
                        "action": "all",
                        "permission": "deny",
                        "topic": "eq test/#"
                      }
                    ]
                  }
                }
              },
              "schema": {
                "$ref": "#/components/schemas/emqx_authz_api_mnesia.rules_for_clientid"
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "Updated"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad clientid or bad rule schema",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "authorization"
        ]
      }
    },
    "/stats": {
      "get": {
        "description": "EMQX stats",
        "parameters": [
          {
            "$ref": "#/components/parameters/emqx_mgmt_api_stats.aggregate"
          }
        ],
        "responses": {
          "200": {
            "description": "List stats ok",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    {
                      "items": {
                        "$ref": "#/components/schemas/emqx_mgmt_api_stats.aggergate_data"
                      },
                      "type": "array"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_mgmt_api_stats.node_stats_data"
                    }
                  ]
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "stats"
        ]
      }
    },
    "/monitor_current": {
      "get": {
        "description": "Current status. Gauge and rate.",
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx_dashboard_monitor_api.sampler_current"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "dashboard"
        ]
      }
    },
    "/listeners/{listener_id}/authentication/{id}": {
      "delete": {
        "description": "Delete authenticator from listener authentication chain.",
        "parameters": [
          {
            "description": "Listener ID.",
            "example": "tcp:default",
            "in": "path",
            "name": "listener_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Authenticator ID.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Authenticator deleted"
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "authentication",
          "authentication config(single listener)"
        ]
      },
      "get": {
        "description": "Get authenticator from listener authentication chain.",
        "parameters": [
          {
            "description": "Listener ID.",
            "example": "tcp:default",
            "in": "path",
            "name": "listener_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Authenticator ID.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "jwt": {
                    "summary": "JWT authentication",
                    "value": {
                      "algorithm": "hmac-based",
                      "mechanism": "jwt",
                      "secret": "mysecret",
                      "secret_base64_encoded": false,
                      "use_jwks": false,
                      "verify_claims": {
                        "username": "${username}"
                      }
                    }
                  },
                  "password_based:built_in_database": {
                    "summary": "Built-in password_based authentication",
                    "value": {
                      "backend": "built_in_database",
                      "mechanism": "password_based",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "user_id_type": "username"
                    }
                  },
                  "password_based:http": {
                    "summary": "password_based authentication through external HTTP API",
                    "value": {
                      "backend": "http",
                      "body": {
                        "password": "${password}",
                        "username": "${username}"
                      },
                      "connect_timeout": 5000,
                      "enable_pipelining": 100,
                      "headers": {
                        "content-type": "application/json"
                      },
                      "mechanism": "password_based",
                      "method": "post",
                      "pool_size": 8,
                      "request_timeout": 5000,
                      "ssl": {
                        "enable": false
                      },
                      "url": "http://127.0.0.1:18083"
                    }
                  },
                  "password_based:mongodb": {
                    "summary": "password_based authentication with MongoDB backend",
                    "value": {
                      "backend": "mongodb",
                      "collection": "users",
                      "database": "example",
                      "filter": {
                        "username": "${username}"
                      },
                      "is_superuser_field": "is_superuser",
                      "mechanism": "password_based",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "password_hash_field": "password_hash",
                      "salt_field": "salt",
                      "server": "127.0.0.1:27017"
                    }
                  },
                  "password_based:redis": {
                    "summary": "password_based authentication with Redis backend",
                    "value": {
                      "backend": "redis",
                      "cmd": "HMGET ${username} password_hash salt",
                      "database": 0,
                      "mechanism": "password_based",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "redis_type": "single",
                      "server": "127.0.0.1:6379"
                    }
                  }
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/authn-scram-builtin_db.authentication"
                    },
                    {
                      "$ref": "#/components/schemas/authn-jwt.jwks"
                    },
                    {
                      "$ref": "#/components/schemas/authn-jwt.public-key"
                    },
                    {
                      "$ref": "#/components/schemas/authn-jwt.hmac-based"
                    },
                    {
                      "$ref": "#/components/schemas/authn-http.post"
                    },
                    {
                      "$ref": "#/components/schemas/authn-http.get"
                    },
                    {
                      "$ref": "#/components/schemas/authn-redis.sentinel"
                    },
                    {
                      "$ref": "#/components/schemas/authn-redis.cluster"
                    },
                    {
                      "$ref": "#/components/schemas/authn-redis.standalone"
                    },
                    {
                      "$ref": "#/components/schemas/authn-mongodb.sharded-cluster"
                    },
                    {
                      "$ref": "#/components/schemas/authn-mongodb.replica-set"
                    },
                    {
                      "$ref": "#/components/schemas/authn-mongodb.standalone"
                    },
                    {
                      "$ref": "#/components/schemas/authn-postgresql.authentication"
                    },
                    {
                      "$ref": "#/components/schemas/authn-mysql.authentication"
                    },
                    {
                      "$ref": "#/components/schemas/authn-builtin_db.authentication"
                    }
                  ]
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "authentication",
          "authentication config(single listener)"
        ]
      },
      "put": {
        "description": "Update authenticator from listener authentication chain.",
        "parameters": [
          {
            "description": "Listener ID.",
            "example": "tcp:default",
            "in": "path",
            "name": "listener_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Authenticator ID.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "jwt": {
                  "summary": "JWT authentication",
                  "value": {
                    "algorithm": "hmac-based",
                    "mechanism": "jwt",
                    "secret": "mysecret",
                    "secret_base64_encoded": false,
                    "use_jwks": false,
                    "verify_claims": {
                      "username": "${username}"
                    }
                  }
                },
                "password_based:built_in_database": {
                  "summary": "Built-in password_based authentication",
                  "value": {
                    "backend": "built_in_database",
                    "mechanism": "password_based",
                    "password_hash_algorithm": {
                      "name": "sha256",
                      "salt_position": "suffix"
                    },
                    "user_id_type": "username"
                  }
                },
                "password_based:http": {
                  "summary": "password_based authentication through external HTTP API",
                  "value": {
                    "backend": "http",
                    "body": {
                      "password": "${password}",
                      "username": "${username}"
                    },
                    "connect_timeout": 5000,
                    "enable_pipelining": 100,
                    "headers": {
                      "content-type": "application/json"
                    },
                    "mechanism": "password_based",
                    "method": "post",
                    "pool_size": 8,
                    "request_timeout": 5000,
                    "ssl": {
                      "enable": false
                    },
                    "url": "http://127.0.0.1:18083"
                  }
                },
                "password_based:mongodb": {
                  "summary": "password_based authentication with MongoDB backend",
                  "value": {
                    "backend": "mongodb",
                    "collection": "users",
                    "database": "example",
                    "filter": {
                      "username": "${username}"
                    },
                    "is_superuser_field": "is_superuser",
                    "mechanism": "password_based",
                    "password_hash_algorithm": {
                      "name": "sha256",
                      "salt_position": "suffix"
                    },
                    "password_hash_field": "password_hash",
                    "salt_field": "salt",
                    "server": "127.0.0.1:27017"
                  }
                },
                "password_based:redis": {
                  "summary": "password_based authentication with Redis backend",
                  "value": {
                    "backend": "redis",
                    "cmd": "HMGET ${username} password_hash salt",
                    "database": 0,
                    "mechanism": "password_based",
                    "password_hash_algorithm": {
                      "name": "sha256",
                      "salt_position": "suffix"
                    },
                    "redis_type": "single",
                    "server": "127.0.0.1:6379"
                  }
                }
              },
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/authn-scram-builtin_db.authentication"
                  },
                  {
                    "$ref": "#/components/schemas/authn-jwt.jwks"
                  },
                  {
                    "$ref": "#/components/schemas/authn-jwt.public-key"
                  },
                  {
                    "$ref": "#/components/schemas/authn-jwt.hmac-based"
                  },
                  {
                    "$ref": "#/components/schemas/authn-http.post"
                  },
                  {
                    "$ref": "#/components/schemas/authn-http.get"
                  },
                  {
                    "$ref": "#/components/schemas/authn-redis.sentinel"
                  },
                  {
                    "$ref": "#/components/schemas/authn-redis.cluster"
                  },
                  {
                    "$ref": "#/components/schemas/authn-redis.standalone"
                  },
                  {
                    "$ref": "#/components/schemas/authn-mongodb.sharded-cluster"
                  },
                  {
                    "$ref": "#/components/schemas/authn-mongodb.replica-set"
                  },
                  {
                    "$ref": "#/components/schemas/authn-mongodb.standalone"
                  },
                  {
                    "$ref": "#/components/schemas/authn-postgresql.authentication"
                  },
                  {
                    "$ref": "#/components/schemas/authn-mysql.authentication"
                  },
                  {
                    "$ref": "#/components/schemas/authn-builtin_db.authentication"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "jwt": {
                    "summary": "JWT authentication",
                    "value": {
                      "algorithm": "hmac-based",
                      "mechanism": "jwt",
                      "secret": "mysecret",
                      "secret_base64_encoded": false,
                      "use_jwks": false,
                      "verify_claims": {
                        "username": "${username}"
                      }
                    }
                  },
                  "password_based:built_in_database": {
                    "summary": "Built-in password_based authentication",
                    "value": {
                      "backend": "built_in_database",
                      "mechanism": "password_based",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "user_id_type": "username"
                    }
                  },
                  "password_based:http": {
                    "summary": "password_based authentication through external HTTP API",
                    "value": {
                      "backend": "http",
                      "body": {
                        "password": "${password}",
                        "username": "${username}"
                      },
                      "connect_timeout": 5000,
                      "enable_pipelining": 100,
                      "headers": {
                        "content-type": "application/json"
                      },
                      "mechanism": "password_based",
                      "method": "post",
                      "pool_size": 8,
                      "request_timeout": 5000,
                      "ssl": {
                        "enable": false
                      },
                      "url": "http://127.0.0.1:18083"
                    }
                  },
                  "password_based:mongodb": {
                    "summary": "password_based authentication with MongoDB backend",
                    "value": {
                      "backend": "mongodb",
                      "collection": "users",
                      "database": "example",
                      "filter": {
                        "username": "${username}"
                      },
                      "is_superuser_field": "is_superuser",
                      "mechanism": "password_based",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "password_hash_field": "password_hash",
                      "salt_field": "salt",
                      "server": "127.0.0.1:27017"
                    }
                  },
                  "password_based:redis": {
                    "summary": "password_based authentication with Redis backend",
                    "value": {
                      "backend": "redis",
                      "cmd": "HMGET ${username} password_hash salt",
                      "database": 0,
                      "mechanism": "password_based",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "redis_type": "single",
                      "server": "127.0.0.1:6379"
                    }
                  }
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/authn-scram-builtin_db.authentication"
                    },
                    {
                      "$ref": "#/components/schemas/authn-jwt.jwks"
                    },
                    {
                      "$ref": "#/components/schemas/authn-jwt.public-key"
                    },
                    {
                      "$ref": "#/components/schemas/authn-jwt.hmac-based"
                    },
                    {
                      "$ref": "#/components/schemas/authn-http.post"
                    },
                    {
                      "$ref": "#/components/schemas/authn-http.get"
                    },
                    {
                      "$ref": "#/components/schemas/authn-redis.sentinel"
                    },
                    {
                      "$ref": "#/components/schemas/authn-redis.cluster"
                    },
                    {
                      "$ref": "#/components/schemas/authn-redis.standalone"
                    },
                    {
                      "$ref": "#/components/schemas/authn-mongodb.sharded-cluster"
                    },
                    {
                      "$ref": "#/components/schemas/authn-mongodb.replica-set"
                    },
                    {
                      "$ref": "#/components/schemas/authn-mongodb.standalone"
                    },
                    {
                      "$ref": "#/components/schemas/authn-postgresql.authentication"
                    },
                    {
                      "$ref": "#/components/schemas/authn-mysql.authentication"
                    },
                    {
                      "$ref": "#/components/schemas/authn-builtin_db.authentication"
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad Request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "409": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "ALREADY_EXISTS"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "ALREADY_EXISTS",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "authentication",
          "authentication config(single listener)"
        ]
      }
    },
    "/nodes/{node}/stats": {
      "get": {
        "description": "Get node stats",
        "parameters": [
          {
            "$ref": "#/components/parameters/emqx_mgmt_api_nodes.node_name"
          }
        ],
        "responses": {
          "200": {
            "description": "Get node stats successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx_mgmt_api_stats.node_stats_data"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "SOURCE_ERROR"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Node error",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "nodes"
        ]
      }
    },
    "/exhooks/{name}": {
      "delete": {
        "description": "Delete the server",
        "parameters": [
          {
            "description": "The Exhook server name",
            "example": "default",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": ""
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Server not found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "500": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_RPC"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad RPC",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "exhooks"
        ]
      },
      "get": {
        "description": "Get the detail information of Exhook server",
        "parameters": [
          {
            "description": "The Exhook server name",
            "example": "default",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/exhook.detail_server_info"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Server not found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "exhooks"
        ]
      },
      "put": {
        "description": "Update the server",
        "parameters": [
          {
            "description": "The Exhook server name",
            "example": "default",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "example": {
                "auto_reconnect": "60s",
                "enable": true,
                "failed_action": "deny",
                "name": "default",
                "pool_size": 8,
                "request_timeout": "5s",
                "ssl": {
                  "cacertfile": "/mnt/code/src/emqx/0/_build/emqx/rel/emqx/etc/certs/cacert.pem",
                  "certfile": "/mnt/code/src/emqx/0/_build/emqx/rel/emqx/etc/certs/cert.pem",
                  "enable": false,
                  "keyfile": "/mnt/code/src/emqx/0/_build/emqx/rel/emqx/etc/certs/key.pem"
                },
                "url": "http://127.0.0.1:8081"
              },
              "schema": {
                "$ref": "#/components/schemas/exhook.server_config"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/exhook.detail_server_info"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad Request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Server not found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "500": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_RPC"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad RPC",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "exhooks"
        ]
      }
    },
    "/prometheus": {
      "get": {
        "description": "Get Prometheus config info",
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": {
                  "enable": true,
                  "interval": "15s",
                  "push_gateway_server": "http://127.0.0.1:9091"
                },
                "schema": {
                  "$ref": "#/components/schemas/prometheus.prometheus"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "prometheus"
        ]
      },
      "put": {
        "description": "Update Prometheus config",
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "example": {
                "enable": true,
                "interval": "15s",
                "push_gateway_server": "http://127.0.0.1:9091"
              },
              "schema": {
                "$ref": "#/components/schemas/prometheus.prometheus"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": {
                  "enable": true,
                  "interval": "15s",
                  "push_gateway_server": "http://127.0.0.1:9091"
                },
                "schema": {
                  "$ref": "#/components/schemas/prometheus.prometheus"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "prometheus"
        ]
      }
    },
    "/mqtt/auto_subscribe": {
      "get": {
        "description": "Get auto subscribe topic list",
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/auto_subscribe.auto_subscribe"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "mqtt"
        ]
      },
      "put": {
        "description": "Update auto subscribe topic list",
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/auto_subscribe.auto_subscribe"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/auto_subscribe.auto_subscribe"
                }
              }
            }
          },
          "409": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "EXCEED_LIMIT"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Auto Subscribe topics max limit",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "mqtt"
        ]
      }
    },
    "/nodes/{node}/bridges/{id}/operation/{operation}": {
      "post": {
        "description": "Stop/Restart bridges on a specific node.</br> NOTE: It's not allowed to disable/enable bridges on a single node.",
        "parameters": [
          {
            "description": "The node name, e.g. emqx@127.0.0.1",
            "example": "emqx@127.0.0.1",
            "in": "path",
            "name": "node",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The bridge Id. Must be of format {type}:{name}",
            "example": "webhook:my_webhook",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Operations can be one of: stop, restart",
            "example": "start",
            "in": "path",
            "name": "operation",
            "required": true,
            "schema": {
              "enum": [
                "stop",
                "restart"
              ],
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Operation success"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "INVALID_ID"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad bridge ID",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "403": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "FORBIDDEN_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "forbidden operation",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "503": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "SERVICE_UNAVAILABLE"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Service unavailable",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "summary": "Stop/Restart Bridge",
        "tags": [
          "bridges"
        ]
      }
    },
    "/gateway/lwm2m/clients/{clientid}/read": {
      "post": {
        "description": "Send a read command to a resource",
        "parameters": [
          {
            "example": "urn:oma:lwm2m:oma:2",
            "in": "path",
            "name": "clientid",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "example": "/3/0/7",
            "in": "query",
            "name": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "No Content"
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "CLIENT_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "clientid not found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "lwm2m"
        ]
      }
    },
    "/mqtt/delayed/messages/{node}/{msgid}": {
      "delete": {
        "description": "Delete delayed message",
        "parameters": [
          {
            "description": "The node where message from",
            "in": "path",
            "name": "node",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Delayed Message ID",
            "in": "path",
            "name": "msgid",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Delete delayed message success"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "MESSAGE_ID_SCHEMA_ERROR",
                        "INVALID_NODE"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad Message ID format",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "MESSAGE_ID_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Message ID not found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "mqtt"
        ]
      },
      "get": {
        "description": "View delayed message",
        "parameters": [
          {
            "description": "The node where message from",
            "in": "path",
            "name": "node",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Delayed Message ID",
            "in": "path",
            "name": "msgid",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx_delayed_api.message_without_payload"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "MESSAGE_ID_SCHEMA_ERROR",
                        "INVALID_NODE"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad Message ID format",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "MESSAGE_ID_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Message ID not found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "mqtt"
        ]
      }
    },
    "/gateway/{name}/authentication": {
      "delete": {
        "description": "Remove the gateway authentication",
        "parameters": [
          {
            "description": "Gateway Name",
            "example": "",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Deleted"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "gateway"
        ]
      },
      "get": {
        "description": "Get the gateway authentication",
        "parameters": [
          {
            "description": "Gateway Name",
            "example": "",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "jwt": {
                    "summary": "JWT authentication",
                    "value": {
                      "algorithm": "hmac-based",
                      "mechanism": "jwt",
                      "secret": "mysecret",
                      "secret_base64_encoded": false,
                      "use_jwks": false,
                      "verify_claims": {
                        "username": "${username}"
                      }
                    }
                  },
                  "password_based:built_in_database": {
                    "summary": "Built-in password_based authentication",
                    "value": {
                      "backend": "built_in_database",
                      "mechanism": "password_based",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "user_id_type": "username"
                    }
                  },
                  "password_based:http": {
                    "summary": "password_based authentication through external HTTP API",
                    "value": {
                      "backend": "http",
                      "body": {
                        "password": "${password}",
                        "username": "${username}"
                      },
                      "connect_timeout": 5000,
                      "enable_pipelining": 100,
                      "headers": {
                        "content-type": "application/json"
                      },
                      "mechanism": "password_based",
                      "method": "post",
                      "pool_size": 8,
                      "request_timeout": 5000,
                      "ssl": {
                        "enable": false
                      },
                      "url": "http://127.0.0.1:18083"
                    }
                  },
                  "password_based:mongodb": {
                    "summary": "password_based authentication with MongoDB backend",
                    "value": {
                      "backend": "mongodb",
                      "collection": "users",
                      "database": "example",
                      "filter": {
                        "username": "${username}"
                      },
                      "is_superuser_field": "is_superuser",
                      "mechanism": "password_based",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "password_hash_field": "password_hash",
                      "salt_field": "salt",
                      "server": "127.0.0.1:27017"
                    }
                  },
                  "password_based:redis": {
                    "summary": "password_based authentication with Redis backend",
                    "value": {
                      "backend": "redis",
                      "cmd": "HMGET ${username} password_hash salt",
                      "database": 0,
                      "mechanism": "password_based",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "redis_type": "single",
                      "server": "127.0.0.1:6379"
                    }
                  }
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/authn-jwt.jwks"
                    },
                    {
                      "$ref": "#/components/schemas/authn-jwt.public-key"
                    },
                    {
                      "$ref": "#/components/schemas/authn-jwt.hmac-based"
                    },
                    {
                      "$ref": "#/components/schemas/authn-http.post"
                    },
                    {
                      "$ref": "#/components/schemas/authn-http.get"
                    },
                    {
                      "$ref": "#/components/schemas/authn-redis.sentinel"
                    },
                    {
                      "$ref": "#/components/schemas/authn-redis.cluster"
                    },
                    {
                      "$ref": "#/components/schemas/authn-redis.standalone"
                    },
                    {
                      "$ref": "#/components/schemas/authn-mongodb.sharded-cluster"
                    },
                    {
                      "$ref": "#/components/schemas/authn-mongodb.replica-set"
                    },
                    {
                      "$ref": "#/components/schemas/authn-mongodb.standalone"
                    },
                    {
                      "$ref": "#/components/schemas/authn-postgresql.authentication"
                    },
                    {
                      "$ref": "#/components/schemas/authn-mysql.authentication"
                    },
                    {
                      "$ref": "#/components/schemas/authn-builtin_db.authentication"
                    }
                  ]
                }
              }
            }
          },
          "204": {
            "description": "Authentication does not initiated"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "gateway"
        ]
      },
      "post": {
        "description": "Add authentication for the gateway",
        "parameters": [
          {
            "description": "Gateway Name",
            "example": "",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "jwt": {
                  "summary": "JWT authentication",
                  "value": {
                    "algorithm": "hmac-based",
                    "mechanism": "jwt",
                    "secret": "mysecret",
                    "secret_base64_encoded": false,
                    "use_jwks": false,
                    "verify_claims": {
                      "username": "${username}"
                    }
                  }
                },
                "password_based:built_in_database": {
                  "summary": "Built-in password_based authentication",
                  "value": {
                    "backend": "built_in_database",
                    "mechanism": "password_based",
                    "password_hash_algorithm": {
                      "name": "sha256",
                      "salt_position": "suffix"
                    },
                    "user_id_type": "username"
                  }
                },
                "password_based:http": {
                  "summary": "password_based authentication through external HTTP API",
                  "value": {
                    "backend": "http",
                    "body": {
                      "password": "${password}",
                      "username": "${username}"
                    },
                    "connect_timeout": 5000,
                    "enable_pipelining": 100,
                    "headers": {
                      "content-type": "application/json"
                    },
                    "mechanism": "password_based",
                    "method": "post",
                    "pool_size": 8,
                    "request_timeout": 5000,
                    "ssl": {
                      "enable": false
                    },
                    "url": "http://127.0.0.1:18083"
                  }
                },
                "password_based:mongodb": {
                  "summary": "password_based authentication with MongoDB backend",
                  "value": {
                    "backend": "mongodb",
                    "collection": "users",
                    "database": "example",
                    "filter": {
                      "username": "${username}"
                    },
                    "is_superuser_field": "is_superuser",
                    "mechanism": "password_based",
                    "password_hash_algorithm": {
                      "name": "sha256",
                      "salt_position": "suffix"
                    },
                    "password_hash_field": "password_hash",
                    "salt_field": "salt",
                    "server": "127.0.0.1:27017"
                  }
                },
                "password_based:redis": {
                  "summary": "password_based authentication with Redis backend",
                  "value": {
                    "backend": "redis",
                    "cmd": "HMGET ${username} password_hash salt",
                    "database": 0,
                    "mechanism": "password_based",
                    "password_hash_algorithm": {
                      "name": "sha256",
                      "salt_position": "suffix"
                    },
                    "redis_type": "single",
                    "server": "127.0.0.1:6379"
                  }
                }
              },
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/authn-jwt.jwks"
                  },
                  {
                    "$ref": "#/components/schemas/authn-jwt.public-key"
                  },
                  {
                    "$ref": "#/components/schemas/authn-jwt.hmac-based"
                  },
                  {
                    "$ref": "#/components/schemas/authn-http.post"
                  },
                  {
                    "$ref": "#/components/schemas/authn-http.get"
                  },
                  {
                    "$ref": "#/components/schemas/authn-redis.sentinel"
                  },
                  {
                    "$ref": "#/components/schemas/authn-redis.cluster"
                  },
                  {
                    "$ref": "#/components/schemas/authn-redis.standalone"
                  },
                  {
                    "$ref": "#/components/schemas/authn-mongodb.sharded-cluster"
                  },
                  {
                    "$ref": "#/components/schemas/authn-mongodb.replica-set"
                  },
                  {
                    "$ref": "#/components/schemas/authn-mongodb.standalone"
                  },
                  {
                    "$ref": "#/components/schemas/authn-postgresql.authentication"
                  },
                  {
                    "$ref": "#/components/schemas/authn-mysql.authentication"
                  },
                  {
                    "$ref": "#/components/schemas/authn-builtin_db.authentication"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "jwt": {
                    "summary": "JWT authentication",
                    "value": {
                      "algorithm": "hmac-based",
                      "mechanism": "jwt",
                      "secret": "mysecret",
                      "secret_base64_encoded": false,
                      "use_jwks": false,
                      "verify_claims": {
                        "username": "${username}"
                      }
                    }
                  },
                  "password_based:built_in_database": {
                    "summary": "Built-in password_based authentication",
                    "value": {
                      "backend": "built_in_database",
                      "mechanism": "password_based",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "user_id_type": "username"
                    }
                  },
                  "password_based:http": {
                    "summary": "password_based authentication through external HTTP API",
                    "value": {
                      "backend": "http",
                      "body": {
                        "password": "${password}",
                        "username": "${username}"
                      },
                      "connect_timeout": 5000,
                      "enable_pipelining": 100,
                      "headers": {
                        "content-type": "application/json"
                      },
                      "mechanism": "password_based",
                      "method": "post",
                      "pool_size": 8,
                      "request_timeout": 5000,
                      "ssl": {
                        "enable": false
                      },
                      "url": "http://127.0.0.1:18083"
                    }
                  },
                  "password_based:mongodb": {
                    "summary": "password_based authentication with MongoDB backend",
                    "value": {
                      "backend": "mongodb",
                      "collection": "users",
                      "database": "example",
                      "filter": {
                        "username": "${username}"
                      },
                      "is_superuser_field": "is_superuser",
                      "mechanism": "password_based",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "password_hash_field": "password_hash",
                      "salt_field": "salt",
                      "server": "127.0.0.1:27017"
                    }
                  },
                  "password_based:redis": {
                    "summary": "password_based authentication with Redis backend",
                    "value": {
                      "backend": "redis",
                      "cmd": "HMGET ${username} password_hash salt",
                      "database": 0,
                      "mechanism": "password_based",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "redis_type": "single",
                      "server": "127.0.0.1:6379"
                    }
                  }
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/authn-jwt.jwks"
                    },
                    {
                      "$ref": "#/components/schemas/authn-jwt.public-key"
                    },
                    {
                      "$ref": "#/components/schemas/authn-jwt.hmac-based"
                    },
                    {
                      "$ref": "#/components/schemas/authn-http.post"
                    },
                    {
                      "$ref": "#/components/schemas/authn-http.get"
                    },
                    {
                      "$ref": "#/components/schemas/authn-redis.sentinel"
                    },
                    {
                      "$ref": "#/components/schemas/authn-redis.cluster"
                    },
                    {
                      "$ref": "#/components/schemas/authn-redis.standalone"
                    },
                    {
                      "$ref": "#/components/schemas/authn-mongodb.sharded-cluster"
                    },
                    {
                      "$ref": "#/components/schemas/authn-mongodb.replica-set"
                    },
                    {
                      "$ref": "#/components/schemas/authn-mongodb.standalone"
                    },
                    {
                      "$ref": "#/components/schemas/authn-postgresql.authentication"
                    },
                    {
                      "$ref": "#/components/schemas/authn-mysql.authentication"
                    },
                    {
                      "$ref": "#/components/schemas/authn-builtin_db.authentication"
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "gateway"
        ]
      },
      "put": {
        "description": "Update authentication for the gateway",
        "parameters": [
          {
            "description": "Gateway Name",
            "example": "",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "jwt": {
                  "summary": "JWT authentication",
                  "value": {
                    "algorithm": "hmac-based",
                    "mechanism": "jwt",
                    "secret": "mysecret",
                    "secret_base64_encoded": false,
                    "use_jwks": false,
                    "verify_claims": {
                      "username": "${username}"
                    }
                  }
                },
                "password_based:built_in_database": {
                  "summary": "Built-in password_based authentication",
                  "value": {
                    "backend": "built_in_database",
                    "mechanism": "password_based",
                    "password_hash_algorithm": {
                      "name": "sha256",
                      "salt_position": "suffix"
                    },
                    "user_id_type": "username"
                  }
                },
                "password_based:http": {
                  "summary": "password_based authentication through external HTTP API",
                  "value": {
                    "backend": "http",
                    "body": {
                      "password": "${password}",
                      "username": "${username}"
                    },
                    "connect_timeout": 5000,
                    "enable_pipelining": 100,
                    "headers": {
                      "content-type": "application/json"
                    },
                    "mechanism": "password_based",
                    "method": "post",
                    "pool_size": 8,
                    "request_timeout": 5000,
                    "ssl": {
                      "enable": false
                    },
                    "url": "http://127.0.0.1:18083"
                  }
                },
                "password_based:mongodb": {
                  "summary": "password_based authentication with MongoDB backend",
                  "value": {
                    "backend": "mongodb",
                    "collection": "users",
                    "database": "example",
                    "filter": {
                      "username": "${username}"
                    },
                    "is_superuser_field": "is_superuser",
                    "mechanism": "password_based",
                    "password_hash_algorithm": {
                      "name": "sha256",
                      "salt_position": "suffix"
                    },
                    "password_hash_field": "password_hash",
                    "salt_field": "salt",
                    "server": "127.0.0.1:27017"
                  }
                },
                "password_based:redis": {
                  "summary": "password_based authentication with Redis backend",
                  "value": {
                    "backend": "redis",
                    "cmd": "HMGET ${username} password_hash salt",
                    "database": 0,
                    "mechanism": "password_based",
                    "password_hash_algorithm": {
                      "name": "sha256",
                      "salt_position": "suffix"
                    },
                    "redis_type": "single",
                    "server": "127.0.0.1:6379"
                  }
                }
              },
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/authn-jwt.jwks"
                  },
                  {
                    "$ref": "#/components/schemas/authn-jwt.public-key"
                  },
                  {
                    "$ref": "#/components/schemas/authn-jwt.hmac-based"
                  },
                  {
                    "$ref": "#/components/schemas/authn-http.post"
                  },
                  {
                    "$ref": "#/components/schemas/authn-http.get"
                  },
                  {
                    "$ref": "#/components/schemas/authn-redis.sentinel"
                  },
                  {
                    "$ref": "#/components/schemas/authn-redis.cluster"
                  },
                  {
                    "$ref": "#/components/schemas/authn-redis.standalone"
                  },
                  {
                    "$ref": "#/components/schemas/authn-mongodb.sharded-cluster"
                  },
                  {
                    "$ref": "#/components/schemas/authn-mongodb.replica-set"
                  },
                  {
                    "$ref": "#/components/schemas/authn-mongodb.standalone"
                  },
                  {
                    "$ref": "#/components/schemas/authn-postgresql.authentication"
                  },
                  {
                    "$ref": "#/components/schemas/authn-mysql.authentication"
                  },
                  {
                    "$ref": "#/components/schemas/authn-builtin_db.authentication"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "jwt": {
                    "summary": "JWT authentication",
                    "value": {
                      "algorithm": "hmac-based",
                      "mechanism": "jwt",
                      "secret": "mysecret",
                      "secret_base64_encoded": false,
                      "use_jwks": false,
                      "verify_claims": {
                        "username": "${username}"
                      }
                    }
                  },
                  "password_based:built_in_database": {
                    "summary": "Built-in password_based authentication",
                    "value": {
                      "backend": "built_in_database",
                      "mechanism": "password_based",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "user_id_type": "username"
                    }
                  },
                  "password_based:http": {
                    "summary": "password_based authentication through external HTTP API",
                    "value": {
                      "backend": "http",
                      "body": {
                        "password": "${password}",
                        "username": "${username}"
                      },
                      "connect_timeout": 5000,
                      "enable_pipelining": 100,
                      "headers": {
                        "content-type": "application/json"
                      },
                      "mechanism": "password_based",
                      "method": "post",
                      "pool_size": 8,
                      "request_timeout": 5000,
                      "ssl": {
                        "enable": false
                      },
                      "url": "http://127.0.0.1:18083"
                    }
                  },
                  "password_based:mongodb": {
                    "summary": "password_based authentication with MongoDB backend",
                    "value": {
                      "backend": "mongodb",
                      "collection": "users",
                      "database": "example",
                      "filter": {
                        "username": "${username}"
                      },
                      "is_superuser_field": "is_superuser",
                      "mechanism": "password_based",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "password_hash_field": "password_hash",
                      "salt_field": "salt",
                      "server": "127.0.0.1:27017"
                    }
                  },
                  "password_based:redis": {
                    "summary": "password_based authentication with Redis backend",
                    "value": {
                      "backend": "redis",
                      "cmd": "HMGET ${username} password_hash salt",
                      "database": 0,
                      "mechanism": "password_based",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "redis_type": "single",
                      "server": "127.0.0.1:6379"
                    }
                  }
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/authn-jwt.jwks"
                    },
                    {
                      "$ref": "#/components/schemas/authn-jwt.public-key"
                    },
                    {
                      "$ref": "#/components/schemas/authn-jwt.hmac-based"
                    },
                    {
                      "$ref": "#/components/schemas/authn-http.post"
                    },
                    {
                      "$ref": "#/components/schemas/authn-http.get"
                    },
                    {
                      "$ref": "#/components/schemas/authn-redis.sentinel"
                    },
                    {
                      "$ref": "#/components/schemas/authn-redis.cluster"
                    },
                    {
                      "$ref": "#/components/schemas/authn-redis.standalone"
                    },
                    {
                      "$ref": "#/components/schemas/authn-mongodb.sharded-cluster"
                    },
                    {
                      "$ref": "#/components/schemas/authn-mongodb.replica-set"
                    },
                    {
                      "$ref": "#/components/schemas/authn-mongodb.standalone"
                    },
                    {
                      "$ref": "#/components/schemas/authn-postgresql.authentication"
                    },
                    {
                      "$ref": "#/components/schemas/authn-mysql.authentication"
                    },
                    {
                      "$ref": "#/components/schemas/authn-builtin_db.authentication"
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "gateway"
        ]
      }
    },
    "/monitor_current/nodes/{node}": {
      "get": {
        "description": "Node current status. Gauge and rate.",
        "parameters": [
          {
            "description": "EMQX node name.",
            "example": "emqx@127.0.0.1",
            "in": "path",
            "name": "node",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx_dashboard_monitor_api.sampler_current"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_RPC"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad RPC",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "dashboard"
        ]
      }
    },
    "/telemetry/status": {
      "get": {
        "description": "Get telemetry status",
        "parameters": [],
        "responses": {
          "200": {
            "description": "Get telemetry status",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx_telemetry_api.status"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "telemetry"
        ]
      },
      "put": {
        "description": "Enable or disable telemetry",
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/emqx_telemetry_api.status"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Enable or disable telemetry",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx_telemetry_api.status"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "telemetry"
        ]
      }
    },
    "/gateway/{name}/clients/{clientid}/subscriptions": {
      "get": {
        "description": "Get the gateway client subscriptions",
        "parameters": [
          {
            "description": "Client ID",
            "in": "path",
            "name": "clientid",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Gateway Name",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "general_subscription_list": {
                    "summary": "A General Subscription List",
                    "value": [
                      {
                        "nl": 0,
                        "qos": 1,
                        "rap": 0,
                        "rh": 0,
                        "topic": "test/topic"
                      }
                    ]
                  },
                  "stomp_subscription_list": {
                    "summary": "The Stomp Subscription List",
                    "value": [
                      "example_stomp_subscription"
                    ]
                  }
                },
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/emqx_gateway_api_clients.subscription"
                  },
                  "type": "array"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "gateway"
        ]
      },
      "post": {
        "description": "Create a subscription membership",
        "parameters": [
          {
            "description": "Client ID",
            "in": "path",
            "name": "clientid",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Gateway Name",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "general_subscription": {
                  "summary": "A General Subscription",
                  "value": {
                    "nl": 0,
                    "qos": 1,
                    "rap": 0,
                    "rh": 0,
                    "topic": "test/topic"
                  }
                },
                "stomp_subscription": {
                  "summary": "A Stomp Subscription",
                  "value": {
                    "nl": 0,
                    "qos": 1,
                    "rap": 0,
                    "rh": 0,
                    "sub_props": {
                      "subid": "10"
                    },
                    "topic": "stomp/topic"
                  }
                }
              },
              "schema": {
                "$ref": "#/components/schemas/emqx_gateway_api_clients.subscription"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "general_subscription": {
                    "summary": "A General Subscription",
                    "value": {
                      "nl": 0,
                      "qos": 1,
                      "rap": 0,
                      "rh": 0,
                      "topic": "test/topic"
                    }
                  },
                  "stomp_subscription": {
                    "summary": "A Stomp Subscription",
                    "value": {
                      "nl": 0,
                      "qos": 1,
                      "rap": 0,
                      "rh": 0,
                      "sub_props": {
                        "subid": "10"
                      },
                      "topic": "stomp/topic"
                    }
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/emqx_gateway_api_clients.subscription"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "gateway"
        ]
      }
    },
    "/authentication/{id}/users": {
      "get": {
        "description": "List users in authenticator in global authentication chain.",
        "parameters": [
          {
            "description": "Authenticator ID.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "$ref": "#/components/parameters/public.page"
          },
          {
            "$ref": "#/components/parameters/public.limit"
          },
          {
            "description": "Fuzzy search user_id (username or clientid).",
            "in": "query",
            "name": "like_user_id",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Is superuser",
            "in": "query",
            "name": "is_superuser",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": {
                  "data": [
                    {
                      "user_id": "user1"
                    },
                    {
                      "is_superuser": true,
                      "user_id": "user2"
                    }
                  ],
                  "meta": {
                    "count": 300,
                    "limit": 20,
                    "page": 0
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/emqx_authn_api.response_users"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "authentication",
          "authentication config(global)"
        ]
      },
      "post": {
        "description": "Create users for authenticator in global authentication chain.",
        "parameters": [
          {
            "description": "Authenticator ID.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "regular_user": {
                  "summary": "Regular user",
                  "value": {
                    "password": "secret",
                    "user_id": "user1"
                  }
                },
                "super_user": {
                  "summary": "Superuser",
                  "value": {
                    "is_superuser": true,
                    "password": "secret",
                    "user_id": "user2"
                  }
                }
              },
              "schema": {
                "$ref": "#/components/schemas/emqx_authn_api.request_user_create"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "regular_user": {
                    "summary": "Regular user",
                    "value": {
                      "user_id": "user1"
                    }
                  },
                  "super_user": {
                    "summary": "Superuser",
                    "value": {
                      "is_superuser": true,
                      "user_id": "user2"
                    }
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/emqx_authn_api.response_user"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad Request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "authentication",
          "authentication config(global)"
        ]
      }
    },
    "/authorization/sources/built_in_database/purge-all": {
      "delete": {
        "description": "Purge all records for username/clientid/all",
        "parameters": [],
        "responses": {
          "204": {
            "description": "Deleted"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad Request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "authorization"
        ]
      }
    },
    "/cluster": {
      "get": {
        "description": "Get cluster info",
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "name": {
                      "description": "Cluster name",
                      "type": "string"
                    },
                    "nodes": {
                      "description": "Node name",
                      "items": {
                        "type": "string"
                      },
                      "type": "array"
                    },
                    "self": {
                      "description": "Self node name",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "cluster"
        ]
      }
    },
    "/plugins/{name}/{action}": {
      "put": {
        "description": "start/stop a installed plugin.</br>- **start**: start the plugin.</br>- **stop**: stop the plugin.</br>",
        "parameters": [
          {
            "$ref": "#/components/parameters/plugins.name"
          },
          {
            "description": "Action",
            "in": "path",
            "name": "action",
            "required": true,
            "schema": {
              "enum": [
                "start",
                "stop"
              ],
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Plugin Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "plugins"
        ]
      }
    },
    "/mqtt/sys_topics": {
      "get": {
        "description": "Get System Topics config",
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": {
                  "sys_event_messages": {
                    "client_connected": true,
                    "client_disconnected": true,
                    "client_subscribed": false,
                    "client_unsubscribed": false
                  },
                  "sys_heartbeat_interval": "30s",
                  "sys_msg_interval": "1m"
                },
                "schema": {
                  "$ref": "#/components/schemas/broker.sys_topics"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "sys"
        ]
      },
      "put": {
        "description": "Update System Topics config",
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "example": {
                "sys_event_messages": {
                  "client_connected": true,
                  "client_disconnected": true,
                  "client_subscribed": false,
                  "client_unsubscribed": false
                },
                "sys_heartbeat_interval": "30s",
                "sys_msg_interval": "1m"
              },
              "schema": {
                "$ref": "#/components/schemas/broker.sys_topics"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": {
                  "sys_event_messages": {
                    "client_connected": true,
                    "client_disconnected": true,
                    "client_subscribed": false,
                    "client_unsubscribed": false
                  },
                  "sys_heartbeat_interval": "30s",
                  "sys_msg_interval": "1m"
                },
                "schema": {
                  "$ref": "#/components/schemas/broker.sys_topics"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "sys"
        ]
      }
    },
    "/gateway/{name}/clients": {
      "get": {
        "description": "Get the gateway client list",
        "parameters": [
          {
            "description": "Gateway Name",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Match the client's node name",
            "example": "",
            "in": "query",
            "name": "node",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Match the client's ID",
            "example": "",
            "in": "query",
            "name": "clientid",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Match the client's Username",
            "example": "",
            "in": "query",
            "name": "username",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Match the client's ip address",
            "example": "",
            "in": "query",
            "name": "ip_address",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Match the client's connection state",
            "example": "",
            "in": "query",
            "name": "conn_state",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Match the client's protocol version",
            "example": "",
            "in": "query",
            "name": "proto_ver",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Match the client's clean start flag",
            "example": "",
            "in": "query",
            "name": "clean_start",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "description": "Use sub-string to match client's ID",
            "example": "",
            "in": "query",
            "name": "like_clientid",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Use sub-string to match client's username",
            "example": "",
            "in": "query",
            "name": "like_username",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Match the session created datetime greater than a certain value",
            "example": "",
            "in": "query",
            "name": "gte_created_at",
            "required": false,
            "schema": {
              "oneOf": [
                {
                  "description": "epoch-millisecond",
                  "example": 1640995200000,
                  "type": "integer"
                },
                {
                  "example": "2022-01-01T00:00:00.000Z",
                  "format": "date-time",
                  "type": "string"
                }
              ]
            }
          },
          {
            "description": "Match the session created datetime less than a certain value",
            "example": "",
            "in": "query",
            "name": "lte_created_at",
            "required": false,
            "schema": {
              "oneOf": [
                {
                  "description": "epoch-millisecond",
                  "example": 1640995200000,
                  "type": "integer"
                },
                {
                  "example": "2022-01-01T00:00:00.000Z",
                  "format": "date-time",
                  "type": "string"
                }
              ]
            }
          },
          {
            "description": "Match the client socket connected datetime greater than a certain value",
            "example": "",
            "in": "query",
            "name": "gte_connected_at",
            "required": false,
            "schema": {
              "oneOf": [
                {
                  "description": "epoch-millisecond",
                  "example": 1640995200000,
                  "type": "integer"
                },
                {
                  "example": "2022-01-01T00:00:00.000Z",
                  "format": "date-time",
                  "type": "string"
                }
              ]
            }
          },
          {
            "description": "Match the client socket connected datatime less than a certain value",
            "example": "",
            "in": "query",
            "name": "lte_connected_at",
            "required": false,
            "schema": {
              "oneOf": [
                {
                  "description": "epoch-millisecond",
                  "example": 1640995200000,
                  "type": "integer"
                },
                {
                  "example": "2022-01-01T00:00:00.000Z",
                  "format": "date-time",
                  "type": "string"
                }
              ]
            }
          },
          {
            "description": "Match the lwm2m client's endpoint name",
            "example": "",
            "in": "query",
            "name": "endpoint_name",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Use sub-string to match lwm2m client's endpoint name",
            "example": "",
            "in": "query",
            "name": "like_endpoint_name",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Match the lwm2m client registered lifetime greater than a certain value",
            "example": "",
            "in": "query",
            "name": "gte_lifetime",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Match the lwm2m client registered lifetime less than a certain value",
            "example": "",
            "in": "query",
            "name": "lte_lifetime",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Page number of the results to fetch.",
            "example": 1,
            "in": "query",
            "name": "page",
            "schema": {
              "default": 1,
              "minimum": 1,
              "type": "integer"
            }
          },
          {
            "description": "Results per page(max 1000)",
            "example": 50,
            "in": "query",
            "name": "limit",
            "schema": {
              "default": 100,
              "maximum": 1000,
              "minimum": 1,
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "general_client_list": {
                    "summary": "General Client List",
                    "value": [
                      {
                        "mqueue_len": 0,
                        "send_oct": 61,
                        "ip_address": "127.0.0.1",
                        "recv_cnt": 1,
                        "connected_at": "2021-12-07T10:44:02.721+08:00",
                        "expiry_interval": 0,
                        "connected": true,
                        "disconnected_at": null,
                        "mqueue_dropped": 0,
                        "keepalive": 0,
                        "clean_start": true,
                        "created_at": "2021-12-07T10:44:02.721+08:00",
                        "send_msg": 0,
                        "reductions": 72022,
                        "subscriptions_max": "infinity",
                        "send_pkt": 1,
                        "inflight_max": "infinity",
                        "recv_msg": 0,
                        "mqueue_max": "infinity",
                        "inflight_cnt": 0,
                        "mailbox_len": 0,
                        "recv_oct": 56,
                        "clientid": "MzAyMzEzNTUwNzk1NDA1MzYyMzIwNzUxNjQwMTY1NzQ0NjE",
                        "recv_pkt": 1,
                        "proto_ver": "1.0",
                        "is_bridge": false,
                        "send_cnt": 1,
                        "proto_name": "STOMP",
                        "node": "emqx@127.0.0.1",
                        "username": "guest",
                        "heap_size": 4185,
                        "port": 50675,
                        "subscriptions_cnt": 0,
                        "awaiting_rel_cnt": 0,
                        "awaiting_rel_max": "infinity"
                      }
                    ]
                  },
                  "lwm2m_client_list": {
                    "summary": "LwM2M Client List",
                    "value": [
                      {
                        "mqueue_len": 0,
                        "send_oct": 61,
                        "ip_address": "127.0.0.1",
                        "recv_cnt": 1,
                        "connected_at": "2021-12-07T10:44:02.721+08:00",
                        "expiry_interval": 0,
                        "connected": true,
                        "disconnected_at": null,
                        "endpoint_name": "urn:imei:154928475237123",
                        "mqueue_dropped": 0,
                        "keepalive": 0,
                        "clean_start": true,
                        "created_at": "2021-12-07T10:44:02.721+08:00",
                        "send_msg": 0,
                        "reductions": 72022,
                        "subscriptions_max": "infinity",
                        "send_pkt": 1,
                        "inflight_max": "infinity",
                        "recv_msg": 0,
                        "lifetime": 86400,
                        "mqueue_max": "infinity",
                        "inflight_cnt": 0,
                        "mailbox_len": 0,
                        "recv_oct": 56,
                        "clientid": "MzAyMzEzNTUwNzk1NDA1MzYyMzIwNzUxNjQwMTY1NzQ0NjE",
                        "recv_pkt": 1,
                        "proto_ver": "1.0",
                        "is_bridge": false,
                        "send_cnt": 1,
                        "proto_name": "LwM2M",
                        "node": "emqx@127.0.0.1",
                        "username": "guest",
                        "heap_size": 4185,
                        "port": 50675,
                        "subscriptions_cnt": 0,
                        "awaiting_rel_cnt": 0,
                        "awaiting_rel_max": "infinity"
                      }
                    ]
                  }
                },
                "schema": {
                  "oneOf": [
                    {
                      "items": {
                        "$ref": "#/components/schemas/emqx_gateway_api_clients.exproto_client"
                      },
                      "type": "array"
                    },
                    {
                      "items": {
                        "$ref": "#/components/schemas/emqx_gateway_api_clients.lwm2m_client"
                      },
                      "type": "array"
                    },
                    {
                      "items": {
                        "$ref": "#/components/schemas/emqx_gateway_api_clients.coap_client"
                      },
                      "type": "array"
                    },
                    {
                      "items": {
                        "$ref": "#/components/schemas/emqx_gateway_api_clients.mqttsn_client"
                      },
                      "type": "array"
                    },
                    {
                      "items": {
                        "$ref": "#/components/schemas/emqx_gateway_api_clients.stomp_client"
                      },
                      "type": "array"
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "gateway"
        ]
      }
    },
    "/publish/bulk": {
      "post": {
        "description": "Publish Messages",
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "items": {
                  "$ref": "#/components/schemas/emqx_mgmt_api_publish.publish_message"
                },
                "type": "array"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/emqx_mgmt_api_publish.publish_message_info"
                  },
                  "type": "array"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "publish"
        ]
      }
    },
    "/rule_test": {
      "post": {
        "description": "Test a rule",
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/emqx_rule_api_schema.rule_test"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Rule Test Pass"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Invalid Parameters",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "412": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_MATCH"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "SQL Not Match",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "summary": "Test a Rule",
        "tags": [
          "rules"
        ]
      }
    },
    "/configs/sysmon": {
      "get": {
        "description": "Get the sub-configurations under *sysmon*",
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/broker.sysmon"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "config not found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "conf"
        ]
      },
      "put": {
        "description": "Update the sub-configurations under *sysmon*",
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/broker.sysmon"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/broker.sysmon"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "UPDATE_FAILED"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Error code to troubleshoot problems.",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "conf"
        ]
      }
    },
    "/connectors/{id}": {
      "delete": {
        "description": "Delete a connector by ID",
        "parameters": [
          {
            "description": "The connector ID. Must be of format {type}:{name}",
            "example": "mqtt:my_mqtt_connector",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Delete connector successfully"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "INVALID_ID"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad connector ID",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "403": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "DEPENDENCY_EXISTS"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Cannot remove dependent connector",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Delete failed, not found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "summary": "Delete connector",
        "tags": [
          "connectors"
        ]
      },
      "get": {
        "description": "Get the connector by ID",
        "parameters": [
          {
            "description": "The connector ID. Must be of format {type}:{name}",
            "example": "mqtt:my_mqtt_connector",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "mqtt": {
                    "summary": "MQTT Connector",
                    "value": {
                      "clean_start": true,
                      "clientid": "foo",
                      "keepalive": "300s",
                      "max_inflight": 100,
                      "mode": "cluster_shareload",
                      "name": "my_mqtt_connector",
                      "password": "bar",
                      "proto_ver": "v4",
                      "reconnect_interval": "15s",
                      "retry_interval": "15s",
                      "server": "127.0.0.1:1883",
                      "ssl": {
                        "enable": false
                      },
                      "type": "mqtt",
                      "username": "foo"
                    }
                  }
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/emqx_connector_mqtt.get"
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "INVALID_ID"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad connector ID",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Connector not found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "summary": "Get connector",
        "tags": [
          "connectors"
        ]
      },
      "put": {
        "description": "Update an existing connector by ID",
        "parameters": [
          {
            "description": "The connector ID. Must be of format {type}:{name}",
            "example": "mqtt:my_mqtt_connector",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "mqtt": {
                  "summary": "MQTT Connector",
                  "value": {
                    "clean_start": true,
                    "clientid": "foo",
                    "keepalive": "300s",
                    "max_inflight": 100,
                    "mode": "cluster_shareload",
                    "password": "bar",
                    "proto_ver": "v4",
                    "reconnect_interval": "15s",
                    "retry_interval": "15s",
                    "server": "127.0.0.1:1883",
                    "ssl": {
                      "enable": false
                    },
                    "username": "foo"
                  }
                }
              },
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/emqx_connector_mqtt.put"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "mqtt": {
                    "summary": "MQTT Connector",
                    "value": {
                      "clean_start": true,
                      "clientid": "foo",
                      "keepalive": "300s",
                      "max_inflight": 100,
                      "mode": "cluster_shareload",
                      "name": "my_mqtt_connector",
                      "password": "bar",
                      "proto_ver": "v4",
                      "reconnect_interval": "15s",
                      "retry_interval": "15s",
                      "server": "127.0.0.1:1883",
                      "ssl": {
                        "enable": false
                      },
                      "type": "mqtt",
                      "username": "foo"
                    }
                  }
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/emqx_connector_mqtt.get"
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "INVALID_ID"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad connector ID",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Connector not found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "summary": "Update connector",
        "tags": [
          "connectors"
        ]
      }
    },
    "/clients/{clientid}/authorization/cache": {
      "delete": {
        "description": "Clean client authz cache in the cluster.",
        "parameters": [
          {
            "in": "path",
            "name": "clientid",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Kick out client successfully"
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "CLIENTID_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Client id not found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "clients"
        ]
      },
      "get": {
        "description": "Get client authz cache in the cluster.",
        "parameters": [
          {
            "in": "path",
            "name": "clientid",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx_mgmt_api_clients.authz_cache"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "CLIENTID_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Client id not found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "clients"
        ]
      }
    },
    "/cluster/{node}/force_leave": {
      "delete": {
        "description": "Force leave node from cluster",
        "parameters": [
          {
            "$ref": "#/components/parameters/cluster.node"
          }
        ],
        "responses": {
          "204": {
            "description": "Delete successfully"
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Error code to troubleshoot problems.",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "cluster"
        ]
      }
    },
    "/rules": {
      "get": {
        "description": "List all rules",
        "parameters": [],
        "responses": {
          "200": {
            "description": "List of rules",
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/emqx_rule_api_schema.rule_info"
                  },
                  "type": "array"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "summary": "List Rules",
        "tags": [
          "rules"
        ]
      },
      "post": {
        "description": "Create a new rule using given Id",
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/emqx_rule_api_schema.rule_creation"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx_rule_api_schema.rule_info"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Invalid Parameters",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "summary": "Create a Rule",
        "tags": [
          "rules"
        ]
      }
    },
    "/authentication/{id}/status": {
      "get": {
        "description": "Get authenticator status from global authentication chain.",
        "parameters": [
          {
            "description": "Authenticator ID.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "status_metrics": {
                    "summary": "Authn status metrics",
                    "value": {
                      "metrics": {
                        "failed": 0,
                        "nomatch": 0,
                        "rate": 0,
                        "rate_last5m": 0,
                        "rate_max": 0,
                        "success": 0,
                        "total": 0
                      },
                      "node_error": [],
                      "node_metrics": [
                        {
                          "metrics": {
                            "failed": 0,
                            "matched": 0,
                            "nomatch": 0,
                            "rate": 0,
                            "rate_last5m": 0,
                            "rate_max": 0,
                            "total": 0
                          },
                          "node": "emqx@127.0.0.1"
                        }
                      ],
                      "node_resource_metrics": [
                        {
                          "metrics": {
                            "failed": 0,
                            "matched": 0,
                            "rate": 0,
                            "rate_last5m": 0,
                            "rate_max": 0,
                            "success": 0
                          },
                          "node": "emqx@127.0.0.1"
                        }
                      ],
                      "node_status": [
                        {
                          "node": "emqx@127.0.0.1",
                          "status": "connected"
                        }
                      ],
                      "resource_metrics": {
                        "failed": 0,
                        "matched": 0,
                        "rate": 0,
                        "rate_last5m": 0,
                        "rate_max": 0,
                        "success": 0
                      },
                      "status": "connected"
                    }
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/emqx_authn_schema.metrics_status_fields"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad Request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "authentication",
          "authentication config(global)"
        ]
      }
    },
    "/mqtt/topic_rewrite": {
      "get": {
        "description": "List all rewrite rules",
        "parameters": [],
        "responses": {
          "200": {
            "description": "List all rewrite rules",
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/modules.rewrite"
                  },
                  "type": "array"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "mqtt"
        ]
      },
      "put": {
        "description": "Update all rewrite rules",
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "items": {
                  "$ref": "#/components/schemas/modules.rewrite"
                },
                "type": "array"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Update all rewrite rules",
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/modules.rewrite"
                  },
                  "type": "array"
                }
              }
            }
          },
          "413": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "EXCEED_LIMIT"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Rules count exceed max limit",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "mqtt"
        ]
      }
    },
    "/mqtt/topic_metrics/{topic}": {
      "delete": {
        "description": "Delete Topic metrics",
        "parameters": [
          {
            "description": "Topic string. Notice: Topic string in url path must be encoded",
            "example": "testtopic/1",
            "in": "path",
            "name": "topic",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Delete Topic metrics"
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "TOPIC_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found. Topic metrics not found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "mqtt"
        ]
      },
      "get": {
        "description": "Get Topic metrics",
        "parameters": [
          {
            "description": "Topic string. Notice: Topic string in url path must be encoded",
            "example": "testtopic/1",
            "in": "path",
            "name": "topic",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Topic",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx_topic_metrics_api.topic_metrics"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "TOPIC_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found. Topic metrics not found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "mqtt"
        ]
      }
    },
    "/connectors_test": {
      "post": {
        "description": "</br>Test creating a new connector by given ID </br>The ID must be of format '{type}:{name}'</br>",
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "mqtt": {
                  "summary": "MQTT Connector",
                  "value": {
                    "clean_start": true,
                    "clientid": "foo",
                    "keepalive": "300s",
                    "max_inflight": 100,
                    "mode": "cluster_shareload",
                    "name": "my_mqtt_connector",
                    "password": "bar",
                    "proto_ver": "v4",
                    "reconnect_interval": "15s",
                    "retry_interval": "15s",
                    "server": "127.0.0.1:1883",
                    "ssl": {
                      "enable": false
                    },
                    "type": "mqtt",
                    "username": "foo"
                  }
                }
              },
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/emqx_connector_mqtt.post"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "Test connector OK"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "TEST_FAILED"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "connector test failed",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "summary": "Test creating connector",
        "tags": [
          "connectors"
        ]
      }
    },
    "/monitor/nodes/{node}": {
      "get": {
        "description": "List the monitor data on the node.",
        "parameters": [
          {
            "description": "EMQX node name.",
            "example": "emqx@127.0.0.1",
            "in": "path",
            "name": "node",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The latest N seconds data. Like 300 for 5 min.",
            "example": 300,
            "in": "query",
            "name": "latest",
            "required": false,
            "schema": {
              "minimum": 1,
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/emqx_dashboard_monitor_api.sampler"
                  },
                  "type": "array"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_RPC"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad RPC",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "dashboard"
        ]
      }
    },
    "/prometheus/stats": {
      "get": {
        "description": "Get Prometheus Data",
        "parameters": [],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "object"
                }
              },
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              }
            },
            "description": "Get Prometheus Data"
          }
        },
        "security": [],
        "tags": [
          "prometheus"
        ]
      }
    },
    "/authentication/{id}": {
      "delete": {
        "description": "Delete authenticator from global authentication chain.",
        "parameters": [
          {
            "description": "Authenticator ID.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Authenticator deleted"
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "authentication",
          "authentication config(global)"
        ]
      },
      "get": {
        "description": "Get authenticator from global authentication chain.",
        "parameters": [
          {
            "description": "Authenticator ID.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "jwt": {
                    "summary": "JWT authentication",
                    "value": {
                      "algorithm": "hmac-based",
                      "mechanism": "jwt",
                      "secret": "mysecret",
                      "secret_base64_encoded": false,
                      "use_jwks": false,
                      "verify_claims": {
                        "username": "${username}"
                      }
                    }
                  },
                  "password_based:built_in_database": {
                    "summary": "Built-in password_based authentication",
                    "value": {
                      "backend": "built_in_database",
                      "mechanism": "password_based",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "user_id_type": "username"
                    }
                  },
                  "password_based:http": {
                    "summary": "password_based authentication through external HTTP API",
                    "value": {
                      "backend": "http",
                      "body": {
                        "password": "${password}",
                        "username": "${username}"
                      },
                      "connect_timeout": 5000,
                      "enable_pipelining": 100,
                      "headers": {
                        "content-type": "application/json"
                      },
                      "mechanism": "password_based",
                      "method": "post",
                      "pool_size": 8,
                      "request_timeout": 5000,
                      "ssl": {
                        "enable": false
                      },
                      "url": "http://127.0.0.1:18083"
                    }
                  },
                  "password_based:mongodb": {
                    "summary": "password_based authentication with MongoDB backend",
                    "value": {
                      "backend": "mongodb",
                      "collection": "users",
                      "database": "example",
                      "filter": {
                        "username": "${username}"
                      },
                      "is_superuser_field": "is_superuser",
                      "mechanism": "password_based",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "password_hash_field": "password_hash",
                      "salt_field": "salt",
                      "server": "127.0.0.1:27017"
                    }
                  },
                  "password_based:redis": {
                    "summary": "password_based authentication with Redis backend",
                    "value": {
                      "backend": "redis",
                      "cmd": "HMGET ${username} password_hash salt",
                      "database": 0,
                      "mechanism": "password_based",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "redis_type": "single",
                      "server": "127.0.0.1:6379"
                    }
                  }
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/authn-scram-builtin_db.authentication"
                    },
                    {
                      "$ref": "#/components/schemas/authn-jwt.jwks"
                    },
                    {
                      "$ref": "#/components/schemas/authn-jwt.public-key"
                    },
                    {
                      "$ref": "#/components/schemas/authn-jwt.hmac-based"
                    },
                    {
                      "$ref": "#/components/schemas/authn-http.post"
                    },
                    {
                      "$ref": "#/components/schemas/authn-http.get"
                    },
                    {
                      "$ref": "#/components/schemas/authn-redis.sentinel"
                    },
                    {
                      "$ref": "#/components/schemas/authn-redis.cluster"
                    },
                    {
                      "$ref": "#/components/schemas/authn-redis.standalone"
                    },
                    {
                      "$ref": "#/components/schemas/authn-mongodb.sharded-cluster"
                    },
                    {
                      "$ref": "#/components/schemas/authn-mongodb.replica-set"
                    },
                    {
                      "$ref": "#/components/schemas/authn-mongodb.standalone"
                    },
                    {
                      "$ref": "#/components/schemas/authn-postgresql.authentication"
                    },
                    {
                      "$ref": "#/components/schemas/authn-mysql.authentication"
                    },
                    {
                      "$ref": "#/components/schemas/authn-builtin_db.authentication"
                    }
                  ]
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "authentication",
          "authentication config(global)"
        ]
      },
      "put": {
        "description": "Update authenticator from global authentication chain.",
        "parameters": [
          {
            "description": "Authenticator ID.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "jwt": {
                  "summary": "JWT authentication",
                  "value": {
                    "algorithm": "hmac-based",
                    "mechanism": "jwt",
                    "secret": "mysecret",
                    "secret_base64_encoded": false,
                    "use_jwks": false,
                    "verify_claims": {
                      "username": "${username}"
                    }
                  }
                },
                "password_based:built_in_database": {
                  "summary": "Built-in password_based authentication",
                  "value": {
                    "backend": "built_in_database",
                    "mechanism": "password_based",
                    "password_hash_algorithm": {
                      "name": "sha256",
                      "salt_position": "suffix"
                    },
                    "user_id_type": "username"
                  }
                },
                "password_based:http": {
                  "summary": "password_based authentication through external HTTP API",
                  "value": {
                    "backend": "http",
                    "body": {
                      "password": "${password}",
                      "username": "${username}"
                    },
                    "connect_timeout": 5000,
                    "enable_pipelining": 100,
                    "headers": {
                      "content-type": "application/json"
                    },
                    "mechanism": "password_based",
                    "method": "post",
                    "pool_size": 8,
                    "request_timeout": 5000,
                    "ssl": {
                      "enable": false
                    },
                    "url": "http://127.0.0.1:18083"
                  }
                },
                "password_based:mongodb": {
                  "summary": "password_based authentication with MongoDB backend",
                  "value": {
                    "backend": "mongodb",
                    "collection": "users",
                    "database": "example",
                    "filter": {
                      "username": "${username}"
                    },
                    "is_superuser_field": "is_superuser",
                    "mechanism": "password_based",
                    "password_hash_algorithm": {
                      "name": "sha256",
                      "salt_position": "suffix"
                    },
                    "password_hash_field": "password_hash",
                    "salt_field": "salt",
                    "server": "127.0.0.1:27017"
                  }
                },
                "password_based:redis": {
                  "summary": "password_based authentication with Redis backend",
                  "value": {
                    "backend": "redis",
                    "cmd": "HMGET ${username} password_hash salt",
                    "database": 0,
                    "mechanism": "password_based",
                    "password_hash_algorithm": {
                      "name": "sha256",
                      "salt_position": "suffix"
                    },
                    "redis_type": "single",
                    "server": "127.0.0.1:6379"
                  }
                }
              },
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/authn-scram-builtin_db.authentication"
                  },
                  {
                    "$ref": "#/components/schemas/authn-jwt.jwks"
                  },
                  {
                    "$ref": "#/components/schemas/authn-jwt.public-key"
                  },
                  {
                    "$ref": "#/components/schemas/authn-jwt.hmac-based"
                  },
                  {
                    "$ref": "#/components/schemas/authn-http.post"
                  },
                  {
                    "$ref": "#/components/schemas/authn-http.get"
                  },
                  {
                    "$ref": "#/components/schemas/authn-redis.sentinel"
                  },
                  {
                    "$ref": "#/components/schemas/authn-redis.cluster"
                  },
                  {
                    "$ref": "#/components/schemas/authn-redis.standalone"
                  },
                  {
                    "$ref": "#/components/schemas/authn-mongodb.sharded-cluster"
                  },
                  {
                    "$ref": "#/components/schemas/authn-mongodb.replica-set"
                  },
                  {
                    "$ref": "#/components/schemas/authn-mongodb.standalone"
                  },
                  {
                    "$ref": "#/components/schemas/authn-postgresql.authentication"
                  },
                  {
                    "$ref": "#/components/schemas/authn-mysql.authentication"
                  },
                  {
                    "$ref": "#/components/schemas/authn-builtin_db.authentication"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "jwt": {
                    "summary": "JWT authentication",
                    "value": {
                      "algorithm": "hmac-based",
                      "mechanism": "jwt",
                      "secret": "mysecret",
                      "secret_base64_encoded": false,
                      "use_jwks": false,
                      "verify_claims": {
                        "username": "${username}"
                      }
                    }
                  },
                  "password_based:built_in_database": {
                    "summary": "Built-in password_based authentication",
                    "value": {
                      "backend": "built_in_database",
                      "mechanism": "password_based",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "user_id_type": "username"
                    }
                  },
                  "password_based:http": {
                    "summary": "password_based authentication through external HTTP API",
                    "value": {
                      "backend": "http",
                      "body": {
                        "password": "${password}",
                        "username": "${username}"
                      },
                      "connect_timeout": 5000,
                      "enable_pipelining": 100,
                      "headers": {
                        "content-type": "application/json"
                      },
                      "mechanism": "password_based",
                      "method": "post",
                      "pool_size": 8,
                      "request_timeout": 5000,
                      "ssl": {
                        "enable": false
                      },
                      "url": "http://127.0.0.1:18083"
                    }
                  },
                  "password_based:mongodb": {
                    "summary": "password_based authentication with MongoDB backend",
                    "value": {
                      "backend": "mongodb",
                      "collection": "users",
                      "database": "example",
                      "filter": {
                        "username": "${username}"
                      },
                      "is_superuser_field": "is_superuser",
                      "mechanism": "password_based",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "password_hash_field": "password_hash",
                      "salt_field": "salt",
                      "server": "127.0.0.1:27017"
                    }
                  },
                  "password_based:redis": {
                    "summary": "password_based authentication with Redis backend",
                    "value": {
                      "backend": "redis",
                      "cmd": "HMGET ${username} password_hash salt",
                      "database": 0,
                      "mechanism": "password_based",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "redis_type": "single",
                      "server": "127.0.0.1:6379"
                    }
                  }
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/authn-scram-builtin_db.authentication"
                    },
                    {
                      "$ref": "#/components/schemas/authn-jwt.jwks"
                    },
                    {
                      "$ref": "#/components/schemas/authn-jwt.public-key"
                    },
                    {
                      "$ref": "#/components/schemas/authn-jwt.hmac-based"
                    },
                    {
                      "$ref": "#/components/schemas/authn-http.post"
                    },
                    {
                      "$ref": "#/components/schemas/authn-http.get"
                    },
                    {
                      "$ref": "#/components/schemas/authn-redis.sentinel"
                    },
                    {
                      "$ref": "#/components/schemas/authn-redis.cluster"
                    },
                    {
                      "$ref": "#/components/schemas/authn-redis.standalone"
                    },
                    {
                      "$ref": "#/components/schemas/authn-mongodb.sharded-cluster"
                    },
                    {
                      "$ref": "#/components/schemas/authn-mongodb.replica-set"
                    },
                    {
                      "$ref": "#/components/schemas/authn-mongodb.standalone"
                    },
                    {
                      "$ref": "#/components/schemas/authn-postgresql.authentication"
                    },
                    {
                      "$ref": "#/components/schemas/authn-mysql.authentication"
                    },
                    {
                      "$ref": "#/components/schemas/authn-builtin_db.authentication"
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad Request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "409": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "ALREADY_EXISTS"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "ALREADY_EXISTS",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "authentication",
          "authentication config(global)"
        ]
      }
    },
    "/publish": {
      "post": {
        "description": "Publish Message",
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/emqx_mgmt_api_publish.publish_message"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx_mgmt_api_publish.publish_message_info"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "publish"
        ]
      }
    },
    "/nodes/{node}/metrics": {
      "get": {
        "description": "Get node metrics",
        "parameters": [
          {
            "$ref": "#/components/parameters/emqx_mgmt_api_nodes.node_name"
          }
        ],
        "responses": {
          "200": {
            "description": "Get node metrics successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx_mgmt_api_metrics.node_metrics"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "SOURCE_ERROR"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Node error",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "nodes"
        ]
      }
    },
    "/configs/global_zone": {
      "get": {
        "description": "Get the global zone configs",
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "mqtt": {
                      "description": "Global MQTT configuration.</br>The configs here work as default values which can be overridden</br>in <code>zone</code> configs",
                      "$ref": "#/components/schemas/zone.mqtt"
                    },
                    "stats": {
                      "description": "Enable/disable statistic data collection.</br>Statistic data such as message receive/send count/rate etc. It provides insights of system performance and helps to diagnose issues. You can find statistic data from the dashboard, or from the '/stats' API.",
                      "$ref": "#/components/schemas/zone.stats"
                    },
                    "flapping_detect": {
                      "description": "This config controls the allowed maximum number of `CONNECT` packets received</br>from the same clientid in a time frame defined by `window_time`.</br>After the limit is reached, successive `CONNECT` requests are forbidden</br>(banned) until the end of the time period defined by `ban_time`.",
                      "$ref": "#/components/schemas/zone.flapping_detect"
                    },
                    "force_shutdown": {
                      "description": "When the process message queue length, or the memory bytes</br>reaches a certain value, the process is forced to close.</br></br>Note: \"message queue\" here refers to the \"message mailbox\"</br>of the Erlang process, not the `mqueue` of QoS 1 and QoS 2.",
                      "$ref": "#/components/schemas/zone.force_shutdown"
                    },
                    "conn_congestion": {
                      "description": "Settings for `conn_congestion` alarm.</br></br>Sometimes the MQTT connection (usually an MQTT subscriber) may</br>get \"congested\", because there are too many packets to be sent.</br>The socket tries to buffer the packets until the buffer is</br>full. If more packets arrive after that, the packets will be</br>\"pending\" in the queue, and we consider the connection</br>congested.</br></br>Note: `sndbuf` can be set to larger value if the</br>alarm is triggered too often.</br>The name of the alarm is of format `conn_congestion/<ClientID>/<Username>`,</br>where the `<ClientID>` is the client ID of the congested MQTT connection,</br>and `<Username>` is the username or `unknown_user`.",
                      "$ref": "#/components/schemas/zone.conn_congestion"
                    },
                    "force_gc": {
                      "description": "Force garbage collection in MQTT connection process after</br> they process certain number of messages or bytes of data.",
                      "$ref": "#/components/schemas/zone.force_gc"
                    },
                    "overload_protection": {
                      "description": "Overload protection mechanism monitors the load of the system and temporarily</br>disables some features (such as accepting new connections) when the load is high.",
                      "$ref": "#/components/schemas/zone.overload_protection"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "conf"
        ]
      },
      "put": {
        "description": "Update globbal zone configs",
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "mqtt": {
                    "description": "Global MQTT configuration.</br>The configs here work as default values which can be overridden</br>in <code>zone</code> configs",
                    "$ref": "#/components/schemas/zone.mqtt"
                  },
                  "stats": {
                    "description": "Enable/disable statistic data collection.</br>Statistic data such as message receive/send count/rate etc. It provides insights of system performance and helps to diagnose issues. You can find statistic data from the dashboard, or from the '/stats' API.",
                    "$ref": "#/components/schemas/zone.stats"
                  },
                  "flapping_detect": {
                    "description": "This config controls the allowed maximum number of `CONNECT` packets received</br>from the same clientid in a time frame defined by `window_time`.</br>After the limit is reached, successive `CONNECT` requests are forbidden</br>(banned) until the end of the time period defined by `ban_time`.",
                    "$ref": "#/components/schemas/zone.flapping_detect"
                  },
                  "force_shutdown": {
                    "description": "When the process message queue length, or the memory bytes</br>reaches a certain value, the process is forced to close.</br></br>Note: \"message queue\" here refers to the \"message mailbox\"</br>of the Erlang process, not the `mqueue` of QoS 1 and QoS 2.",
                    "$ref": "#/components/schemas/zone.force_shutdown"
                  },
                  "conn_congestion": {
                    "description": "Settings for `conn_congestion` alarm.</br></br>Sometimes the MQTT connection (usually an MQTT subscriber) may</br>get \"congested\", because there are too many packets to be sent.</br>The socket tries to buffer the packets until the buffer is</br>full. If more packets arrive after that, the packets will be</br>\"pending\" in the queue, and we consider the connection</br>congested.</br></br>Note: `sndbuf` can be set to larger value if the</br>alarm is triggered too often.</br>The name of the alarm is of format `conn_congestion/<ClientID>/<Username>`,</br>where the `<ClientID>` is the client ID of the congested MQTT connection,</br>and `<Username>` is the username or `unknown_user`.",
                    "$ref": "#/components/schemas/zone.conn_congestion"
                  },
                  "force_gc": {
                    "description": "Force garbage collection in MQTT connection process after</br> they process certain number of messages or bytes of data.",
                    "$ref": "#/components/schemas/zone.force_gc"
                  },
                  "overload_protection": {
                    "description": "Overload protection mechanism monitors the load of the system and temporarily</br>disables some features (such as accepting new connections) when the load is high.",
                    "$ref": "#/components/schemas/zone.overload_protection"
                  }
                },
                "type": "object"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "mqtt": {
                      "description": "Global MQTT configuration.</br>The configs here work as default values which can be overridden</br>in <code>zone</code> configs",
                      "$ref": "#/components/schemas/zone.mqtt"
                    },
                    "stats": {
                      "description": "Enable/disable statistic data collection.</br>Statistic data such as message receive/send count/rate etc. It provides insights of system performance and helps to diagnose issues. You can find statistic data from the dashboard, or from the '/stats' API.",
                      "$ref": "#/components/schemas/zone.stats"
                    },
                    "flapping_detect": {
                      "description": "This config controls the allowed maximum number of `CONNECT` packets received</br>from the same clientid in a time frame defined by `window_time`.</br>After the limit is reached, successive `CONNECT` requests are forbidden</br>(banned) until the end of the time period defined by `ban_time`.",
                      "$ref": "#/components/schemas/zone.flapping_detect"
                    },
                    "force_shutdown": {
                      "description": "When the process message queue length, or the memory bytes</br>reaches a certain value, the process is forced to close.</br></br>Note: \"message queue\" here refers to the \"message mailbox\"</br>of the Erlang process, not the `mqueue` of QoS 1 and QoS 2.",
                      "$ref": "#/components/schemas/zone.force_shutdown"
                    },
                    "conn_congestion": {
                      "description": "Settings for `conn_congestion` alarm.</br></br>Sometimes the MQTT connection (usually an MQTT subscriber) may</br>get \"congested\", because there are too many packets to be sent.</br>The socket tries to buffer the packets until the buffer is</br>full. If more packets arrive after that, the packets will be</br>\"pending\" in the queue, and we consider the connection</br>congested.</br></br>Note: `sndbuf` can be set to larger value if the</br>alarm is triggered too often.</br>The name of the alarm is of format `conn_congestion/<ClientID>/<Username>`,</br>where the `<ClientID>` is the client ID of the congested MQTT connection,</br>and `<Username>` is the username or `unknown_user`.",
                      "$ref": "#/components/schemas/zone.conn_congestion"
                    },
                    "force_gc": {
                      "description": "Force garbage collection in MQTT connection process after</br> they process certain number of messages or bytes of data.",
                      "$ref": "#/components/schemas/zone.force_gc"
                    },
                    "overload_protection": {
                      "description": "Overload protection mechanism monitors the load of the system and temporarily</br>disables some features (such as accepting new connections) when the load is high.",
                      "$ref": "#/components/schemas/zone.overload_protection"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "UPDATE_FAILED"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Error code to troubleshoot problems.",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "conf"
        ]
      }
    },
    "/configs/cluster": {
      "get": {
        "description": "Get the sub-configurations under *cluster*",
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx_conf_schema.cluster"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "config not found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "conf"
        ]
      },
      "put": {
        "description": "Update the sub-configurations under *cluster*",
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/emqx_conf_schema.cluster"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx_conf_schema.cluster"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "UPDATE_FAILED"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Error code to troubleshoot problems.",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "conf"
        ]
      }
    },
    "/users": {
      "get": {
        "description": "Dashboard list users",
        "parameters": [],
        "responses": {
          "200": {
            "description": "Dashboard list users",
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/dashboard.user"
                  },
                  "type": "array"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "dashboard"
        ]
      },
      "post": {
        "description": "Create dashboard user",
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "username": {
                    "description": "Dashboard Username",
                    "example": "admin",
                    "maxLength": 100,
                    "type": "string"
                  },
                  "password": {
                    "description": "Dashboard Password",
                    "example": "public",
                    "maxLength": 100,
                    "type": "string"
                  },
                  "description": {
                    "description": "Dashboard User Description",
                    "example": "administrator",
                    "type": "string"
                  }
                },
                "type": "object"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "username": {
                      "description": "Dashboard Username",
                      "example": "admin",
                      "maxLength": 100,
                      "type": "string"
                    },
                    "description": {
                      "description": "Dashboard User Description",
                      "example": "administrator",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "dashboard"
        ]
      }
    },
    "/gateway/lwm2m/clients/{clientid}/write": {
      "post": {
        "description": "Send a write command to a resource",
        "parameters": [
          {
            "example": "urn:oma:lwm2m:oma:2",
            "in": "path",
            "name": "clientid",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "example": "/3/0/7",
            "in": "query",
            "name": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "example": "Integer",
            "in": "query",
            "name": "type",
            "required": true,
            "schema": {
              "enum": [
                "Integer",
                "Float",
                "Time",
                "String",
                "Boolean",
                "Opaque",
                "Objlnk"
              ],
              "type": "string"
            }
          },
          {
            "example": 123,
            "in": "query",
            "name": "value",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "No Content"
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "CLIENT_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Clientid not found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "lwm2m"
        ]
      }
    },
    "/gateway/{name}": {
      "delete": {
        "description": "Delete/Unload the gateway",
        "parameters": [
          {
            "description": "Gateway Name",
            "example": "",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Deleted"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "gateway"
        ]
      },
      "get": {
        "description": "Get the gateway configurations",
        "parameters": [
          {
            "description": "Gateway Name",
            "example": "",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "coap_gateway": {
                    "summary": "A simple CoAP gateway configs",
                    "value": {
                      "connection_required": false,
                      "enable": true,
                      "enable_stats": true,
                      "heartbeat": "30s",
                      "idle_timeout": "30s",
                      "listeners": [
                        {
                          "bind": "5683",
                          "max_conn_rate": 1000,
                          "max_connections": 1024000,
                          "name": "default",
                          "type": "udp"
                        }
                      ],
                      "mountpoint": "coap/",
                      "name": "coap",
                      "notify_type": "qos",
                      "publish_qos": "coap",
                      "subscribe_qos": "coap"
                    }
                  },
                  "exproto_gateway": {
                    "summary": "A simple ExProto gateway configs",
                    "value": {
                      "enable": true,
                      "enable_stats": true,
                      "handler": {
                        "address": "http://127.0.0.1:9001"
                      },
                      "idle_timeout": "30s",
                      "listeners": [
                        {
                          "bind": "7993",
                          "max_conn_rate": 1000,
                          "max_connections": 1024000,
                          "name": "default",
                          "type": "tcp"
                        }
                      ],
                      "mountpoint": "exproto/",
                      "name": "exproto",
                      "server": {
                        "bind": "9100"
                      }
                    }
                  },
                  "lwm2m_gateway": {
                    "summary": "A simple LwM2M gateway configs",
                    "value": {
                      "auto_observe": false,
                      "enable": true,
                      "enable_stats": true,
                      "idle_timeout": "30s",
                      "lifetime_max": "86400s",
                      "lifetime_min": "1s",
                      "listeners": [
                        {
                          "bind": "5783",
                          "max_conn_rate": 1000,
                          "max_connections": 1024000,
                          "name": "default",
                          "type": "udp"
                        }
                      ],
                      "mountpoint": "lwm2m/",
                      "name": "lwm2m",
                      "qmode_time_window": "22s",
                      "translators": {
                        "command": {
                          "topic": "dn/#"
                        },
                        "notify": {
                          "topic": "up/notify"
                        },
                        "register": {
                          "topic": "up/resp"
                        },
                        "response": {
                          "topic": "up/resp"
                        },
                        "update": {
                          "topic": "up/resp"
                        }
                      },
                      "update_msg_publish_condition": "always",
                      "xml_dir": "/mnt/code/src/emqx/0/_build/emqx/rel/emqx/etc/lwm2m_xml"
                    }
                  },
                  "mqttsn_gateway": {
                    "summary": "A simple MQTT-SN gateway configs",
                    "value": {
                      "broadcast": true,
                      "enable": true,
                      "enable_qos3": true,
                      "enable_stats": true,
                      "gateway_id": 1,
                      "idle_timeout": "30s",
                      "listeners": [
                        {
                          "bind": "1884",
                          "max_conn_rate": 1000,
                          "max_connections": 1024000,
                          "name": "default",
                          "type": "udp"
                        }
                      ],
                      "mountpoint": "mqttsn/",
                      "name": "mqttsn",
                      "predefined": [
                        {
                          "id": "1001",
                          "topic": "pred/1001"
                        },
                        {
                          "id": "1002",
                          "topic": "pred/1002"
                        }
                      ]
                    }
                  },
                  "stomp_gateway": {
                    "summary": "A simple STOMP gateway configs",
                    "value": {
                      "enable": true,
                      "enable_stats": true,
                      "frame": {
                        "max_body_length": 65535,
                        "max_headers": 10,
                        "max_headers_length": 1024
                      },
                      "idle_timeout": "30s",
                      "listeners": [
                        {
                          "bind": "61613",
                          "max_conn_rate": 1000,
                          "max_connections": 1024000,
                          "name": "default",
                          "type": "tcp"
                        }
                      ],
                      "mountpoint": "stomp/",
                      "name": "stomp"
                    }
                  }
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api.exproto"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api.lwm2m"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api.coap"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api.mqttsn"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api.stomp"
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "gateway"
        ]
      },
      "put": {
        "description": "Update the gateway configurations/status",
        "parameters": [
          {
            "description": "Gateway Name",
            "example": "",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "coap_gateway": {
                  "summary": "A simple CoAP gateway configs",
                  "value": {
                    "connection_required": false,
                    "enable": true,
                    "enable_stats": true,
                    "heartbeat": "30s",
                    "idle_timeout": "30s",
                    "mountpoint": "coap2/",
                    "notify_type": "qos",
                    "publish_qos": "coap",
                    "subscribe_qos": "coap"
                  }
                },
                "exproto_gateway": {
                  "summary": "A simple ExProto gateway configs",
                  "value": {
                    "enable": true,
                    "enable_stats": true,
                    "handler": {
                      "address": "http://127.0.0.1:9001"
                    },
                    "idle_timeout": "30s",
                    "mountpoint": "exproto2/",
                    "server": {
                      "bind": "9100"
                    }
                  }
                },
                "lwm2m_gateway": {
                  "summary": "A simple LwM2M gateway configs",
                  "value": {
                    "auto_observe": false,
                    "enable": true,
                    "enable_stats": true,
                    "idle_timeout": "30s",
                    "lifetime_max": "86400s",
                    "lifetime_min": "1s",
                    "mountpoint": "lwm2m2/",
                    "qmode_time_window": "22s",
                    "translators": {
                      "command": {
                        "topic": "dn/#"
                      },
                      "notify": {
                        "topic": "up/notify"
                      },
                      "register": {
                        "topic": "up/resp"
                      },
                      "response": {
                        "topic": "up/resp"
                      },
                      "update": {
                        "topic": "up/resp"
                      }
                    },
                    "update_msg_publish_condition": "always",
                    "xml_dir": "/mnt/code/src/emqx/0/_build/emqx/rel/emqx/etc/lwm2m_xml"
                  }
                },
                "mqttsn_gateway": {
                  "summary": "A simple MQTT-SN gateway configs",
                  "value": {
                    "broadcast": true,
                    "enable": true,
                    "enable_qos3": false,
                    "enable_stats": true,
                    "gateway_id": 1,
                    "idle_timeout": "30s",
                    "mountpoint": "mqttsn2/",
                    "predefined": [
                      {
                        "id": "1003",
                        "topic": "pred/1003"
                      }
                    ]
                  }
                },
                "stomp_gateway": {
                  "summary": "A simple STOMP gateway configs",
                  "value": {
                    "enable": true,
                    "enable_stats": true,
                    "frame": {
                      "max_body_length": 655350,
                      "max_headers": 100,
                      "max_headers_length": 10240
                    },
                    "idle_timeout": "30s",
                    "mountpoint": "stomp2/"
                  }
                }
              },
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/emqx_gateway_api.update_disable_enable_only"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_gateway_api.update_exproto"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_gateway_api.update_lwm2m"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_gateway_api.update_coap"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_gateway_api.update_mqttsn"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_gateway_api.update_stomp"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "coap_gateway": {
                    "summary": "A simple CoAP gateway configs",
                    "value": {
                      "connection_required": false,
                      "enable": true,
                      "enable_stats": true,
                      "heartbeat": "30s",
                      "idle_timeout": "30s",
                      "listeners": [
                        {
                          "bind": "5683",
                          "max_conn_rate": 1000,
                          "max_connections": 1024000,
                          "name": "default",
                          "type": "udp"
                        }
                      ],
                      "mountpoint": "coap/",
                      "name": "coap",
                      "notify_type": "qos",
                      "publish_qos": "coap",
                      "subscribe_qos": "coap"
                    }
                  },
                  "exproto_gateway": {
                    "summary": "A simple ExProto gateway configs",
                    "value": {
                      "enable": true,
                      "enable_stats": true,
                      "handler": {
                        "address": "http://127.0.0.1:9001"
                      },
                      "idle_timeout": "30s",
                      "listeners": [
                        {
                          "bind": "7993",
                          "max_conn_rate": 1000,
                          "max_connections": 1024000,
                          "name": "default",
                          "type": "tcp"
                        }
                      ],
                      "mountpoint": "exproto/",
                      "name": "exproto",
                      "server": {
                        "bind": "9100"
                      }
                    }
                  },
                  "lwm2m_gateway": {
                    "summary": "A simple LwM2M gateway configs",
                    "value": {
                      "auto_observe": false,
                      "enable": true,
                      "enable_stats": true,
                      "idle_timeout": "30s",
                      "lifetime_max": "86400s",
                      "lifetime_min": "1s",
                      "listeners": [
                        {
                          "bind": "5783",
                          "max_conn_rate": 1000,
                          "max_connections": 1024000,
                          "name": "default",
                          "type": "udp"
                        }
                      ],
                      "mountpoint": "lwm2m/",
                      "name": "lwm2m",
                      "qmode_time_window": "22s",
                      "translators": {
                        "command": {
                          "topic": "dn/#"
                        },
                        "notify": {
                          "topic": "up/notify"
                        },
                        "register": {
                          "topic": "up/resp"
                        },
                        "response": {
                          "topic": "up/resp"
                        },
                        "update": {
                          "topic": "up/resp"
                        }
                      },
                      "update_msg_publish_condition": "always",
                      "xml_dir": "/mnt/code/src/emqx/0/_build/emqx/rel/emqx/etc/lwm2m_xml"
                    }
                  },
                  "mqttsn_gateway": {
                    "summary": "A simple MQTT-SN gateway configs",
                    "value": {
                      "broadcast": true,
                      "enable": true,
                      "enable_qos3": true,
                      "enable_stats": true,
                      "gateway_id": 1,
                      "idle_timeout": "30s",
                      "listeners": [
                        {
                          "bind": "1884",
                          "max_conn_rate": 1000,
                          "max_connections": 1024000,
                          "name": "default",
                          "type": "udp"
                        }
                      ],
                      "mountpoint": "mqttsn/",
                      "name": "mqttsn",
                      "predefined": [
                        {
                          "id": "1001",
                          "topic": "pred/1001"
                        },
                        {
                          "id": "1002",
                          "topic": "pred/1002"
                        }
                      ]
                    }
                  },
                  "stomp_gateway": {
                    "summary": "A simple STOMP gateway configs",
                    "value": {
                      "enable": true,
                      "enable_stats": true,
                      "frame": {
                        "max_body_length": 65535,
                        "max_headers": 10,
                        "max_headers_length": 1024
                      },
                      "idle_timeout": "30s",
                      "listeners": [
                        {
                          "bind": "61613",
                          "max_conn_rate": 1000,
                          "max_connections": 1024000,
                          "name": "default",
                          "type": "tcp"
                        }
                      ],
                      "mountpoint": "stomp/",
                      "name": "stomp"
                    }
                  }
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api.exproto"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api.lwm2m"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api.coap"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api.mqttsn"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api.stomp"
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "gateway"
        ]
      }
    },
    "/gateway/lwm2m/clients/{clientid}/lookup": {
      "get": {
        "description": "Look up a resource",
        "parameters": [
          {
            "example": "urn:oma:lwm2m:oma:2",
            "in": "path",
            "name": "clientid",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "example": "/3/0/7",
            "in": "query",
            "name": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "example": "discover",
            "in": "query",
            "name": "action",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "clientid": {
                      "example": "urn:oma:lwm2m:oma:2",
                      "type": "string"
                    },
                    "path": {
                      "example": "/3/0/7",
                      "type": "string"
                    },
                    "action": {
                      "example": "discover",
                      "type": "string"
                    },
                    "codeMsg": {
                      "example": "reply_not_received",
                      "type": "string"
                    },
                    "content": {
                      "items": {
                        "$ref": "#/components/schemas/lwm2m.resource"
                      },
                      "type": "array"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "CLIENT_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Client not found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "lwm2m"
        ]
      }
    },
    "/authorization/sources/{type}/status": {
      "get": {
        "description": "Get a authorization source",
        "parameters": [
          {
            "description": "Authorization type",
            "in": "path",
            "name": "type",
            "required": true,
            "schema": {
              "enum": [
                "http",
                "mongodb",
                "redis",
                "built_in_database",
                "mysql",
                "postgresql",
                "file"
              ],
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "metrics": {
                    "allow": 0,
                    "deny": 0,
                    "nomatch": 0,
                    "rate": 0,
                    "rate_last5m": 0,
                    "rate_max": 0,
                    "total": 0
                  },
                  "node_metrics": [
                    {
                      "metrics": {
                        "allow": 0,
                        "deny": 0,
                        "nomatch": 0,
                        "rate": 0,
                        "rate_last5m": 0,
                        "rate_max": 0,
                        "total": 0
                      },
                      "node": "emqx@127.0.0.1"
                    }
                  ],
                  "node_resource_metrics": [
                    {
                      "metrics": {
                        "failed": 0,
                        "matched": 0,
                        "rate": 0,
                        "rate_last5m": 0,
                        "rate_max": 0,
                        "success": 0
                      },
                      "node": "emqx@127.0.0.1"
                    }
                  ],
                  "node_status": [
                    {
                      "node": "emqx@127.0.0.1",
                      "status": "connected"
                    }
                  ],
                  "resource_metrics": {
                    "failed": 0,
                    "matched": 0,
                    "rate": 0,
                    "rate_last5m": 0,
                    "rate_max": 0,
                    "success": 0
                  },
                  "status": "connected"
                },
                "schema": {
                  "$ref": "#/components/schemas/authz.metrics_status_fields"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "authorization"
        ]
      }
    },
    "/listeners": {
      "get": {
        "description": "List all running node's listeners for the specified type.",
        "parameters": [
          {
            "description": "Listener type",
            "example": "tcp",
            "in": "query",
            "name": "type",
            "required": false,
            "schema": {
              "enum": [
                "tcp",
                "ssl",
                "ws",
                "wss",
                "quic"
              ],
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": [
                  {
                    "acceptors": 16,
                    "bind": "0.0.0.0:1884",
                    "enable": true,
                    "id": "tcp:demo",
                    "node_status": {
                      "emqx@127.0.0.1": {
                        "current_connections": 100,
                        "max_connections": 1024000
                      },
                      "emqx@127.0.0.2": {
                        "current_connections": 101,
                        "max_connections": 1024000
                      }
                    },
                    "number": 2,
                    "status": {
                      "current_connections": 201,
                      "max_connections": 2048000
                    }
                  },
                  {
                    "acceptors": 32,
                    "bind": "0.0.0.0:1883",
                    "enable": true,
                    "id": "tcp:default",
                    "node_status": {
                      "emqx@127.0.0.1": {
                        "current_connections": 300,
                        "max_connections": "infinity"
                      },
                      "emqx@127.0.0.2": {
                        "current_connections": 201,
                        "max_connections": "infinity"
                      }
                    },
                    "number": 2,
                    "status": {
                      "current_connections": 501,
                      "max_connections": "infinity"
                    }
                  }
                ],
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/listeners.listener_id_status"
                  },
                  "type": "array"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "listeners"
        ]
      }
    },
    "/gateway/{name}/authentication/import_users": {
      "post": {
        "description": "Import users into the gateway authentication",
        "parameters": [
          {
            "description": "Gateway Name",
            "example": "stomp",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "multipart/form-data": {
              "schema": {
                "filename": "file"
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "Imported"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "gateway"
        ]
      }
    },
    "/trace/{name}/download": {
      "get": {
        "description": "Download trace log by name",
        "parameters": [
          {
            "$ref": "#/components/parameters/trace.name"
          },
          {
            "$ref": "#/components/parameters/trace.node"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/octet-stream": {
                "schema": {
                  "format": "binary",
                  "type": "string"
                }
              }
            },
            "description": "A trace zip file"
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "trace"
        ]
      }
    },
    "/clients/{clientid}": {
      "delete": {
        "description": "Kick out client by client ID",
        "parameters": [
          {
            "in": "path",
            "name": "clientid",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Kick out client successfully"
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "CLIENTID_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Client id not found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "clients"
        ]
      },
      "get": {
        "description": "Get clients info by client ID",
        "parameters": [
          {
            "in": "path",
            "name": "clientid",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx_mgmt_api_clients.client"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "CLIENTID_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Client id not found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "clients"
        ]
      }
    },
    "/clients/{clientid}/unsubscribe/bulk": {
      "post": {
        "description": "Unsubscribe",
        "parameters": [
          {
            "in": "path",
            "name": "clientid",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "items": {
                  "$ref": "#/components/schemas/emqx_mgmt_api_clients.unsubscribe"
                },
                "type": "array"
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "Unsubscribe OK"
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "CLIENTID_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Client id not found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "clients"
        ]
      }
    },
    "/clients/{clientid}/subscribe/bulk": {
      "post": {
        "description": "Subscribe",
        "parameters": [
          {
            "in": "path",
            "name": "clientid",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "items": {
                  "$ref": "#/components/schemas/emqx_mgmt_api_clients.subscribe"
                },
                "type": "array"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/emqx_mgmt_api_subscriptions.subscription"
                  },
                  "type": "array"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "CLIENTID_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Client id not found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "clients"
        ]
      }
    },
    "/authorization/sources/built_in_database/username": {
      "get": {
        "description": "Show the list of record for username",
        "parameters": [
          {
            "$ref": "#/components/parameters/public.page"
          },
          {
            "$ref": "#/components/parameters/public.limit"
          },
          {
            "description": "Fuzzy search `username` as substring",
            "in": "query",
            "name": "like_username",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "password_based:built_in_database": {
                    "summary": "Username",
                    "value": {
                      "data": [
                        {
                          "rules": [
                            {
                              "action": "publish",
                              "permission": "allow",
                              "topic": "test/toopic/1"
                            },
                            {
                              "action": "subscribe",
                              "permission": "allow",
                              "topic": "test/toopic/2"
                            },
                            {
                              "action": "all",
                              "permission": "deny",
                              "topic": "eq test/#"
                            }
                          ],
                          "username": "user1"
                        }
                      ],
                      "meta": {
                        "count": 1,
                        "limit": 100,
                        "page": 1
                      }
                    }
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/emqx_authz_api_mnesia.username_response_data"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "authorization"
        ]
      },
      "post": {
        "description": "Add new records for username",
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "password_based:built_in_database": {
                  "summary": "Username",
                  "value": [
                    {
                      "rules": [
                        {
                          "action": "publish",
                          "permission": "allow",
                          "topic": "test/toopic/1"
                        },
                        {
                          "action": "subscribe",
                          "permission": "allow",
                          "topic": "test/toopic/2"
                        },
                        {
                          "action": "all",
                          "permission": "deny",
                          "topic": "eq test/#"
                        }
                      ],
                      "username": "user1"
                    }
                  ]
                }
              },
              "schema": {
                "items": {
                  "$ref": "#/components/schemas/emqx_authz_api_mnesia.rules_for_username"
                },
                "type": "array"
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "Created"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad username or bad rule schema",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "409": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "ALREADY_EXISTS"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "ALREADY_EXISTS",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "authorization"
        ]
      }
    },
    "/configs/alarm": {
      "get": {
        "description": "Get the sub-configurations under *alarm*",
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/broker.alarm"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "config not found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "conf"
        ]
      },
      "put": {
        "description": "Update the sub-configurations under *alarm*",
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/broker.alarm"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/broker.alarm"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "UPDATE_FAILED"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Error code to troubleshoot problems.",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "conf"
        ]
      }
    },
    "/gateway/{name}/listeners/{id}/authentication/users": {
      "get": {
        "description": "Get the users for the authentication",
        "parameters": [
          {
            "description": "Gateway Name",
            "example": "",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Listener ID",
            "example": "",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Page number of the results to fetch.",
            "example": 1,
            "in": "query",
            "name": "page",
            "schema": {
              "default": 1,
              "minimum": 1,
              "type": "integer"
            }
          },
          {
            "description": "Results per page(max 1000)",
            "example": 50,
            "in": "query",
            "name": "limit",
            "schema": {
              "default": 100,
              "maximum": 1000,
              "minimum": 1,
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": {
                  "regular_user": {
                    "summary": "Regular user",
                    "value": {
                      "user_id": "user1"
                    }
                  },
                  "super_user": {
                    "summary": "Superuser",
                    "value": {
                      "is_superuser": true,
                      "user_id": "user2"
                    }
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/emqx_authn_api.response_user"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "gateway"
        ]
      },
      "post": {
        "description": "Add user for the authentication",
        "parameters": [
          {
            "description": "Gateway Name",
            "example": "",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Listener ID",
            "example": "",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "regular_user": {
                  "summary": "Regular user",
                  "value": {
                    "password": "secret",
                    "user_id": "user1"
                  }
                },
                "super_user": {
                  "summary": "Superuser",
                  "value": {
                    "is_superuser": true,
                    "password": "secret",
                    "user_id": "user2"
                  }
                }
              },
              "schema": {
                "$ref": "#/components/schemas/emqx_authn_api.request_user_create"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "example": {
                  "regular_user": {
                    "summary": "Regular user",
                    "value": {
                      "user_id": "user1"
                    }
                  },
                  "super_user": {
                    "summary": "Superuser",
                    "value": {
                      "is_superuser": true,
                      "user_id": "user2"
                    }
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/emqx_authn_api.response_user"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "gateway"
        ]
      }
    },
    "/nodes/{node}": {
      "get": {
        "description": "Get node info",
        "parameters": [
          {
            "$ref": "#/components/parameters/emqx_mgmt_api_nodes.node_name"
          }
        ],
        "responses": {
          "200": {
            "description": "Get node info successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx_mgmt_api_nodes.node_info"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "SOURCE_ERROR"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Node error",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "nodes"
        ]
      }
    },
    "/gateway/{name}/clients/{clientid}/subscriptions/{topic}": {
      "delete": {
        "description": "Delete a subscriptions membership",
        "parameters": [
          {
            "description": "Topic Filter/Name",
            "in": "path",
            "name": "topic",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Client ID",
            "in": "path",
            "name": "clientid",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Gateway Name",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Unsubscribed"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "gateway"
        ]
      }
    },
    "/configs/persistent_session_store": {
      "get": {
        "description": "Get the sub-configurations under *persistent_session_store*",
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/broker.persistent_session_store"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "config not found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "conf"
        ]
      },
      "put": {
        "description": "Update the sub-configurations under *persistent_session_store*",
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/broker.persistent_session_store"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/broker.persistent_session_store"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "UPDATE_FAILED"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Error code to troubleshoot problems.",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "conf"
        ]
      }
    },
    "/listeners/{id}/stop": {
      "post": {
        "description": "Stop the listener on all nodes.",
        "parameters": [
          {
            "$ref": "#/components/parameters/listeners.listener_id"
          }
        ],
        "responses": {
          "200": {
            "description": "Updated"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST",
                        "BAD_LISTENER_ID"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Error code to troubleshoot problems.",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "listeners"
        ]
      }
    },
    "/topics": {
      "get": {
        "description": "Topics list",
        "parameters": [
          {
            "description": "Topic Name",
            "example": "",
            "in": "query",
            "name": "topic",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Node Name",
            "example": "emqx@127.0.0.1",
            "in": "query",
            "name": "node",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "$ref": "#/components/parameters/public.page"
          },
          {
            "$ref": "#/components/parameters/public.limit"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "data": {
                      "items": {
                        "$ref": "#/components/schemas/emqx_mgmt_api_topics.topic"
                      },
                      "type": "array"
                    },
                    "meta": {
                      "$ref": "#/components/schemas/public.meta"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "topics"
        ]
      }
    },
    "/authorization/sources": {
      "get": {
        "description": "List all authorization sources",
        "parameters": [],
        "responses": {
          "200": {
            "description": "Authorization sources",
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "oneOf": [
                      {
                        "$ref": "#/components/schemas/emqx_authz_api_schema.file"
                      },
                      {
                        "$ref": "#/components/schemas/emqx_authz_api_schema.postgresql"
                      },
                      {
                        "$ref": "#/components/schemas/emqx_authz_api_schema.mysql"
                      },
                      {
                        "$ref": "#/components/schemas/emqx_authz_api_schema.built_in_database"
                      },
                      {
                        "$ref": "#/components/schemas/emqx_authz_api_schema.redis_cluster"
                      },
                      {
                        "$ref": "#/components/schemas/emqx_authz_api_schema.redis_sentinel"
                      },
                      {
                        "$ref": "#/components/schemas/emqx_authz_api_schema.redis_single"
                      },
                      {
                        "$ref": "#/components/schemas/emqx_authz_api_schema.mongo_sharded"
                      },
                      {
                        "$ref": "#/components/schemas/emqx_authz_api_schema.mongo_rs"
                      },
                      {
                        "$ref": "#/components/schemas/emqx_authz_api_schema.mongo_single"
                      },
                      {
                        "$ref": "#/components/schemas/emqx_authz_api_schema.http_post"
                      },
                      {
                        "$ref": "#/components/schemas/emqx_authz_api_schema.http_get"
                      }
                    ]
                  },
                  "type": "array"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "authorization"
        ]
      },
      "post": {
        "description": "Add a new source",
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/emqx_authz_api_schema.file"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_authz_api_schema.postgresql"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_authz_api_schema.mysql"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_authz_api_schema.built_in_database"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_authz_api_schema.redis_cluster"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_authz_api_schema.redis_sentinel"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_authz_api_schema.redis_single"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_authz_api_schema.mongo_sharded"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_authz_api_schema.mongo_rs"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_authz_api_schema.mongo_single"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_authz_api_schema.http_post"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_authz_api_schema.http_get"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "Authorization source created successfully"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad Request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "authorization"
        ]
      }
    },
    "/plugins": {
      "get": {
        "description": "List all install plugins.</br>Plugins are launched in top-down order.</br>Using `POST /plugins/{name}/move` to change the boot order.",
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/plugins.plugin"
                  },
                  "type": "array"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "plugins"
        ]
      }
    },
    "/login": {
      "post": {
        "description": "Dashboard Auth. Get Token",
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "username": {
                    "description": "Dashboard Username",
                    "example": "admin",
                    "maxLength": 100,
                    "type": "string"
                  },
                  "password": {
                    "description": "Dashboard Password",
                    "example": "public",
                    "maxLength": 100,
                    "type": "string"
                  }
                },
                "type": "object"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "token": {
                      "description": "Dashboard Auth Token",
                      "type": "string"
                    },
                    "version": {
                      "description": "EMQX Version",
                      "example": "5.0.0",
                      "type": "string"
                    },
                    "license": {
                      "properties": {
                        "edition": {
                          "description": "EMQX License. opensource or enterprise",
                          "enum": [
                            "opensource",
                            "enterprise"
                          ],
                          "example": "opensource",
                          "type": "string"
                        }
                      },
                      "type": "object"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "401": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "WRONG_USERNAME_OR_PWD"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Login failed. Bad username or password",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [],
        "summary": "Dashboard Auth",
        "tags": [
          "dashboard"
        ]
      }
    },
    "/bridges/{id}": {
      "delete": {
        "description": "Delete a bridge by Id",
        "parameters": [
          {
            "description": "The bridge Id. Must be of format {type}:{name}",
            "example": "webhook:my_webhook",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Bridge deleted"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "INVALID_ID"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Update bridge failed",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "503": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "SERVICE_UNAVAILABLE"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Service unavailable",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "summary": "Delete Bridge",
        "tags": [
          "bridges"
        ]
      },
      "get": {
        "description": "Get a bridge by Id",
        "parameters": [
          {
            "description": "The bridge Id. Must be of format {type}:{name}",
            "example": "webhook:my_webhook",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "mqtt_egress": {
                    "summary": "MQTT Egress Bridge",
                    "value": {
                      "connector": "mqtt:my_mqtt_connector",
                      "direction": "egress",
                      "enable": true,
                      "local_topic": "emqx/#",
                      "metrics": {
                        "failed": 0,
                        "matched": 0,
                        "rate": 0,
                        "rate_last5m": 0,
                        "rate_max": 0,
                        "success": 0
                      },
                      "name": "my_egress_mqtt_bridge",
                      "node_metrics": [
                        {
                          "metrics": {
                            "failed": 0,
                            "matched": 0,
                            "rate": 0,
                            "rate_last5m": 0,
                            "rate_max": 0,
                            "success": 0
                          },
                          "node": "emqx@127.0.0.1"
                        }
                      ],
                      "payload": "${payload}",
                      "remote_qos": "${qos}",
                      "remote_topic": "from_emqx/${topic}",
                      "retain": false,
                      "type": "mqtt"
                    }
                  },
                  "mqtt_ingress": {
                    "summary": "MQTT Ingress Bridge",
                    "value": {
                      "connector": "mqtt:my_mqtt_connector",
                      "direction": "ingress",
                      "enable": true,
                      "local_qos": "${qos}",
                      "local_topic": "from_aws/${topic}",
                      "metrics": {
                        "failed": 0,
                        "matched": 0,
                        "rate": 0,
                        "rate_last5m": 0,
                        "rate_max": 0,
                        "success": 0
                      },
                      "name": "my_ingress_mqtt_bridge",
                      "node_metrics": [
                        {
                          "metrics": {
                            "failed": 0,
                            "matched": 0,
                            "rate": 0,
                            "rate_last5m": 0,
                            "rate_max": 0,
                            "success": 0
                          },
                          "node": "emqx@127.0.0.1"
                        }
                      ],
                      "payload": "${payload}",
                      "remote_qos": 1,
                      "remote_topic": "aws/#",
                      "retain": "${retain}",
                      "type": "mqtt"
                    }
                  },
                  "my_webhook": {
                    "summary": "WebHook",
                    "value": {
                      "body": "${payload}",
                      "connect_timeout": "15s",
                      "enable": true,
                      "enable_pipelining": 100,
                      "local_topic": "emqx_webhook/#",
                      "max_retries": 3,
                      "method": "post",
                      "metrics": {
                        "failed": 0,
                        "matched": 0,
                        "rate": 0,
                        "rate_last5m": 0,
                        "rate_max": 0,
                        "success": 0
                      },
                      "name": "my_webhook",
                      "node_metrics": [
                        {
                          "metrics": {
                            "failed": 0,
                            "matched": 0,
                            "rate": 0,
                            "rate_last5m": 0,
                            "rate_max": 0,
                            "success": 0
                          },
                          "node": "emqx@127.0.0.1"
                        }
                      ],
                      "pool_size": 4,
                      "pool_type": "random",
                      "request_timeout": "15s",
                      "retry_interval": "10s",
                      "ssl": {
                        "enable": false
                      },
                      "type": "webhook",
                      "url": "http://localhost:9901/messages/${topic}"
                    }
                  }
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/emqx_bridge_mqtt_schema.get_egress"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_bridge_mqtt_schema.get_ingress"
                    },
                    {
                      "$ref": "#/components/schemas/bridge.get"
                    }
                  ]
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bridge not found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "summary": "Get Bridge",
        "tags": [
          "bridges"
        ]
      },
      "put": {
        "description": "Update a bridge by Id",
        "parameters": [
          {
            "description": "The bridge Id. Must be of format {type}:{name}",
            "example": "webhook:my_webhook",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "mqtt_egress": {
                  "summary": "MQTT Egress Bridge",
                  "value": {
                    "connector": "mqtt:my_mqtt_connector",
                    "direction": "egress",
                    "enable": true,
                    "local_topic": "emqx/#",
                    "payload": "${payload}",
                    "remote_qos": "${qos}",
                    "remote_topic": "from_emqx/${topic}",
                    "retain": false
                  }
                },
                "mqtt_ingress": {
                  "summary": "MQTT Ingress Bridge",
                  "value": {
                    "connector": "mqtt:my_mqtt_connector",
                    "direction": "ingress",
                    "enable": true,
                    "local_qos": "${qos}",
                    "local_topic": "from_aws/${topic}",
                    "payload": "${payload}",
                    "remote_qos": 1,
                    "remote_topic": "aws/#",
                    "retain": "${retain}"
                  }
                },
                "my_webhook": {
                  "summary": "WebHook",
                  "value": {
                    "body": "${payload}",
                    "connect_timeout": "15s",
                    "enable": true,
                    "enable_pipelining": 100,
                    "local_topic": "emqx_webhook/#",
                    "max_retries": 3,
                    "method": "post",
                    "pool_size": 4,
                    "pool_type": "random",
                    "request_timeout": "15s",
                    "retry_interval": "10s",
                    "ssl": {
                      "enable": false
                    },
                    "url": "http://localhost:9901/messages/${topic}"
                  }
                }
              },
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/emqx_bridge_mqtt_schema.put_egress"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_bridge_mqtt_schema.put_ingress"
                  },
                  {
                    "$ref": "#/components/schemas/bridge.put"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "mqtt_egress": {
                    "summary": "MQTT Egress Bridge",
                    "value": {
                      "connector": "mqtt:my_mqtt_connector",
                      "direction": "egress",
                      "enable": true,
                      "local_topic": "emqx/#",
                      "metrics": {
                        "failed": 0,
                        "matched": 0,
                        "rate": 0,
                        "rate_last5m": 0,
                        "rate_max": 0,
                        "success": 0
                      },
                      "name": "my_egress_mqtt_bridge",
                      "node_metrics": [
                        {
                          "metrics": {
                            "failed": 0,
                            "matched": 0,
                            "rate": 0,
                            "rate_last5m": 0,
                            "rate_max": 0,
                            "success": 0
                          },
                          "node": "emqx@127.0.0.1"
                        }
                      ],
                      "payload": "${payload}",
                      "remote_qos": "${qos}",
                      "remote_topic": "from_emqx/${topic}",
                      "retain": false,
                      "type": "mqtt"
                    }
                  },
                  "mqtt_ingress": {
                    "summary": "MQTT Ingress Bridge",
                    "value": {
                      "connector": "mqtt:my_mqtt_connector",
                      "direction": "ingress",
                      "enable": true,
                      "local_qos": "${qos}",
                      "local_topic": "from_aws/${topic}",
                      "metrics": {
                        "failed": 0,
                        "matched": 0,
                        "rate": 0,
                        "rate_last5m": 0,
                        "rate_max": 0,
                        "success": 0
                      },
                      "name": "my_ingress_mqtt_bridge",
                      "node_metrics": [
                        {
                          "metrics": {
                            "failed": 0,
                            "matched": 0,
                            "rate": 0,
                            "rate_last5m": 0,
                            "rate_max": 0,
                            "success": 0
                          },
                          "node": "emqx@127.0.0.1"
                        }
                      ],
                      "payload": "${payload}",
                      "remote_qos": 1,
                      "remote_topic": "aws/#",
                      "retain": "${retain}",
                      "type": "mqtt"
                    }
                  },
                  "my_webhook": {
                    "summary": "WebHook",
                    "value": {
                      "body": "${payload}",
                      "connect_timeout": "15s",
                      "enable": true,
                      "enable_pipelining": 100,
                      "local_topic": "emqx_webhook/#",
                      "max_retries": 3,
                      "method": "post",
                      "metrics": {
                        "failed": 0,
                        "matched": 0,
                        "rate": 0,
                        "rate_last5m": 0,
                        "rate_max": 0,
                        "success": 0
                      },
                      "name": "my_webhook",
                      "node_metrics": [
                        {
                          "metrics": {
                            "failed": 0,
                            "matched": 0,
                            "rate": 0,
                            "rate_last5m": 0,
                            "rate_max": 0,
                            "success": 0
                          },
                          "node": "emqx@127.0.0.1"
                        }
                      ],
                      "pool_size": 4,
                      "pool_type": "random",
                      "request_timeout": "15s",
                      "retry_interval": "10s",
                      "ssl": {
                        "enable": false
                      },
                      "type": "webhook",
                      "url": "http://localhost:9901/messages/${topic}"
                    }
                  }
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/emqx_bridge_mqtt_schema.get_egress"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_bridge_mqtt_schema.get_ingress"
                    },
                    {
                      "$ref": "#/components/schemas/bridge.get"
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST",
                        "INVALID_ID"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Update bridge failed",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bridge not found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "summary": "Update Bridge",
        "tags": [
          "bridges"
        ]
      }
    },
    "/gateway/lwm2m/clients/{clientid}/observe": {
      "post": {
        "description": "Observe or Cancel observe a resource",
        "parameters": [
          {
            "example": "urn:oma:lwm2m:oma:2",
            "in": "path",
            "name": "clientid",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "example": "/3/0/7",
            "in": "query",
            "name": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "example": true,
            "in": "query",
            "name": "enable",
            "required": true,
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "No Content"
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "CLIENT_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Clientid not found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "lwm2m"
        ]
      }
    },
    "/configs/dashboard": {
      "get": {
        "description": "Get the sub-configurations under *dashboard*",
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/dashboard.dashboard"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "config not found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "conf"
        ]
      },
      "put": {
        "description": "Update the sub-configurations under *dashboard*",
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/dashboard.dashboard"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/dashboard.dashboard"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "UPDATE_FAILED"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Error code to troubleshoot problems.",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "conf"
        ]
      }
    },
    "/cluster/{node}/invite": {
      "put": {
        "description": "Invite node to cluster",
        "parameters": [
          {
            "$ref": "#/components/parameters/cluster.node"
          }
        ],
        "responses": {
          "200": {
            "description": "ok"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Error code to troubleshoot problems.",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "cluster"
        ]
      }
    },
    "/authorization/sources/built_in_database/clientid": {
      "get": {
        "description": "Show the list of record for clientid",
        "parameters": [
          {
            "$ref": "#/components/parameters/public.page"
          },
          {
            "$ref": "#/components/parameters/public.limit"
          },
          {
            "description": "Fuzzy search `clientid` as substring",
            "in": "query",
            "name": "like_clientid",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "password_based:built_in_database": {
                    "summary": "ClientID",
                    "value": {
                      "data": [
                        {
                          "clientid": "client1",
                          "rules": [
                            {
                              "action": "publish",
                              "permission": "allow",
                              "topic": "test/toopic/1"
                            },
                            {
                              "action": "subscribe",
                              "permission": "allow",
                              "topic": "test/toopic/2"
                            },
                            {
                              "action": "all",
                              "permission": "deny",
                              "topic": "eq test/#"
                            }
                          ]
                        }
                      ],
                      "meta": {
                        "count": 1,
                        "limit": 100,
                        "page": 1
                      }
                    }
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/emqx_authz_api_mnesia.clientid_response_data"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "authorization"
        ]
      },
      "post": {
        "description": "Add new records for clientid",
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "password_based:built_in_database": {
                  "summary": "ClientID",
                  "value": [
                    {
                      "clientid": "client1",
                      "rules": [
                        {
                          "action": "publish",
                          "permission": "allow",
                          "topic": "test/toopic/1"
                        },
                        {
                          "action": "subscribe",
                          "permission": "allow",
                          "topic": "test/toopic/2"
                        },
                        {
                          "action": "all",
                          "permission": "deny",
                          "topic": "eq test/#"
                        }
                      ]
                    }
                  ]
                }
              },
              "schema": {
                "items": {
                  "$ref": "#/components/schemas/emqx_authz_api_mnesia.rules_for_clientid"
                },
                "type": "array"
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "Created"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad clientid or bad rule schema",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "authorization"
        ]
      }
    },
    "/configs/node": {
      "get": {
        "description": "Get the sub-configurations under *node*",
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx_conf_schema.node"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "config not found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "conf"
        ]
      },
      "put": {
        "description": "Update the sub-configurations under *node*",
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/emqx_conf_schema.node"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx_conf_schema.node"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "UPDATE_FAILED"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Error code to troubleshoot problems.",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "conf"
        ]
      }
    },
    "/gateway/{name}/authentication/users/{uid}": {
      "delete": {
        "description": "Delete the user for the gateway authentication",
        "parameters": [
          {
            "description": "Gateway Name",
            "example": "",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "User ID",
            "example": "",
            "in": "path",
            "name": "uid",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "User Deleted"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "gateway"
        ]
      },
      "get": {
        "description": "Get user info from the gateway authentication",
        "parameters": [
          {
            "description": "Gateway Name",
            "example": "",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "User ID",
            "example": "",
            "in": "path",
            "name": "uid",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": {
                  "regular_user": {
                    "summary": "Regular user",
                    "value": {
                      "user_id": "user1"
                    }
                  },
                  "super_user": {
                    "summary": "Superuser",
                    "value": {
                      "is_superuser": true,
                      "user_id": "user2"
                    }
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/emqx_authn_api.response_user"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "gateway"
        ]
      },
      "put": {
        "description": "Update the user info for the gateway authentication",
        "parameters": [
          {
            "description": "Gateway Name",
            "example": "",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "User ID",
            "example": "",
            "in": "path",
            "name": "uid",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "regular_user": {
                  "summary": "Update regular user",
                  "value": {
                    "password": "newsecret"
                  }
                },
                "super_user": {
                  "summary": "Update user and promote to superuser",
                  "value": {
                    "is_superuser": true,
                    "password": "newsecret"
                  }
                }
              },
              "schema": {
                "$ref": "#/components/schemas/emqx_authn_api.request_user_update"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": {
                  "regular_user": {
                    "summary": "Regular user",
                    "value": {
                      "user_id": "user1"
                    }
                  },
                  "super_user": {
                    "summary": "Superuser",
                    "value": {
                      "is_superuser": true,
                      "user_id": "user2"
                    }
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/emqx_authn_api.response_user"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "gateway"
        ]
      }
    },
    "/configs/zones": {
      "get": {
        "description": "Get the sub-configurations under *zones*",
        "parameters": [],
        "responses": {
          "200": {
            "description": "A zone is a set of configs grouped by the zone <code>name</code>.</br>For flexible configuration mapping, the <code>name</code> can be set to a listener's <code>zone</code> config.</br>NOTE: A built-in zone named <code>default</code> is auto created and can not be deleted.</br>",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "$name": {
                      "$ref": "#/components/schemas/broker.zone"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "config not found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "conf"
        ]
      },
      "put": {
        "description": "Update the sub-configurations under *zones*",
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "$name": {
                    "$ref": "#/components/schemas/broker.zone"
                  }
                },
                "type": "object"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "A zone is a set of configs grouped by the zone <code>name</code>.</br>For flexible configuration mapping, the <code>name</code> can be set to a listener's <code>zone</code> config.</br>NOTE: A built-in zone named <code>default</code> is auto created and can not be deleted.</br>",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "$name": {
                      "$ref": "#/components/schemas/broker.zone"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "UPDATE_FAILED"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Error code to troubleshoot problems.",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "conf"
        ]
      }
    },
    "/mqtt/retainer/messages": {
      "get": {
        "description": "List retained messages.",
        "parameters": [
          {
            "description": "Page number of the results to fetch.",
            "example": 1,
            "in": "query",
            "name": "page",
            "schema": {
              "default": 1,
              "minimum": 1,
              "type": "integer"
            }
          },
          {
            "description": "Results per page(max 1000)",
            "example": 50,
            "in": "query",
            "name": "limit",
            "schema": {
              "default": 100,
              "maximum": 1000,
              "minimum": 1,
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "data": {
                      "description": "Retained messages list.",
                      "items": {
                        "$ref": "#/components/schemas/retainer.message_summary"
                      },
                      "type": "array"
                    },
                    "meta": {
                      "$ref": "#/components/schemas/public.meta"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Unsupported backend.",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "retainer"
        ]
      }
    },
    "/plugins/{name}/move": {
      "post": {
        "description": "Setting the boot order of plugins.",
        "parameters": [
          {
            "$ref": "#/components/parameters/plugins.name"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "move_to_after": {
                  "summary": "move plugin after other plugins",
                  "value": {
                    "position": "after:emqx_plugin_demo-5.1-rc.2"
                  }
                },
                "move_to_before": {
                  "summary": "move plugin before other plugins",
                  "value": {
                    "position": "before:emqx_plugin_demo-5.1-rc.2"
                  }
                },
                "move_to_front": {
                  "summary": "move plugin on the front",
                  "value": {
                    "position": "front"
                  }
                },
                "move_to_rear": {
                  "summary": "move plugin on the rear",
                  "value": {
                    "position": "rear"
                  }
                }
              },
              "schema": {
                "$ref": "#/components/schemas/plugins.position"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "plugins"
        ]
      }
    },
    "/configs/broker": {
      "get": {
        "description": "Get the sub-configurations under *broker*",
        "parameters": [],
        "responses": {
          "200": {
            "description": "Message broker options.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/broker.broker"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "config not found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "conf"
        ]
      },
      "put": {
        "description": "Update the sub-configurations under *broker*",
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/broker.broker"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Message broker options.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/broker.broker"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "UPDATE_FAILED"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Error code to troubleshoot problems.",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "conf"
        ]
      }
    },
    "/statsd": {
      "get": {
        "description": "Get statsd config",
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": {
                  "enable": true,
                  "flush_time_interval": "32s",
                  "sample_time_interval": "32s",
                  "server": "127.0.0.1:8125"
                },
                "schema": {
                  "$ref": "#/components/schemas/statsd.statsd"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "statsd"
        ]
      },
      "put": {
        "description": "Set statsd config",
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "example": {
                "enable": true,
                "flush_time_interval": "32s",
                "sample_time_interval": "32s",
                "server": "127.0.0.1:8125"
              },
              "schema": {
                "$ref": "#/components/schemas/statsd.statsd"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": {
                  "enable": true,
                  "flush_time_interval": "32s",
                  "sample_time_interval": "32s",
                  "server": "127.0.0.1:8125"
                },
                "schema": {
                  "$ref": "#/components/schemas/statsd.statsd"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "statsd"
        ]
      }
    },
    "/alarms": {
      "delete": {
        "description": "Remove all deactivated alarms",
        "parameters": [],
        "responses": {
          "204": {
            "description": "Remove all deactivated alarms ok"
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "alarms"
        ]
      },
      "get": {
        "description": "List alarms",
        "parameters": [
          {
            "$ref": "#/components/parameters/public.page"
          },
          {
            "$ref": "#/components/parameters/public.limit"
          },
          {
            "description": "Activate alarms, or deactivate alarms. Default is false",
            "in": "query",
            "name": "activated",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "data": {
                      "items": {
                        "$ref": "#/components/schemas/emqx_mgmt_api_alarms.alarm"
                      },
                      "type": "array"
                    },
                    "meta": {
                      "$ref": "#/components/schemas/public.meta"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "alarms"
        ]
      }
    },
    "/gateway": {
      "get": {
        "description": "Get gateway list",
        "parameters": [
          {
            "description": "Gateway Status",
            "example": "",
            "in": "query",
            "name": "status",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": [
                  {
                    "name": "coap",
                    "status": "unloaded"
                  },
                  {
                    "name": "exproto",
                    "status": "unloaded"
                  },
                  {
                    "created_at": "2021-12-08T14:41:26.171+08:00",
                    "current_connections": 0,
                    "listeners": [
                      {
                        "id": "lwm2m:udp:default",
                        "name": "default",
                        "running": true,
                        "type": "udp"
                      }
                    ],
                    "max_connections": 1024000,
                    "name": "lwm2m",
                    "node_status": [
                      {
                        "current_connections": 0,
                        "max_connections": 1024000,
                        "node": "node@127.0.0.1",
                        "status": "running"
                      }
                    ],
                    "started_at": "2021-12-08T14:41:26.202+08:00",
                    "status": "running"
                  },
                  {
                    "created_at": "2021-12-08T14:41:45.071+08:00",
                    "current_connections": 0,
                    "listeners": [
                      {
                        "id": "mqttsn:udp:default",
                        "name": "default",
                        "running": false,
                        "type": "udp"
                      }
                    ],
                    "max_connections": 1024000,
                    "name": "mqttsn",
                    "node_status": [
                      {
                        "current_connections": 0,
                        "max_connections": 1024000,
                        "node": "node@127.0.0.1",
                        "status": "running"
                      }
                    ],
                    "status": "stopped",
                    "stopped_at": "2021-12-08T14:56:35.576+08:00"
                  },
                  {
                    "created_at": "2021-12-08T14:42:15.272+08:00",
                    "current_connections": 0,
                    "listeners": [
                      {
                        "id": "stomp:tcp:default",
                        "name": "default",
                        "running": true,
                        "type": "tcp"
                      }
                    ],
                    "max_connections": 1024000,
                    "name": "stomp",
                    "node_status": [
                      {
                        "current_connections": 0,
                        "max_connections": 1024000,
                        "node": "node@127.0.0.1",
                        "status": "running"
                      }
                    ],
                    "started_at": "2021-12-08T14:42:15.274+08:00",
                    "status": "running"
                  }
                ],
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/emqx_gateway_api.gateway_overview"
                  },
                  "type": "array"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "gateway"
        ]
      },
      "post": {
        "description": "Enable a gateway",
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "coap_gateway": {
                  "summary": "A simple CoAP gateway configs",
                  "value": {
                    "connection_required": false,
                    "enable": true,
                    "enable_stats": true,
                    "heartbeat": "30s",
                    "idle_timeout": "30s",
                    "listeners": [
                      {
                        "bind": "5683",
                        "max_conn_rate": 1000,
                        "max_connections": 1024000,
                        "name": "default",
                        "type": "udp"
                      }
                    ],
                    "mountpoint": "coap/",
                    "name": "coap",
                    "notify_type": "qos",
                    "publish_qos": "coap",
                    "subscribe_qos": "coap"
                  }
                },
                "exproto_gateway": {
                  "summary": "A simple ExProto gateway configs",
                  "value": {
                    "enable": true,
                    "enable_stats": true,
                    "handler": {
                      "address": "http://127.0.0.1:9001"
                    },
                    "idle_timeout": "30s",
                    "listeners": [
                      {
                        "bind": "7993",
                        "max_conn_rate": 1000,
                        "max_connections": 1024000,
                        "name": "default",
                        "type": "tcp"
                      }
                    ],
                    "mountpoint": "exproto/",
                    "name": "exproto",
                    "server": {
                      "bind": "9100"
                    }
                  }
                },
                "lwm2m_gateway": {
                  "summary": "A simple LwM2M gateway configs",
                  "value": {
                    "auto_observe": false,
                    "enable": true,
                    "enable_stats": true,
                    "idle_timeout": "30s",
                    "lifetime_max": "86400s",
                    "lifetime_min": "1s",
                    "listeners": [
                      {
                        "bind": "5783",
                        "max_conn_rate": 1000,
                        "max_connections": 1024000,
                        "name": "default",
                        "type": "udp"
                      }
                    ],
                    "mountpoint": "lwm2m/",
                    "name": "lwm2m",
                    "qmode_time_window": "22s",
                    "translators": {
                      "command": {
                        "topic": "dn/#"
                      },
                      "notify": {
                        "topic": "up/notify"
                      },
                      "register": {
                        "topic": "up/resp"
                      },
                      "response": {
                        "topic": "up/resp"
                      },
                      "update": {
                        "topic": "up/resp"
                      }
                    },
                    "update_msg_publish_condition": "always",
                    "xml_dir": "/mnt/code/src/emqx/0/_build/emqx/rel/emqx/etc/lwm2m_xml"
                  }
                },
                "mqttsn_gateway": {
                  "summary": "A simple MQTT-SN gateway configs",
                  "value": {
                    "broadcast": true,
                    "enable": true,
                    "enable_qos3": true,
                    "enable_stats": true,
                    "gateway_id": 1,
                    "idle_timeout": "30s",
                    "listeners": [
                      {
                        "bind": "1884",
                        "max_conn_rate": 1000,
                        "max_connections": 1024000,
                        "name": "default",
                        "type": "udp"
                      }
                    ],
                    "mountpoint": "mqttsn/",
                    "name": "mqttsn",
                    "predefined": [
                      {
                        "id": "1001",
                        "topic": "pred/1001"
                      },
                      {
                        "id": "1002",
                        "topic": "pred/1002"
                      }
                    ]
                  }
                },
                "stomp_gateway": {
                  "summary": "A simple STOMP gateway configs",
                  "value": {
                    "enable": true,
                    "enable_stats": true,
                    "frame": {
                      "max_body_length": 65535,
                      "max_headers": 10,
                      "max_headers_length": 1024
                    },
                    "idle_timeout": "30s",
                    "listeners": [
                      {
                        "bind": "61613",
                        "max_conn_rate": 1000,
                        "max_connections": 1024000,
                        "name": "default",
                        "type": "tcp"
                      }
                    ],
                    "mountpoint": "stomp/",
                    "name": "stomp"
                  }
                }
              },
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/emqx_gateway_api.exproto"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_gateway_api.lwm2m"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_gateway_api.coap"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_gateway_api.mqttsn"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_gateway_api.stomp"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "coap_gateway": {
                    "summary": "A simple CoAP gateway configs",
                    "value": {
                      "connection_required": false,
                      "enable": true,
                      "enable_stats": true,
                      "heartbeat": "30s",
                      "idle_timeout": "30s",
                      "listeners": [
                        {
                          "bind": "5683",
                          "max_conn_rate": 1000,
                          "max_connections": 1024000,
                          "name": "default",
                          "type": "udp"
                        }
                      ],
                      "mountpoint": "coap/",
                      "name": "coap",
                      "notify_type": "qos",
                      "publish_qos": "coap",
                      "subscribe_qos": "coap"
                    }
                  },
                  "exproto_gateway": {
                    "summary": "A simple ExProto gateway configs",
                    "value": {
                      "enable": true,
                      "enable_stats": true,
                      "handler": {
                        "address": "http://127.0.0.1:9001"
                      },
                      "idle_timeout": "30s",
                      "listeners": [
                        {
                          "bind": "7993",
                          "max_conn_rate": 1000,
                          "max_connections": 1024000,
                          "name": "default",
                          "type": "tcp"
                        }
                      ],
                      "mountpoint": "exproto/",
                      "name": "exproto",
                      "server": {
                        "bind": "9100"
                      }
                    }
                  },
                  "lwm2m_gateway": {
                    "summary": "A simple LwM2M gateway configs",
                    "value": {
                      "auto_observe": false,
                      "enable": true,
                      "enable_stats": true,
                      "idle_timeout": "30s",
                      "lifetime_max": "86400s",
                      "lifetime_min": "1s",
                      "listeners": [
                        {
                          "bind": "5783",
                          "max_conn_rate": 1000,
                          "max_connections": 1024000,
                          "name": "default",
                          "type": "udp"
                        }
                      ],
                      "mountpoint": "lwm2m/",
                      "name": "lwm2m",
                      "qmode_time_window": "22s",
                      "translators": {
                        "command": {
                          "topic": "dn/#"
                        },
                        "notify": {
                          "topic": "up/notify"
                        },
                        "register": {
                          "topic": "up/resp"
                        },
                        "response": {
                          "topic": "up/resp"
                        },
                        "update": {
                          "topic": "up/resp"
                        }
                      },
                      "update_msg_publish_condition": "always",
                      "xml_dir": "/mnt/code/src/emqx/0/_build/emqx/rel/emqx/etc/lwm2m_xml"
                    }
                  },
                  "mqttsn_gateway": {
                    "summary": "A simple MQTT-SN gateway configs",
                    "value": {
                      "broadcast": true,
                      "enable": true,
                      "enable_qos3": true,
                      "enable_stats": true,
                      "gateway_id": 1,
                      "idle_timeout": "30s",
                      "listeners": [
                        {
                          "bind": "1884",
                          "max_conn_rate": 1000,
                          "max_connections": 1024000,
                          "name": "default",
                          "type": "udp"
                        }
                      ],
                      "mountpoint": "mqttsn/",
                      "name": "mqttsn",
                      "predefined": [
                        {
                          "id": "1001",
                          "topic": "pred/1001"
                        },
                        {
                          "id": "1002",
                          "topic": "pred/1002"
                        }
                      ]
                    }
                  },
                  "stomp_gateway": {
                    "summary": "A simple STOMP gateway configs",
                    "value": {
                      "enable": true,
                      "enable_stats": true,
                      "frame": {
                        "max_body_length": 65535,
                        "max_headers": 10,
                        "max_headers_length": 1024
                      },
                      "idle_timeout": "30s",
                      "listeners": [
                        {
                          "bind": "61613",
                          "max_conn_rate": 1000,
                          "max_connections": 1024000,
                          "name": "default",
                          "type": "tcp"
                        }
                      ],
                      "mountpoint": "stomp/",
                      "name": "stomp"
                    }
                  }
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api.exproto"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api.lwm2m"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api.coap"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api.mqttsn"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api.stomp"
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "gateway"
        ]
      }
    },
    "/subscriptions": {
      "get": {
        "description": "List subscriptions",
        "parameters": [
          {
            "$ref": "#/components/parameters/public.page"
          },
          {
            "$ref": "#/components/parameters/public.limit"
          },
          {
            "description": "Node name",
            "example": "emqx@127.0.0.1",
            "in": "query",
            "name": "node",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Client ID",
            "in": "query",
            "name": "clientid",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "QoS",
            "in": "query",
            "name": "qos",
            "required": false,
            "schema": {
              "enum": [
                0,
                1,
                2
              ],
              "type": "string"
            }
          },
          {
            "description": "Topic, url encoding",
            "in": "query",
            "name": "topic",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Match topic string, url encoding",
            "in": "query",
            "name": "match_topic",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Shared subscription group name",
            "in": "query",
            "name": "share_group",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/emqx_mgmt_api_subscriptions.subscription"
                  },
                  "type": "array"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "subscriptions"
        ]
      }
    },
    "/bridges/{id}/reset_metrics": {
      "put": {
        "description": "Reset a bridge metrics by Id",
        "parameters": [
          {
            "description": "The bridge Id. Must be of format {type}:{name}",
            "example": "webhook:my_webhook",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Reset success"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "RPC Call Failed",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "summary": "Reset Bridge Metrics",
        "tags": [
          "bridges"
        ]
      }
    },
    "/error_codes": {
      "get": {
        "description": "API Error Codes",
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/dashboard.error_code"
                  },
                  "type": "array"
                }
              }
            }
          }
        },
        "security": [],
        "tags": [
          "error_codes"
        ]
      }
    },
    "/listeners/{listener_id}/authentication/{id}/users/{user_id}": {
      "delete": {
        "description": "Delete user in authenticator in listener authentication chain.",
        "parameters": [
          {
            "description": "Listener ID.",
            "example": "tcp:default",
            "in": "path",
            "name": "listener_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Authenticator ID.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "User ID.",
            "in": "path",
            "name": "user_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "User deleted"
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "authentication",
          "authentication config(single listener)"
        ]
      },
      "get": {
        "description": "Get user from authenticator in listener authentication chain.",
        "parameters": [
          {
            "description": "Listener ID.",
            "example": "tcp:default",
            "in": "path",
            "name": "listener_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Authenticator ID.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "User ID.",
            "in": "path",
            "name": "user_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": {
                  "regular_user": {
                    "summary": "Regular user",
                    "value": {
                      "user_id": "user1"
                    }
                  },
                  "super_user": {
                    "summary": "Superuser",
                    "value": {
                      "is_superuser": true,
                      "user_id": "user2"
                    }
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/emqx_authn_api.response_user"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "authentication",
          "authentication config(single listener)"
        ]
      },
      "put": {
        "description": "Update user in authenticator in listener authentication chain.",
        "parameters": [
          {
            "description": "Listener ID.",
            "example": "tcp:default",
            "in": "path",
            "name": "listener_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Authenticator ID.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "User ID.",
            "in": "path",
            "name": "user_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "example": {
                "regular_user": {
                  "summary": "Update regular user",
                  "value": {
                    "password": "newsecret"
                  }
                },
                "super_user": {
                  "summary": "Update user and promote to superuser",
                  "value": {
                    "is_superuser": true,
                    "password": "newsecret"
                  }
                }
              },
              "schema": {
                "$ref": "#/components/schemas/emqx_authn_api.request_user_update"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": {
                  "regular_user": {
                    "summary": "Regular user",
                    "value": {
                      "user_id": "user1"
                    }
                  },
                  "super_user": {
                    "summary": "Superuser",
                    "value": {
                      "is_superuser": true,
                      "user_id": "user2"
                    }
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/emqx_authn_api.response_user"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad Request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "authentication",
          "authentication config(single listener)"
        ]
      }
    },
    "/authorization/sources/{type}/move": {
      "post": {
        "description": "Change the exection order of sources",
        "parameters": [
          {
            "description": "Authorization type",
            "in": "path",
            "name": "type",
            "required": true,
            "schema": {
              "enum": [
                "http",
                "mongodb",
                "redis",
                "built_in_database",
                "mysql",
                "postgresql",
                "file"
              ],
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "front": {
                  "summary": "front example",
                  "value": {
                    "position": "front"
                  }
                },
                "rear": {
                  "summary": "rear example",
                  "value": {
                    "position": "rear"
                  }
                },
                "relative_after": {
                  "summary": "relative example",
                  "value": {
                    "position": "after:file"
                  }
                },
                "relative_before": {
                  "summary": "relative example",
                  "value": {
                    "position": "before:file"
                  }
                }
              },
              "schema": {
                "$ref": "#/components/schemas/emqx_authz_api_schema.position"
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "No Content"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad Request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "authorization"
        ]
      }
    },
    "/listeners/{listener_id}/authentication/{id}/import_users": {
      "post": {
        "description": "Import users into authenticator in listener authentication chain.",
        "parameters": [
          {
            "description": "Listener ID.",
            "example": "tcp:default",
            "in": "path",
            "name": "listener_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Authenticator ID.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "multipart/form-data": {
              "schema": {
                "filename": "file"
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "Users imported"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad Request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "authentication",
          "authentication config(single listener)"
        ]
      }
    },
    "/telemetry/data": {
      "get": {
        "description": "Get telemetry data",
        "parameters": [],
        "responses": {
          "200": {
            "description": "Get telemetry data",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx_telemetry_api.telemetry"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "telemetry"
        ]
      }
    },
    "/authentication": {
      "get": {
        "description": "List authenticators for global authentication.",
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": [
                  {
                    "algorithm": "hmac-based",
                    "mechanism": "jwt",
                    "secret": "mysecret",
                    "secret_base64_encoded": false,
                    "use_jwks": false,
                    "verify_claims": {
                      "username": "${username}"
                    }
                  },
                  {
                    "backend": "built_in_database",
                    "mechanism": "password_based",
                    "password_hash_algorithm": {
                      "name": "sha256",
                      "salt_position": "suffix"
                    },
                    "user_id_type": "username"
                  },
                  {
                    "backend": "http",
                    "body": {
                      "password": "${password}",
                      "username": "${username}"
                    },
                    "connect_timeout": 5000,
                    "enable_pipelining": 100,
                    "headers": {
                      "content-type": "application/json"
                    },
                    "mechanism": "password_based",
                    "method": "post",
                    "pool_size": 8,
                    "request_timeout": 5000,
                    "ssl": {
                      "enable": false
                    },
                    "url": "http://127.0.0.1:18083"
                  },
                  {
                    "backend": "mongodb",
                    "collection": "users",
                    "database": "example",
                    "filter": {
                      "username": "${username}"
                    },
                    "is_superuser_field": "is_superuser",
                    "mechanism": "password_based",
                    "password_hash_algorithm": {
                      "name": "sha256",
                      "salt_position": "suffix"
                    },
                    "password_hash_field": "password_hash",
                    "salt_field": "salt",
                    "server": "127.0.0.1:27017"
                  },
                  {
                    "backend": "redis",
                    "cmd": "HMGET ${username} password_hash salt",
                    "database": 0,
                    "mechanism": "password_based",
                    "password_hash_algorithm": {
                      "name": "sha256",
                      "salt_position": "suffix"
                    },
                    "redis_type": "single",
                    "server": "127.0.0.1:6379"
                  }
                ],
                "schema": {
                  "items": {
                    "oneOf": [
                      {
                        "$ref": "#/components/schemas/authn-scram-builtin_db.authentication"
                      },
                      {
                        "$ref": "#/components/schemas/authn-jwt.jwks"
                      },
                      {
                        "$ref": "#/components/schemas/authn-jwt.public-key"
                      },
                      {
                        "$ref": "#/components/schemas/authn-jwt.hmac-based"
                      },
                      {
                        "$ref": "#/components/schemas/authn-http.post"
                      },
                      {
                        "$ref": "#/components/schemas/authn-http.get"
                      },
                      {
                        "$ref": "#/components/schemas/authn-redis.sentinel"
                      },
                      {
                        "$ref": "#/components/schemas/authn-redis.cluster"
                      },
                      {
                        "$ref": "#/components/schemas/authn-redis.standalone"
                      },
                      {
                        "$ref": "#/components/schemas/authn-mongodb.sharded-cluster"
                      },
                      {
                        "$ref": "#/components/schemas/authn-mongodb.replica-set"
                      },
                      {
                        "$ref": "#/components/schemas/authn-mongodb.standalone"
                      },
                      {
                        "$ref": "#/components/schemas/authn-postgresql.authentication"
                      },
                      {
                        "$ref": "#/components/schemas/authn-mysql.authentication"
                      },
                      {
                        "$ref": "#/components/schemas/authn-builtin_db.authentication"
                      }
                    ]
                  },
                  "type": "array"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "authentication",
          "authentication config(global)"
        ]
      },
      "post": {
        "description": "Create authenticator for global authentication.",
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "jwt": {
                  "summary": "JWT authentication",
                  "value": {
                    "algorithm": "hmac-based",
                    "mechanism": "jwt",
                    "secret": "mysecret",
                    "secret_base64_encoded": false,
                    "use_jwks": false,
                    "verify_claims": {
                      "username": "${username}"
                    }
                  }
                },
                "password_based:built_in_database": {
                  "summary": "Built-in password_based authentication",
                  "value": {
                    "backend": "built_in_database",
                    "mechanism": "password_based",
                    "password_hash_algorithm": {
                      "name": "sha256",
                      "salt_position": "suffix"
                    },
                    "user_id_type": "username"
                  }
                },
                "password_based:http": {
                  "summary": "password_based authentication through external HTTP API",
                  "value": {
                    "backend": "http",
                    "body": {
                      "password": "${password}",
                      "username": "${username}"
                    },
                    "connect_timeout": 5000,
                    "enable_pipelining": 100,
                    "headers": {
                      "content-type": "application/json"
                    },
                    "mechanism": "password_based",
                    "method": "post",
                    "pool_size": 8,
                    "request_timeout": 5000,
                    "ssl": {
                      "enable": false
                    },
                    "url": "http://127.0.0.1:18083"
                  }
                },
                "password_based:mongodb": {
                  "summary": "password_based authentication with MongoDB backend",
                  "value": {
                    "backend": "mongodb",
                    "collection": "users",
                    "database": "example",
                    "filter": {
                      "username": "${username}"
                    },
                    "is_superuser_field": "is_superuser",
                    "mechanism": "password_based",
                    "password_hash_algorithm": {
                      "name": "sha256",
                      "salt_position": "suffix"
                    },
                    "password_hash_field": "password_hash",
                    "salt_field": "salt",
                    "server": "127.0.0.1:27017"
                  }
                },
                "password_based:redis": {
                  "summary": "password_based authentication with Redis backend",
                  "value": {
                    "backend": "redis",
                    "cmd": "HMGET ${username} password_hash salt",
                    "database": 0,
                    "mechanism": "password_based",
                    "password_hash_algorithm": {
                      "name": "sha256",
                      "salt_position": "suffix"
                    },
                    "redis_type": "single",
                    "server": "127.0.0.1:6379"
                  }
                }
              },
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/authn-scram-builtin_db.authentication"
                  },
                  {
                    "$ref": "#/components/schemas/authn-jwt.jwks"
                  },
                  {
                    "$ref": "#/components/schemas/authn-jwt.public-key"
                  },
                  {
                    "$ref": "#/components/schemas/authn-jwt.hmac-based"
                  },
                  {
                    "$ref": "#/components/schemas/authn-http.post"
                  },
                  {
                    "$ref": "#/components/schemas/authn-http.get"
                  },
                  {
                    "$ref": "#/components/schemas/authn-redis.sentinel"
                  },
                  {
                    "$ref": "#/components/schemas/authn-redis.cluster"
                  },
                  {
                    "$ref": "#/components/schemas/authn-redis.standalone"
                  },
                  {
                    "$ref": "#/components/schemas/authn-mongodb.sharded-cluster"
                  },
                  {
                    "$ref": "#/components/schemas/authn-mongodb.replica-set"
                  },
                  {
                    "$ref": "#/components/schemas/authn-mongodb.standalone"
                  },
                  {
                    "$ref": "#/components/schemas/authn-postgresql.authentication"
                  },
                  {
                    "$ref": "#/components/schemas/authn-mysql.authentication"
                  },
                  {
                    "$ref": "#/components/schemas/authn-builtin_db.authentication"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "jwt": {
                    "summary": "JWT authentication",
                    "value": {
                      "algorithm": "hmac-based",
                      "mechanism": "jwt",
                      "secret": "mysecret",
                      "secret_base64_encoded": false,
                      "use_jwks": false,
                      "verify_claims": {
                        "username": "${username}"
                      }
                    }
                  },
                  "password_based:built_in_database": {
                    "summary": "Built-in password_based authentication",
                    "value": {
                      "backend": "built_in_database",
                      "mechanism": "password_based",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "user_id_type": "username"
                    }
                  },
                  "password_based:http": {
                    "summary": "password_based authentication through external HTTP API",
                    "value": {
                      "backend": "http",
                      "body": {
                        "password": "${password}",
                        "username": "${username}"
                      },
                      "connect_timeout": 5000,
                      "enable_pipelining": 100,
                      "headers": {
                        "content-type": "application/json"
                      },
                      "mechanism": "password_based",
                      "method": "post",
                      "pool_size": 8,
                      "request_timeout": 5000,
                      "ssl": {
                        "enable": false
                      },
                      "url": "http://127.0.0.1:18083"
                    }
                  },
                  "password_based:mongodb": {
                    "summary": "password_based authentication with MongoDB backend",
                    "value": {
                      "backend": "mongodb",
                      "collection": "users",
                      "database": "example",
                      "filter": {
                        "username": "${username}"
                      },
                      "is_superuser_field": "is_superuser",
                      "mechanism": "password_based",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "password_hash_field": "password_hash",
                      "salt_field": "salt",
                      "server": "127.0.0.1:27017"
                    }
                  },
                  "password_based:redis": {
                    "summary": "password_based authentication with Redis backend",
                    "value": {
                      "backend": "redis",
                      "cmd": "HMGET ${username} password_hash salt",
                      "database": 0,
                      "mechanism": "password_based",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "redis_type": "single",
                      "server": "127.0.0.1:6379"
                    }
                  }
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/authn-scram-builtin_db.authentication"
                    },
                    {
                      "$ref": "#/components/schemas/authn-jwt.jwks"
                    },
                    {
                      "$ref": "#/components/schemas/authn-jwt.public-key"
                    },
                    {
                      "$ref": "#/components/schemas/authn-jwt.hmac-based"
                    },
                    {
                      "$ref": "#/components/schemas/authn-http.post"
                    },
                    {
                      "$ref": "#/components/schemas/authn-http.get"
                    },
                    {
                      "$ref": "#/components/schemas/authn-redis.sentinel"
                    },
                    {
                      "$ref": "#/components/schemas/authn-redis.cluster"
                    },
                    {
                      "$ref": "#/components/schemas/authn-redis.standalone"
                    },
                    {
                      "$ref": "#/components/schemas/authn-mongodb.sharded-cluster"
                    },
                    {
                      "$ref": "#/components/schemas/authn-mongodb.replica-set"
                    },
                    {
                      "$ref": "#/components/schemas/authn-mongodb.standalone"
                    },
                    {
                      "$ref": "#/components/schemas/authn-postgresql.authentication"
                    },
                    {
                      "$ref": "#/components/schemas/authn-mysql.authentication"
                    },
                    {
                      "$ref": "#/components/schemas/authn-builtin_db.authentication"
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad Request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "409": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "ALREADY_EXISTS"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "ALREADY_EXISTS",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "authentication",
          "authentication config(global)"
        ]
      }
    },
    "/clients/{clientid}/subscribe": {
      "post": {
        "description": "Subscribe",
        "parameters": [
          {
            "in": "path",
            "name": "clientid",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/emqx_mgmt_api_clients.subscribe"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx_mgmt_api_subscriptions.subscription"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "CLIENTID_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Client id not found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "clients"
        ]
      }
    },
    "/trace": {
      "delete": {
        "description": "Clear all traces",
        "parameters": [],
        "responses": {
          "204": {
            "description": "No Content"
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "trace"
        ]
      },
      "get": {
        "description": "List all trace",
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/trace.trace"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "trace"
        ]
      },
      "post": {
        "description": "Create new trace",
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "required": [
                  "type",
                  "name"
                ],
                "properties": {
                  "name": {
                    "description": "Unique and format by [a-zA-Z0-9-_]",
                    "example": "EMQX-TRACE-1",
                    "type": "string"
                  },
                  "type": {
                    "description": "Filter type",
                    "enum": [
                      "clientid",
                      "topic",
                      "ip_address"
                    ],
                    "example": "clientid",
                    "type": "string"
                  },
                  "topic": {
                    "description": "support mqtt wildcard topic.",
                    "example": "/dev/#",
                    "type": "string"
                  },
                  "clientid": {
                    "description": "mqtt clientid.",
                    "example": "dev-001",
                    "type": "string"
                  },
                  "ip_address": {
                    "description": "client ip address",
                    "example": "127.0.0.1",
                    "type": "string"
                  },
                  "start_at": {
                    "description": "rfc3339 timestamp or epoch second",
                    "example": "2021-11-04T18:17:38+08:00",
                    "oneOf": [
                      {
                        "description": "epoch-second",
                        "example": 1640995200,
                        "type": "integer"
                      },
                      {
                        "example": "2022-01-01T00:00:00.000Z",
                        "format": "date-time",
                        "type": "string"
                      }
                    ]
                  },
                  "end_at": {
                    "description": "rfc3339 timestamp or epoch second",
                    "example": "2021-11-05T18:17:38+08:00",
                    "oneOf": [
                      {
                        "description": "epoch-second",
                        "example": 1640995200,
                        "type": "integer"
                      },
                      {
                        "example": "2022-01-01T00:00:00.000Z",
                        "format": "date-time",
                        "type": "string"
                      }
                    ]
                  }
                },
                "type": "object"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/trace.trace"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "ALREADY_EXISTS",
                        "DUPLICATE_CONDITION",
                        "INVALID_PARAMS"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "trace name already exists",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "trace"
        ]
      }
    },
    "/exhooks/{name}/move": {
      "post": {
        "description": "Move the server.</br>NOTE: The position should be \"front | rear | before:{name} | after:{name}",
        "parameters": [
          {
            "description": "The Exhook server name",
            "example": "default",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "front": {
                  "summary": "absolute position 'front'",
                  "value": {
                    "position": "front"
                  }
                },
                "rear": {
                  "summary": "absolute position 'rear'",
                  "value": {
                    "position": "rear"
                  }
                },
                "related_after": {
                  "summary": "relative position 'after'",
                  "value": {
                    "position": "after:default"
                  }
                },
                "related_before": {
                  "summary": "relative position 'before'",
                  "value": {
                    "position": "before:default"
                  }
                }
              },
              "schema": {
                "$ref": "#/components/schemas/exhook.move_req"
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "No Content"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad Request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "500": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_RPC"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad RPC",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "exhooks"
        ]
      }
    },
    "/slow_subscriptions/settings": {
      "get": {
        "description": "View slow subs settings",
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/slow_subs.slow_subs"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "slow subs"
        ]
      },
      "put": {
        "description": "Update slow subs settings",
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/slow_subs.slow_subs"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/slow_subs.slow_subs"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "slow subs"
        ]
      }
    },
    "/authentication/{id}/move": {
      "post": {
        "description": "Move authenticator in global authentication chain.",
        "parameters": [
          {
            "description": "Authenticator ID.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "move_before_password_based:built_in_database": {
                  "summary": "Move authenticator to the position preceding some other authenticator",
                  "value": {
                    "position": "before:password_based:built_in_database"
                  }
                },
                "move_to_front": {
                  "summary": "Move authenticator to the beginning of the chain",
                  "value": {
                    "position": "front"
                  }
                },
                "move_to_rear": {
                  "summary": "Move authenticator to the end of the chain",
                  "value": {
                    "position": "rear"
                  }
                }
              },
              "schema": {
                "$ref": "#/components/schemas/emqx_authn_api.request_move"
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "Authenticator moved"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad Request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "authentication",
          "authentication config(global)"
        ]
      }
    },
    "/mqtt/topic_metrics": {
      "get": {
        "description": "List Topic metrics",
        "parameters": [],
        "responses": {
          "200": {
            "description": "List Topic metrics",
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/emqx_topic_metrics_api.topic_metrics"
                  },
                  "type": "array"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "mqtt"
        ]
      },
      "post": {
        "description": "Create Topic metrics",
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "required": [
                  "topic"
                ],
                "properties": {
                  "topic": {
                    "description": "Raw topic string",
                    "example": "testtopic/1",
                    "type": "string"
                  }
                },
                "type": "object"
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "Create Topic metrics"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST",
                        "BAD_TOPIC"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad Request. Already exists or bad topic name",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "409": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "EXCEED_LIMIT"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Conflict. Topic metrics exceeded max limit 512",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "mqtt"
        ]
      },
      "put": {
        "description": "Reset telemetry status",
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "reset_all_topic_metrics": {
                  "summary": "reset_all_topic_metrics",
                  "value": {
                    "action": "reset"
                  }
                },
                "reset_specific_one_topic_metrics": {
                  "summary": "reset_specific_one_topic_metrics",
                  "value": {
                    "action": "reset",
                    "topic": "testtopic/1"
                  }
                }
              },
              "schema": {
                "$ref": "#/components/schemas/emqx_topic_metrics_api.reset"
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "Reset telemetry status"
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "TOPIC_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found. Topic metrics not found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "mqtt"
        ]
      }
    },
    "/configs/trace": {
      "get": {
        "description": "Get the sub-configurations under *trace*",
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/broker.trace"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "config not found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "conf"
        ]
      },
      "put": {
        "description": "Update the sub-configurations under *trace*",
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/broker.trace"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/broker.trace"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "UPDATE_FAILED"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Error code to troubleshoot problems.",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "conf"
        ]
      }
    },
    "/error_codes/{code}": {
      "get": {
        "description": "API Error Codes",
        "parameters": [
          {
            "description": "API Error Codes",
            "example": "WRONG_USERNAME_OR_PWD",
            "in": "path",
            "name": "code",
            "required": true,
            "schema": {
              "enum": [
                "WRONG_USERNAME_OR_PWD",
                "WRONG_USERNAME_OR_PWD_OR_API_KEY_OR_API_SECRET",
                "BAD_REQUEST",
                "NOT_MATCH",
                "ALREADY_EXISTS",
                "BAD_CONFIG_SCHEMA",
                "BAD_LISTENER_ID",
                "BAD_NODE_NAME",
                "BAD_RPC",
                "BAD_TOPIC",
                "EXCEED_LIMIT",
                "INVALID_PARAMETER",
                "CONFLICT",
                "NO_DEFAULT_VALUE",
                "DEPENDENCY_EXISTS",
                "MESSAGE_ID_SCHEMA_ERROR",
                "INVALID_ID",
                "MESSAGE_ID_NOT_FOUND",
                "NOT_FOUND",
                "CLIENTID_NOT_FOUND",
                "CLIENT_NOT_FOUND",
                "RESOURCE_NOT_FOUND",
                "TOPIC_NOT_FOUND",
                "USER_NOT_FOUND",
                "INTERNAL_ERROR",
                "SERVICE_UNAVAILABLE",
                "SOURCE_ERROR",
                "UPDATE_FAILED",
                "REST_FAILED",
                "CLIENT_NOT_RESPONSE"
              ],
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/dashboard.error_code"
                }
              }
            }
          }
        },
        "security": [],
        "tags": [
          "error_codes"
        ]
      }
    },
    "/mqtt/delayed/messages": {
      "get": {
        "description": "List delayed messages",
        "parameters": [
          {
            "$ref": "#/components/parameters/public.page"
          },
          {
            "$ref": "#/components/parameters/public.limit"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "data": {
                      "items": {
                        "$ref": "#/components/schemas/emqx_delayed_api.message"
                      },
                      "type": "array"
                    },
                    "meta": {
                      "properties": {
                        "page": {
                          "description": "View page",
                          "minimum": 1,
                          "type": "integer"
                        },
                        "limit": {
                          "description": "Page limit",
                          "minimum": 1,
                          "type": "integer"
                        },
                        "count": {
                          "description": "Count of delayed messages",
                          "minimum": 0,
                          "type": "integer"
                        }
                      },
                      "type": "object"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "mqtt"
        ]
      }
    },
    "/users/{username}": {
      "delete": {
        "description": "Delete dashboard user",
        "parameters": [
          {
            "description": "Dashboard Username",
            "example": "admin",
            "in": "path",
            "maxLength": 100,
            "name": "username",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Delete User successfully"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST",
                        "NOT_ALLOWED"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Login failed. Bad username or password",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "USER_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Dashboard user not found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "dashboard"
        ]
      },
      "put": {
        "description": "Update dashboard user description",
        "parameters": [
          {
            "description": "Dashboard Username",
            "example": "admin",
            "in": "path",
            "maxLength": 100,
            "name": "username",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "description": {
                    "description": "Dashboard User Description",
                    "example": "administrator",
                    "type": "string"
                  }
                },
                "type": "object"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "username": {
                      "description": "Dashboard Username",
                      "example": "admin",
                      "maxLength": 100,
                      "type": "string"
                    },
                    "description": {
                      "description": "Dashboard User Description",
                      "example": "administrator",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "USER_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Dashboard user not found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "dashboard"
        ]
      }
    },
    "/exhooks": {
      "get": {
        "description": "List all servers",
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/exhook.detail_server_info"
                  },
                  "type": "array"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "exhooks"
        ]
      },
      "post": {
        "description": "Add a server",
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "example": {
                "auto_reconnect": "60s",
                "enable": true,
                "failed_action": "deny",
                "name": "default",
                "pool_size": 8,
                "request_timeout": "5s",
                "ssl": {
                  "cacertfile": "/mnt/code/src/emqx/0/_build/emqx/rel/emqx/etc/certs/cacert.pem",
                  "certfile": "/mnt/code/src/emqx/0/_build/emqx/rel/emqx/etc/certs/cert.pem",
                  "enable": false,
                  "keyfile": "/mnt/code/src/emqx/0/_build/emqx/rel/emqx/etc/certs/key.pem"
                },
                "url": "http://127.0.0.1:8081"
              },
              "schema": {
                "$ref": "#/components/schemas/exhook.server_config"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/exhook.detail_server_info"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Already exists",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "500": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_RPC"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad RPC",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "exhooks"
        ]
      }
    },
    "/gateway/{name}/listeners": {
      "get": {
        "description": "Get the gateway listeners",
        "parameters": [
          {
            "description": "Gateway Name",
            "example": "",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": [
                  {
                    "acceptors": 16,
                    "access_rules": [
                      "allow all"
                    ],
                    "bind": "22213",
                    "current_connections": 0,
                    "dtls_options": {
                      "cacertfile": "/mnt/code/src/emqx/0/_build/emqx/rel/emqx/etc/certs/cacert.pem",
                      "certfile": "/mnt/code/src/emqx/0/_build/emqx/rel/emqx/etc/certs/cert.pem",
                      "fail_if_no_peer_cert": false,
                      "keyfile": "/mnt/code/src/emqx/0/_build/emqx/rel/emqx/etc/certs/key.pem",
                      "verify": "verify_none",
                      "versions": [
                        "dtlsv1.2",
                        "dtlsv1"
                      ]
                    },
                    "max_conn_rate": 1000,
                    "max_connections": 1024000,
                    "name": "dtls-def",
                    "node_status": [
                      {
                        "current_connections": 0,
                        "max_connections": 1024000,
                        "node": "127.0.0.1"
                      }
                    ],
                    "type": "dtls",
                    "udp_options": {
                      "active_n": 100,
                      "backlog": 1024
                    }
                  },
                  {
                    "acceptors": 16,
                    "bind": "22214",
                    "current_connections": 0,
                    "dtls_options": {
                      "cacertfile": "/mnt/code/src/emqx/0/_build/emqx/rel/emqx/etc/certs/cacert.pem",
                      "certfile": "/mnt/code/src/emqx/0/_build/emqx/rel/emqx/etc/certs/cert.pem",
                      "ciphers": "RSA-PSK-AES256-GCM-SHA384,RSA-PSK-AES256-CBC-SHA384,RSA-PSK-AES128-GCM-SHA256,RSA-PSK-AES128-CBC-SHA256,RSA-PSK-AES256-CBC-SHA,RSA-PSK-AES128-CBC-SHA",
                      "fail_if_no_peer_cert": false,
                      "keyfile": "/mnt/code/src/emqx/0/_build/emqx/rel/emqx/etc/certs/key.pem",
                      "user_lookup_fun": "emqx_tls_psk:lookup",
                      "verify": "verify_none",
                      "versions": [
                        "dtlsv1.2",
                        "dtlsv1"
                      ]
                    },
                    "max_conn_rate": 1000,
                    "max_connections": 1024000,
                    "name": "dtls-psk",
                    "node_status": [
                      {
                        "current_connections": 0,
                        "max_connections": 1024000,
                        "node": "127.0.0.1"
                      }
                    ],
                    "type": "dtls"
                  },
                  {
                    "acceptors": 16,
                    "authentication": {
                      "backend": "built_in_database",
                      "mechanism": "password_based",
                      "password_hash_algorithm": {
                        "name": "sha256"
                      },
                      "user_id_type": "username"
                    },
                    "bind": "22215",
                    "current_connections": 0,
                    "max_conn_rate": 1000,
                    "max_connections": 1024000,
                    "name": "tcp-with-authn",
                    "node_status": [
                      {
                        "current_connections": 0,
                        "max_connections": 1024000,
                        "node": "127.0.0.1"
                      }
                    ],
                    "type": "tcp"
                  },
                  {
                    "acceptors": 16,
                    "access_rules": [
                      "allow all"
                    ],
                    "bind": "22211",
                    "current_connections": 0,
                    "max_conn_rate": 1000,
                    "max_connections": 1024000,
                    "name": "ssl-def",
                    "node_status": [
                      {
                        "current_connections": 0,
                        "max_connections": 1024000,
                        "node": "127.0.0.1"
                      }
                    ],
                    "ssl_options": {
                      "cacertfile": "/mnt/code/src/emqx/0/_build/emqx/rel/emqx/etc/certs/cacert.pem",
                      "certfile": "/mnt/code/src/emqx/0/_build/emqx/rel/emqx/etc/certs/cert.pem",
                      "fail_if_no_peer_cert": false,
                      "keyfile": "/mnt/code/src/emqx/0/_build/emqx/rel/emqx/etc/certs/key.pem",
                      "verify": "verify_none",
                      "versions": [
                        "tlsv1.3",
                        "tlsv1.2",
                        "tlsv1.1",
                        "tlsv1"
                      ]
                    },
                    "tcp_options": {
                      "active_n": 100,
                      "backlog": 1024
                    },
                    "type": "ssl"
                  },
                  {
                    "acceptors": 16,
                    "bind": "22210",
                    "current_connections": 0,
                    "max_conn_rate": 1000,
                    "max_connections": 1024000,
                    "name": "tcp-def",
                    "node_status": [
                      {
                        "current_connections": 0,
                        "max_connections": 1024000,
                        "node": "127.0.0.1"
                      }
                    ],
                    "tcp_options": {
                      "active_n": 100,
                      "backlog": 1024,
                      "buffer": "10KB",
                      "high_watermark": "1MB",
                      "nodelay": false,
                      "recbuf": "10KB",
                      "reuseaddr": true,
                      "send_timeout": "15s",
                      "send_timeout_close": true,
                      "sndbuf": "10KB"
                    },
                    "type": "tcp"
                  },
                  {
                    "bind": "22212",
                    "current_connections": 0,
                    "name": "udp-def",
                    "node_status": [
                      {
                        "current_connections": 0,
                        "max_connections": 1024000,
                        "node": "127.0.0.1"
                      }
                    ],
                    "type": "udp",
                    "udp_options": {
                      "active_n": 100,
                      "buffer": "10KB",
                      "recbuf": "10KB",
                      "reuseaddr": true,
                      "sndbuf": "10KB"
                    }
                  }
                ],
                "schema": {
                  "items": {
                    "oneOf": [
                      {
                        "$ref": "#/components/schemas/emqx_gateway_api_listeners.dtls_listener"
                      },
                      {
                        "$ref": "#/components/schemas/emqx_gateway_api_listeners.udp_listener"
                      },
                      {
                        "$ref": "#/components/schemas/emqx_gateway_api_listeners.ssl_listener"
                      },
                      {
                        "$ref": "#/components/schemas/emqx_gateway_api_listeners.tcp_listener"
                      }
                    ]
                  },
                  "type": "array"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "gateway"
        ]
      },
      "post": {
        "description": "Create the gateway listener",
        "parameters": [
          {
            "description": "Gateway Name",
            "example": "",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "dtls_listener": {
                  "summary": "A simple dtls listener example",
                  "value": {
                    "acceptors": 16,
                    "access_rules": [
                      "allow all"
                    ],
                    "bind": "22213",
                    "dtls_options": {
                      "cacertfile": "/mnt/code/src/emqx/0/_build/emqx/rel/emqx/etc/certs/cacert.pem",
                      "certfile": "/mnt/code/src/emqx/0/_build/emqx/rel/emqx/etc/certs/cert.pem",
                      "fail_if_no_peer_cert": false,
                      "keyfile": "/mnt/code/src/emqx/0/_build/emqx/rel/emqx/etc/certs/key.pem",
                      "verify": "verify_none",
                      "versions": [
                        "dtlsv1.2",
                        "dtlsv1"
                      ]
                    },
                    "max_conn_rate": 1000,
                    "max_connections": 1024000,
                    "name": "dtls-def",
                    "type": "dtls",
                    "udp_options": {
                      "active_n": 100,
                      "backlog": 1024
                    }
                  }
                },
                "dtls_listener_with_psk_ciphers": {
                  "summary": "A dtls listener with PSK example",
                  "value": {
                    "acceptors": 16,
                    "bind": "22214",
                    "dtls_options": {
                      "cacertfile": "/mnt/code/src/emqx/0/_build/emqx/rel/emqx/etc/certs/cacert.pem",
                      "certfile": "/mnt/code/src/emqx/0/_build/emqx/rel/emqx/etc/certs/cert.pem",
                      "ciphers": "RSA-PSK-AES256-GCM-SHA384,RSA-PSK-AES256-CBC-SHA384,RSA-PSK-AES128-GCM-SHA256,RSA-PSK-AES128-CBC-SHA256,RSA-PSK-AES256-CBC-SHA,RSA-PSK-AES128-CBC-SHA",
                      "fail_if_no_peer_cert": false,
                      "keyfile": "/mnt/code/src/emqx/0/_build/emqx/rel/emqx/etc/certs/key.pem",
                      "user_lookup_fun": "emqx_tls_psk:lookup",
                      "verify": "verify_none",
                      "versions": [
                        "dtlsv1.2",
                        "dtlsv1"
                      ]
                    },
                    "max_conn_rate": 1000,
                    "max_connections": 1024000,
                    "name": "dtls-psk",
                    "type": "dtls"
                  }
                },
                "lisetner_with_authn": {
                  "summary": "A tcp listener with authentication example",
                  "value": {
                    "acceptors": 16,
                    "authentication": {
                      "backend": "built_in_database",
                      "mechanism": "password_based",
                      "password_hash_algorithm": {
                        "name": "sha256"
                      },
                      "user_id_type": "username"
                    },
                    "bind": "22215",
                    "max_conn_rate": 1000,
                    "max_connections": 1024000,
                    "name": "tcp-with-authn",
                    "type": "tcp"
                  }
                },
                "ssl_listener": {
                  "summary": "A simple ssl listener example",
                  "value": {
                    "acceptors": 16,
                    "access_rules": [
                      "allow all"
                    ],
                    "bind": "22211",
                    "max_conn_rate": 1000,
                    "max_connections": 1024000,
                    "name": "ssl-def",
                    "ssl_options": {
                      "cacertfile": "/mnt/code/src/emqx/0/_build/emqx/rel/emqx/etc/certs/cacert.pem",
                      "certfile": "/mnt/code/src/emqx/0/_build/emqx/rel/emqx/etc/certs/cert.pem",
                      "fail_if_no_peer_cert": false,
                      "keyfile": "/mnt/code/src/emqx/0/_build/emqx/rel/emqx/etc/certs/key.pem",
                      "verify": "verify_none",
                      "versions": [
                        "tlsv1.3",
                        "tlsv1.2",
                        "tlsv1.1",
                        "tlsv1"
                      ]
                    },
                    "tcp_options": {
                      "active_n": 100,
                      "backlog": 1024
                    },
                    "type": "ssl"
                  }
                },
                "tcp_listener": {
                  "summary": "A simple tcp listener example",
                  "value": {
                    "acceptors": 16,
                    "bind": "22210",
                    "max_conn_rate": 1000,
                    "max_connections": 1024000,
                    "name": "tcp-def",
                    "tcp_options": {
                      "active_n": 100,
                      "backlog": 1024,
                      "buffer": "10KB",
                      "high_watermark": "1MB",
                      "nodelay": false,
                      "recbuf": "10KB",
                      "reuseaddr": true,
                      "send_timeout": "15s",
                      "send_timeout_close": true,
                      "sndbuf": "10KB"
                    },
                    "type": "tcp"
                  }
                },
                "udp_listener": {
                  "summary": "A simple udp listener example",
                  "value": {
                    "bind": "22212",
                    "name": "udp-def",
                    "type": "udp",
                    "udp_options": {
                      "active_n": 100,
                      "buffer": "10KB",
                      "recbuf": "10KB",
                      "reuseaddr": true,
                      "sndbuf": "10KB"
                    }
                  }
                }
              },
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/emqx_gateway_api.dtls_listener"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_gateway_api.udp_listener"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_gateway_api.ssl_listener"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_gateway_api.tcp_listener"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "dtls_listener": {
                    "summary": "A simple dtls listener example",
                    "value": {
                      "acceptors": 16,
                      "access_rules": [
                        "allow all"
                      ],
                      "bind": "22213",
                      "dtls_options": {
                        "cacertfile": "/mnt/code/src/emqx/0/_build/emqx/rel/emqx/etc/certs/cacert.pem",
                        "certfile": "/mnt/code/src/emqx/0/_build/emqx/rel/emqx/etc/certs/cert.pem",
                        "fail_if_no_peer_cert": false,
                        "keyfile": "/mnt/code/src/emqx/0/_build/emqx/rel/emqx/etc/certs/key.pem",
                        "verify": "verify_none",
                        "versions": [
                          "dtlsv1.2",
                          "dtlsv1"
                        ]
                      },
                      "max_conn_rate": 1000,
                      "max_connections": 1024000,
                      "name": "dtls-def",
                      "type": "dtls",
                      "udp_options": {
                        "active_n": 100,
                        "backlog": 1024
                      }
                    }
                  },
                  "dtls_listener_with_psk_ciphers": {
                    "summary": "A dtls listener with PSK example",
                    "value": {
                      "acceptors": 16,
                      "bind": "22214",
                      "dtls_options": {
                        "cacertfile": "/mnt/code/src/emqx/0/_build/emqx/rel/emqx/etc/certs/cacert.pem",
                        "certfile": "/mnt/code/src/emqx/0/_build/emqx/rel/emqx/etc/certs/cert.pem",
                        "ciphers": "RSA-PSK-AES256-GCM-SHA384,RSA-PSK-AES256-CBC-SHA384,RSA-PSK-AES128-GCM-SHA256,RSA-PSK-AES128-CBC-SHA256,RSA-PSK-AES256-CBC-SHA,RSA-PSK-AES128-CBC-SHA",
                        "fail_if_no_peer_cert": false,
                        "keyfile": "/mnt/code/src/emqx/0/_build/emqx/rel/emqx/etc/certs/key.pem",
                        "user_lookup_fun": "emqx_tls_psk:lookup",
                        "verify": "verify_none",
                        "versions": [
                          "dtlsv1.2",
                          "dtlsv1"
                        ]
                      },
                      "max_conn_rate": 1000,
                      "max_connections": 1024000,
                      "name": "dtls-psk",
                      "type": "dtls"
                    }
                  },
                  "lisetner_with_authn": {
                    "summary": "A tcp listener with authentication example",
                    "value": {
                      "acceptors": 16,
                      "authentication": {
                        "backend": "built_in_database",
                        "mechanism": "password_based",
                        "password_hash_algorithm": {
                          "name": "sha256"
                        },
                        "user_id_type": "username"
                      },
                      "bind": "22215",
                      "max_conn_rate": 1000,
                      "max_connections": 1024000,
                      "name": "tcp-with-authn",
                      "type": "tcp"
                    }
                  },
                  "ssl_listener": {
                    "summary": "A simple ssl listener example",
                    "value": {
                      "acceptors": 16,
                      "access_rules": [
                        "allow all"
                      ],
                      "bind": "22211",
                      "max_conn_rate": 1000,
                      "max_connections": 1024000,
                      "name": "ssl-def",
                      "ssl_options": {
                        "cacertfile": "/mnt/code/src/emqx/0/_build/emqx/rel/emqx/etc/certs/cacert.pem",
                        "certfile": "/mnt/code/src/emqx/0/_build/emqx/rel/emqx/etc/certs/cert.pem",
                        "fail_if_no_peer_cert": false,
                        "keyfile": "/mnt/code/src/emqx/0/_build/emqx/rel/emqx/etc/certs/key.pem",
                        "verify": "verify_none",
                        "versions": [
                          "tlsv1.3",
                          "tlsv1.2",
                          "tlsv1.1",
                          "tlsv1"
                        ]
                      },
                      "tcp_options": {
                        "active_n": 100,
                        "backlog": 1024
                      },
                      "type": "ssl"
                    }
                  },
                  "tcp_listener": {
                    "summary": "A simple tcp listener example",
                    "value": {
                      "acceptors": 16,
                      "bind": "22210",
                      "max_conn_rate": 1000,
                      "max_connections": 1024000,
                      "name": "tcp-def",
                      "tcp_options": {
                        "active_n": 100,
                        "backlog": 1024,
                        "buffer": "10KB",
                        "high_watermark": "1MB",
                        "nodelay": false,
                        "recbuf": "10KB",
                        "reuseaddr": true,
                        "send_timeout": "15s",
                        "send_timeout_close": true,
                        "sndbuf": "10KB"
                      },
                      "type": "tcp"
                    }
                  },
                  "udp_listener": {
                    "summary": "A simple udp listener example",
                    "value": {
                      "bind": "22212",
                      "name": "udp-def",
                      "type": "udp",
                      "udp_options": {
                        "active_n": 100,
                        "buffer": "10KB",
                        "recbuf": "10KB",
                        "reuseaddr": true,
                        "sndbuf": "10KB"
                      }
                    }
                  }
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api.dtls_listener"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api.udp_listener"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api.ssl_listener"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api.tcp_listener"
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "gateway"
        ]
      }
    },
    "/gateway/{name}/listeners/{id}/authentication": {
      "delete": {
        "description": "Remove authentication for the listener",
        "parameters": [
          {
            "description": "Gateway Name",
            "example": "",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Listener ID",
            "example": "",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Deleted"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "gateway"
        ]
      },
      "get": {
        "description": "Get the listener's authentication info",
        "parameters": [
          {
            "description": "Gateway Name",
            "example": "",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Listener ID",
            "example": "",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "jwt": {
                    "summary": "JWT authentication",
                    "value": {
                      "algorithm": "hmac-based",
                      "mechanism": "jwt",
                      "secret": "mysecret",
                      "secret_base64_encoded": false,
                      "use_jwks": false,
                      "verify_claims": {
                        "username": "${username}"
                      }
                    }
                  },
                  "password_based:built_in_database": {
                    "summary": "Built-in password_based authentication",
                    "value": {
                      "backend": "built_in_database",
                      "mechanism": "password_based",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "user_id_type": "username"
                    }
                  },
                  "password_based:http": {
                    "summary": "password_based authentication through external HTTP API",
                    "value": {
                      "backend": "http",
                      "body": {
                        "password": "${password}",
                        "username": "${username}"
                      },
                      "connect_timeout": 5000,
                      "enable_pipelining": 100,
                      "headers": {
                        "content-type": "application/json"
                      },
                      "mechanism": "password_based",
                      "method": "post",
                      "pool_size": 8,
                      "request_timeout": 5000,
                      "ssl": {
                        "enable": false
                      },
                      "url": "http://127.0.0.1:18083"
                    }
                  },
                  "password_based:mongodb": {
                    "summary": "password_based authentication with MongoDB backend",
                    "value": {
                      "backend": "mongodb",
                      "collection": "users",
                      "database": "example",
                      "filter": {
                        "username": "${username}"
                      },
                      "is_superuser_field": "is_superuser",
                      "mechanism": "password_based",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "password_hash_field": "password_hash",
                      "salt_field": "salt",
                      "server": "127.0.0.1:27017"
                    }
                  },
                  "password_based:redis": {
                    "summary": "password_based authentication with Redis backend",
                    "value": {
                      "backend": "redis",
                      "cmd": "HMGET ${username} password_hash salt",
                      "database": 0,
                      "mechanism": "password_based",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "redis_type": "single",
                      "server": "127.0.0.1:6379"
                    }
                  }
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/authn-jwt.jwks"
                    },
                    {
                      "$ref": "#/components/schemas/authn-jwt.public-key"
                    },
                    {
                      "$ref": "#/components/schemas/authn-jwt.hmac-based"
                    },
                    {
                      "$ref": "#/components/schemas/authn-http.post"
                    },
                    {
                      "$ref": "#/components/schemas/authn-http.get"
                    },
                    {
                      "$ref": "#/components/schemas/authn-redis.sentinel"
                    },
                    {
                      "$ref": "#/components/schemas/authn-redis.cluster"
                    },
                    {
                      "$ref": "#/components/schemas/authn-redis.standalone"
                    },
                    {
                      "$ref": "#/components/schemas/authn-mongodb.sharded-cluster"
                    },
                    {
                      "$ref": "#/components/schemas/authn-mongodb.replica-set"
                    },
                    {
                      "$ref": "#/components/schemas/authn-mongodb.standalone"
                    },
                    {
                      "$ref": "#/components/schemas/authn-postgresql.authentication"
                    },
                    {
                      "$ref": "#/components/schemas/authn-mysql.authentication"
                    },
                    {
                      "$ref": "#/components/schemas/authn-builtin_db.authentication"
                    }
                  ]
                }
              }
            }
          },
          "204": {
            "description": "Authentication or listener does not existed"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "gateway"
        ]
      },
      "post": {
        "description": "Add authentication for the listener",
        "parameters": [
          {
            "description": "Gateway Name",
            "example": "",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Listener ID",
            "example": "",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "jwt": {
                  "summary": "JWT authentication",
                  "value": {
                    "algorithm": "hmac-based",
                    "mechanism": "jwt",
                    "secret": "mysecret",
                    "secret_base64_encoded": false,
                    "use_jwks": false,
                    "verify_claims": {
                      "username": "${username}"
                    }
                  }
                },
                "password_based:built_in_database": {
                  "summary": "Built-in password_based authentication",
                  "value": {
                    "backend": "built_in_database",
                    "mechanism": "password_based",
                    "password_hash_algorithm": {
                      "name": "sha256",
                      "salt_position": "suffix"
                    },
                    "user_id_type": "username"
                  }
                },
                "password_based:http": {
                  "summary": "password_based authentication through external HTTP API",
                  "value": {
                    "backend": "http",
                    "body": {
                      "password": "${password}",
                      "username": "${username}"
                    },
                    "connect_timeout": 5000,
                    "enable_pipelining": 100,
                    "headers": {
                      "content-type": "application/json"
                    },
                    "mechanism": "password_based",
                    "method": "post",
                    "pool_size": 8,
                    "request_timeout": 5000,
                    "ssl": {
                      "enable": false
                    },
                    "url": "http://127.0.0.1:18083"
                  }
                },
                "password_based:mongodb": {
                  "summary": "password_based authentication with MongoDB backend",
                  "value": {
                    "backend": "mongodb",
                    "collection": "users",
                    "database": "example",
                    "filter": {
                      "username": "${username}"
                    },
                    "is_superuser_field": "is_superuser",
                    "mechanism": "password_based",
                    "password_hash_algorithm": {
                      "name": "sha256",
                      "salt_position": "suffix"
                    },
                    "password_hash_field": "password_hash",
                    "salt_field": "salt",
                    "server": "127.0.0.1:27017"
                  }
                },
                "password_based:redis": {
                  "summary": "password_based authentication with Redis backend",
                  "value": {
                    "backend": "redis",
                    "cmd": "HMGET ${username} password_hash salt",
                    "database": 0,
                    "mechanism": "password_based",
                    "password_hash_algorithm": {
                      "name": "sha256",
                      "salt_position": "suffix"
                    },
                    "redis_type": "single",
                    "server": "127.0.0.1:6379"
                  }
                }
              },
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/authn-jwt.jwks"
                  },
                  {
                    "$ref": "#/components/schemas/authn-jwt.public-key"
                  },
                  {
                    "$ref": "#/components/schemas/authn-jwt.hmac-based"
                  },
                  {
                    "$ref": "#/components/schemas/authn-http.post"
                  },
                  {
                    "$ref": "#/components/schemas/authn-http.get"
                  },
                  {
                    "$ref": "#/components/schemas/authn-redis.sentinel"
                  },
                  {
                    "$ref": "#/components/schemas/authn-redis.cluster"
                  },
                  {
                    "$ref": "#/components/schemas/authn-redis.standalone"
                  },
                  {
                    "$ref": "#/components/schemas/authn-mongodb.sharded-cluster"
                  },
                  {
                    "$ref": "#/components/schemas/authn-mongodb.replica-set"
                  },
                  {
                    "$ref": "#/components/schemas/authn-mongodb.standalone"
                  },
                  {
                    "$ref": "#/components/schemas/authn-postgresql.authentication"
                  },
                  {
                    "$ref": "#/components/schemas/authn-mysql.authentication"
                  },
                  {
                    "$ref": "#/components/schemas/authn-builtin_db.authentication"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "jwt": {
                    "summary": "JWT authentication",
                    "value": {
                      "algorithm": "hmac-based",
                      "mechanism": "jwt",
                      "secret": "mysecret",
                      "secret_base64_encoded": false,
                      "use_jwks": false,
                      "verify_claims": {
                        "username": "${username}"
                      }
                    }
                  },
                  "password_based:built_in_database": {
                    "summary": "Built-in password_based authentication",
                    "value": {
                      "backend": "built_in_database",
                      "mechanism": "password_based",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "user_id_type": "username"
                    }
                  },
                  "password_based:http": {
                    "summary": "password_based authentication through external HTTP API",
                    "value": {
                      "backend": "http",
                      "body": {
                        "password": "${password}",
                        "username": "${username}"
                      },
                      "connect_timeout": 5000,
                      "enable_pipelining": 100,
                      "headers": {
                        "content-type": "application/json"
                      },
                      "mechanism": "password_based",
                      "method": "post",
                      "pool_size": 8,
                      "request_timeout": 5000,
                      "ssl": {
                        "enable": false
                      },
                      "url": "http://127.0.0.1:18083"
                    }
                  },
                  "password_based:mongodb": {
                    "summary": "password_based authentication with MongoDB backend",
                    "value": {
                      "backend": "mongodb",
                      "collection": "users",
                      "database": "example",
                      "filter": {
                        "username": "${username}"
                      },
                      "is_superuser_field": "is_superuser",
                      "mechanism": "password_based",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "password_hash_field": "password_hash",
                      "salt_field": "salt",
                      "server": "127.0.0.1:27017"
                    }
                  },
                  "password_based:redis": {
                    "summary": "password_based authentication with Redis backend",
                    "value": {
                      "backend": "redis",
                      "cmd": "HMGET ${username} password_hash salt",
                      "database": 0,
                      "mechanism": "password_based",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "redis_type": "single",
                      "server": "127.0.0.1:6379"
                    }
                  }
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/authn-jwt.jwks"
                    },
                    {
                      "$ref": "#/components/schemas/authn-jwt.public-key"
                    },
                    {
                      "$ref": "#/components/schemas/authn-jwt.hmac-based"
                    },
                    {
                      "$ref": "#/components/schemas/authn-http.post"
                    },
                    {
                      "$ref": "#/components/schemas/authn-http.get"
                    },
                    {
                      "$ref": "#/components/schemas/authn-redis.sentinel"
                    },
                    {
                      "$ref": "#/components/schemas/authn-redis.cluster"
                    },
                    {
                      "$ref": "#/components/schemas/authn-redis.standalone"
                    },
                    {
                      "$ref": "#/components/schemas/authn-mongodb.sharded-cluster"
                    },
                    {
                      "$ref": "#/components/schemas/authn-mongodb.replica-set"
                    },
                    {
                      "$ref": "#/components/schemas/authn-mongodb.standalone"
                    },
                    {
                      "$ref": "#/components/schemas/authn-postgresql.authentication"
                    },
                    {
                      "$ref": "#/components/schemas/authn-mysql.authentication"
                    },
                    {
                      "$ref": "#/components/schemas/authn-builtin_db.authentication"
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "gateway"
        ]
      },
      "put": {
        "description": "Update authentication for the listener",
        "parameters": [
          {
            "description": "Gateway Name",
            "example": "",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Listener ID",
            "example": "",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "jwt": {
                  "summary": "JWT authentication",
                  "value": {
                    "algorithm": "hmac-based",
                    "mechanism": "jwt",
                    "secret": "mysecret",
                    "secret_base64_encoded": false,
                    "use_jwks": false,
                    "verify_claims": {
                      "username": "${username}"
                    }
                  }
                },
                "password_based:built_in_database": {
                  "summary": "Built-in password_based authentication",
                  "value": {
                    "backend": "built_in_database",
                    "mechanism": "password_based",
                    "password_hash_algorithm": {
                      "name": "sha256",
                      "salt_position": "suffix"
                    },
                    "user_id_type": "username"
                  }
                },
                "password_based:http": {
                  "summary": "password_based authentication through external HTTP API",
                  "value": {
                    "backend": "http",
                    "body": {
                      "password": "${password}",
                      "username": "${username}"
                    },
                    "connect_timeout": 5000,
                    "enable_pipelining": 100,
                    "headers": {
                      "content-type": "application/json"
                    },
                    "mechanism": "password_based",
                    "method": "post",
                    "pool_size": 8,
                    "request_timeout": 5000,
                    "ssl": {
                      "enable": false
                    },
                    "url": "http://127.0.0.1:18083"
                  }
                },
                "password_based:mongodb": {
                  "summary": "password_based authentication with MongoDB backend",
                  "value": {
                    "backend": "mongodb",
                    "collection": "users",
                    "database": "example",
                    "filter": {
                      "username": "${username}"
                    },
                    "is_superuser_field": "is_superuser",
                    "mechanism": "password_based",
                    "password_hash_algorithm": {
                      "name": "sha256",
                      "salt_position": "suffix"
                    },
                    "password_hash_field": "password_hash",
                    "salt_field": "salt",
                    "server": "127.0.0.1:27017"
                  }
                },
                "password_based:redis": {
                  "summary": "password_based authentication with Redis backend",
                  "value": {
                    "backend": "redis",
                    "cmd": "HMGET ${username} password_hash salt",
                    "database": 0,
                    "mechanism": "password_based",
                    "password_hash_algorithm": {
                      "name": "sha256",
                      "salt_position": "suffix"
                    },
                    "redis_type": "single",
                    "server": "127.0.0.1:6379"
                  }
                }
              },
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/authn-jwt.jwks"
                  },
                  {
                    "$ref": "#/components/schemas/authn-jwt.public-key"
                  },
                  {
                    "$ref": "#/components/schemas/authn-jwt.hmac-based"
                  },
                  {
                    "$ref": "#/components/schemas/authn-http.post"
                  },
                  {
                    "$ref": "#/components/schemas/authn-http.get"
                  },
                  {
                    "$ref": "#/components/schemas/authn-redis.sentinel"
                  },
                  {
                    "$ref": "#/components/schemas/authn-redis.cluster"
                  },
                  {
                    "$ref": "#/components/schemas/authn-redis.standalone"
                  },
                  {
                    "$ref": "#/components/schemas/authn-mongodb.sharded-cluster"
                  },
                  {
                    "$ref": "#/components/schemas/authn-mongodb.replica-set"
                  },
                  {
                    "$ref": "#/components/schemas/authn-mongodb.standalone"
                  },
                  {
                    "$ref": "#/components/schemas/authn-postgresql.authentication"
                  },
                  {
                    "$ref": "#/components/schemas/authn-mysql.authentication"
                  },
                  {
                    "$ref": "#/components/schemas/authn-builtin_db.authentication"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "jwt": {
                    "summary": "JWT authentication",
                    "value": {
                      "algorithm": "hmac-based",
                      "mechanism": "jwt",
                      "secret": "mysecret",
                      "secret_base64_encoded": false,
                      "use_jwks": false,
                      "verify_claims": {
                        "username": "${username}"
                      }
                    }
                  },
                  "password_based:built_in_database": {
                    "summary": "Built-in password_based authentication",
                    "value": {
                      "backend": "built_in_database",
                      "mechanism": "password_based",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "user_id_type": "username"
                    }
                  },
                  "password_based:http": {
                    "summary": "password_based authentication through external HTTP API",
                    "value": {
                      "backend": "http",
                      "body": {
                        "password": "${password}",
                        "username": "${username}"
                      },
                      "connect_timeout": 5000,
                      "enable_pipelining": 100,
                      "headers": {
                        "content-type": "application/json"
                      },
                      "mechanism": "password_based",
                      "method": "post",
                      "pool_size": 8,
                      "request_timeout": 5000,
                      "ssl": {
                        "enable": false
                      },
                      "url": "http://127.0.0.1:18083"
                    }
                  },
                  "password_based:mongodb": {
                    "summary": "password_based authentication with MongoDB backend",
                    "value": {
                      "backend": "mongodb",
                      "collection": "users",
                      "database": "example",
                      "filter": {
                        "username": "${username}"
                      },
                      "is_superuser_field": "is_superuser",
                      "mechanism": "password_based",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "password_hash_field": "password_hash",
                      "salt_field": "salt",
                      "server": "127.0.0.1:27017"
                    }
                  },
                  "password_based:redis": {
                    "summary": "password_based authentication with Redis backend",
                    "value": {
                      "backend": "redis",
                      "cmd": "HMGET ${username} password_hash salt",
                      "database": 0,
                      "mechanism": "password_based",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "redis_type": "single",
                      "server": "127.0.0.1:6379"
                    }
                  }
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/authn-jwt.jwks"
                    },
                    {
                      "$ref": "#/components/schemas/authn-jwt.public-key"
                    },
                    {
                      "$ref": "#/components/schemas/authn-jwt.hmac-based"
                    },
                    {
                      "$ref": "#/components/schemas/authn-http.post"
                    },
                    {
                      "$ref": "#/components/schemas/authn-http.get"
                    },
                    {
                      "$ref": "#/components/schemas/authn-redis.sentinel"
                    },
                    {
                      "$ref": "#/components/schemas/authn-redis.cluster"
                    },
                    {
                      "$ref": "#/components/schemas/authn-redis.standalone"
                    },
                    {
                      "$ref": "#/components/schemas/authn-mongodb.sharded-cluster"
                    },
                    {
                      "$ref": "#/components/schemas/authn-mongodb.replica-set"
                    },
                    {
                      "$ref": "#/components/schemas/authn-mongodb.standalone"
                    },
                    {
                      "$ref": "#/components/schemas/authn-postgresql.authentication"
                    },
                    {
                      "$ref": "#/components/schemas/authn-mysql.authentication"
                    },
                    {
                      "$ref": "#/components/schemas/authn-builtin_db.authentication"
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "gateway"
        ]
      }
    },
    "/slow_subscriptions": {
      "delete": {
        "description": "Clear current data and re count slow topic",
        "parameters": [],
        "responses": {
          "204": {
            "description": "No Content"
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "slow subs"
        ]
      },
      "get": {
        "description": "View slow topics statistics record data",
        "parameters": [
          {
            "$ref": "#/components/parameters/public.page"
          },
          {
            "$ref": "#/components/parameters/public.limit"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "data": {
                      "items": {
                        "$ref": "#/components/schemas/slow_subscribers_statistics.record"
                      },
                      "type": "array"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "slow subs"
        ]
      }
    },
    "/nodes": {
      "get": {
        "description": "List EMQX nodes",
        "parameters": [],
        "responses": {
          "200": {
            "description": "List all EMQX nodes",
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/emqx_mgmt_api_nodes.node_info"
                  },
                  "type": "array"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "nodes"
        ]
      }
    },
    "/authorization/sources/built_in_database/all": {
      "get": {
        "description": "Show the list of rules for all",
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "password_based:built_in_database": {
                    "summary": "All",
                    "value": {
                      "rules": [
                        {
                          "action": "publish",
                          "permission": "allow",
                          "topic": "test/toopic/1"
                        },
                        {
                          "action": "subscribe",
                          "permission": "allow",
                          "topic": "test/toopic/2"
                        },
                        {
                          "action": "all",
                          "permission": "deny",
                          "topic": "eq test/#"
                        }
                      ]
                    }
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/emqx_authz_api_mnesia.rules"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "authorization"
        ]
      },
      "post": {
        "description": "</br>Create/Update the list of rules for all.</br>Set a empty list to clean up rules</br>",
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "password_based:built_in_database": {
                  "summary": "All",
                  "value": {
                    "rules": [
                      {
                        "action": "publish",
                        "permission": "allow",
                        "topic": "test/toopic/1"
                      },
                      {
                        "action": "subscribe",
                        "permission": "allow",
                        "topic": "test/toopic/2"
                      },
                      {
                        "action": "all",
                        "permission": "deny",
                        "topic": "eq test/#"
                      }
                    ]
                  }
                }
              },
              "schema": {
                "$ref": "#/components/schemas/emqx_authz_api_mnesia.rules"
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "Updated"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad rule schema",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "authorization"
        ]
      }
    },
    "/authorization/sources/{type}": {
      "delete": {
        "description": "Delete source",
        "parameters": [
          {
            "description": "Authorization type",
            "in": "path",
            "name": "type",
            "required": true,
            "schema": {
              "enum": [
                "http",
                "mongodb",
                "redis",
                "built_in_database",
                "mysql",
                "postgresql",
                "file"
              ],
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Deleted successfully"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad Request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "authorization"
        ]
      },
      "get": {
        "description": "Get a authorization source",
        "parameters": [
          {
            "description": "Authorization type",
            "in": "path",
            "name": "type",
            "required": true,
            "schema": {
              "enum": [
                "http",
                "mongodb",
                "redis",
                "built_in_database",
                "mysql",
                "postgresql",
                "file"
              ],
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Authorization source",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/emqx_authz_api_schema.file"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_authz_api_schema.postgresql"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_authz_api_schema.mysql"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_authz_api_schema.built_in_database"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_authz_api_schema.redis_cluster"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_authz_api_schema.redis_sentinel"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_authz_api_schema.redis_single"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_authz_api_schema.mongo_sharded"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_authz_api_schema.mongo_rs"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_authz_api_schema.mongo_single"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_authz_api_schema.http_post"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_authz_api_schema.http_get"
                    }
                  ]
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "authorization"
        ]
      },
      "put": {
        "description": "Update source",
        "parameters": [
          {
            "description": "Authorization type",
            "in": "path",
            "name": "type",
            "required": true,
            "schema": {
              "enum": [
                "http",
                "mongodb",
                "redis",
                "built_in_database",
                "mysql",
                "postgresql",
                "file"
              ],
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/emqx_authz_api_schema.file"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_authz_api_schema.postgresql"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_authz_api_schema.mysql"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_authz_api_schema.built_in_database"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_authz_api_schema.redis_cluster"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_authz_api_schema.redis_sentinel"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_authz_api_schema.redis_single"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_authz_api_schema.mongo_sharded"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_authz_api_schema.mongo_rs"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_authz_api_schema.mongo_single"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_authz_api_schema.http_post"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_authz_api_schema.http_get"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "Authorization source updated successfully"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad Request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "authorization"
        ]
      }
    },
    "/api_key": {
      "get": {
        "description": "Return api_key list",
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "name": {
                      "description": "Unique and format by [a-zA-Z0-9-_]",
                      "example": "EMQX-API-KEY-1",
                      "type": "string"
                    },
                    "api_key": {
                      "description": "TODO:uses HMAC-SHA256 for signing.",
                      "example": "a4697a5c75a769f6",
                      "type": "string"
                    },
                    "expired_at": {
                      "default": "infinity",
                      "description": "No longer valid datetime",
                      "example": "2021-12-05T02:01:34.186Z",
                      "oneOf": [
                        {
                          "oneOf": [
                            {
                              "description": "epoch-second",
                              "example": 1640995200,
                              "type": "integer"
                            },
                            {
                              "example": "2022-01-01T00:00:00.000Z",
                              "format": "date-time",
                              "type": "string"
                            }
                          ]
                        },
                        {
                          "enum": [
                            "infinity"
                          ],
                          "type": "string"
                        }
                      ]
                    },
                    "created_at": {
                      "description": "ApiKey create datetime",
                      "example": "2021-12-01T00:00:00.000Z",
                      "oneOf": [
                        {
                          "description": "epoch-second",
                          "example": 1640995200,
                          "type": "integer"
                        },
                        {
                          "example": "2022-01-01T00:00:00.000Z",
                          "format": "date-time",
                          "type": "string"
                        }
                      ]
                    },
                    "desc": {
                      "example": "Note",
                      "type": "string"
                    },
                    "enable": {
                      "description": "Enable/Disable",
                      "type": "boolean"
                    },
                    "expired": {
                      "description": "Expired",
                      "type": "boolean"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "api_key"
        ]
      },
      "post": {
        "description": "Create new api_key",
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "name": {
                    "description": "Unique and format by [a-zA-Z0-9-_]",
                    "example": "EMQX-API-KEY-1",
                    "type": "string"
                  },
                  "expired_at": {
                    "default": "infinity",
                    "description": "No longer valid datetime",
                    "example": "2021-12-05T02:01:34.186Z",
                    "oneOf": [
                      {
                        "oneOf": [
                          {
                            "description": "epoch-second",
                            "example": 1640995200,
                            "type": "integer"
                          },
                          {
                            "example": "2022-01-01T00:00:00.000Z",
                            "format": "date-time",
                            "type": "string"
                          }
                        ]
                      },
                      {
                        "enum": [
                          "infinity"
                        ],
                        "type": "string"
                      }
                    ]
                  },
                  "desc": {
                    "example": "Note",
                    "type": "string"
                  },
                  "enable": {
                    "description": "Enable/Disable",
                    "type": "boolean"
                  },
                  "expired": {
                    "description": "Expired",
                    "type": "boolean"
                  }
                },
                "type": "object"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/api_key.app"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Error code to troubleshoot problems.",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "api_key"
        ]
      }
    },
    "/listeners/{id}/start": {
      "post": {
        "description": "Start the listener on all nodes.",
        "parameters": [
          {
            "$ref": "#/components/parameters/listeners.listener_id"
          }
        ],
        "responses": {
          "200": {
            "description": "Updated"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST",
                        "BAD_LISTENER_ID"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Error code to troubleshoot problems.",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "listeners"
        ]
      }
    },
    "/banned": {
      "get": {
        "description": "List banned.",
        "parameters": [
          {
            "$ref": "#/components/parameters/public.page"
          },
          {
            "$ref": "#/components/parameters/public.limit"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "data": {
                      "items": {
                        "$ref": "#/components/schemas/emqx_mgmt_api_banned.ban"
                      },
                      "type": "array"
                    },
                    "meta": {
                      "$ref": "#/components/schemas/public.meta"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "banned"
        ]
      },
      "post": {
        "description": "Create banned.",
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/emqx_mgmt_api_banned.ban"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "data": {
                      "items": {
                        "$ref": "#/components/schemas/emqx_mgmt_api_banned.ban"
                      },
                      "type": "array"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "ALREADY_EXISTS",
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Banned already existed, or bad args.",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "banned"
        ]
      }
    },
    "/trace/{name}/log": {
      "get": {
        "description": "view trace log",
        "parameters": [
          {
            "$ref": "#/components/parameters/trace.name"
          },
          {
            "$ref": "#/components/parameters/trace.bytes"
          },
          {
            "$ref": "#/components/parameters/trace.position"
          },
          {
            "$ref": "#/components/parameters/trace.node"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "items": {
                      "example": "TEXT-LOG-ITEMS",
                      "type": "string"
                    },
                    "bytes": {
                      "default": 1000,
                      "description": "Maximum number of bytes to store in request",
                      "type": "integer"
                    },
                    "position": {
                      "default": 0,
                      "description": "Offset from the current trace position.",
                      "type": "integer"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "trace"
        ]
      }
    },
    "/connectors": {
      "get": {
        "description": "List all connectors",
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": [
                  {
                    "clean_start": true,
                    "clientid": "foo",
                    "keepalive": "300s",
                    "max_inflight": 100,
                    "mode": "cluster_shareload",
                    "name": "my_mqtt_connector",
                    "password": "bar",
                    "proto_ver": "v4",
                    "reconnect_interval": "15s",
                    "retry_interval": "15s",
                    "server": "127.0.0.1:1883",
                    "ssl": {
                      "enable": false
                    },
                    "type": "mqtt",
                    "username": "foo"
                  }
                ],
                "schema": {
                  "items": {
                    "oneOf": [
                      {
                        "$ref": "#/components/schemas/emqx_connector_mqtt.get"
                      }
                    ]
                  },
                  "type": "array"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "summary": "List connectors",
        "tags": [
          "connectors"
        ]
      },
      "post": {
        "description": "Create a new connector",
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "mqtt": {
                  "summary": "MQTT Connector",
                  "value": {
                    "clean_start": true,
                    "clientid": "foo",
                    "keepalive": "300s",
                    "max_inflight": 100,
                    "mode": "cluster_shareload",
                    "name": "my_mqtt_connector",
                    "password": "bar",
                    "proto_ver": "v4",
                    "reconnect_interval": "15s",
                    "retry_interval": "15s",
                    "server": "127.0.0.1:1883",
                    "ssl": {
                      "enable": false
                    },
                    "type": "mqtt",
                    "username": "foo"
                  }
                }
              },
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/emqx_connector_mqtt.post"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "mqtt": {
                    "summary": "MQTT Connector",
                    "value": {
                      "clean_start": true,
                      "clientid": "foo",
                      "keepalive": "300s",
                      "max_inflight": 100,
                      "mode": "cluster_shareload",
                      "name": "my_mqtt_connector",
                      "password": "bar",
                      "proto_ver": "v4",
                      "reconnect_interval": "15s",
                      "retry_interval": "15s",
                      "server": "127.0.0.1:1883",
                      "ssl": {
                        "enable": false
                      },
                      "type": "mqtt",
                      "username": "foo"
                    }
                  }
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/emqx_connector_mqtt.get"
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "ALREADY_EXISTS"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "connector already exists",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "summary": "Create connector",
        "tags": [
          "connectors"
        ]
      }
    },
    "/bridges/{id}/operation/{operation}": {
      "post": {
        "description": "Enable/Disable/Stop/Restart bridges on all nodes in the cluster.",
        "parameters": [
          {
            "description": "The bridge Id. Must be of format {type}:{name}",
            "example": "webhook:my_webhook",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Operations can be one of: enable, disable, start, stop, restart",
            "example": "start",
            "in": "path",
            "name": "operation",
            "required": true,
            "schema": {
              "enum": [
                "enable",
                "disable",
                "stop",
                "restart"
              ],
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Operation success"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "INVALID_ID"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad bridge ID",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "503": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "SERVICE_UNAVAILABLE"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Service unavailable",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "summary": "Enable/Disable/Stop/Restart Bridge",
        "tags": [
          "bridges"
        ]
      }
    },
    "/trace/{name}": {
      "delete": {
        "description": "Delete trace by name",
        "parameters": [
          {
            "$ref": "#/components/parameters/trace.name"
          }
        ],
        "responses": {
          "204": {
            "description": "Delete successfully"
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Trace Name Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "trace"
        ]
      }
    },
    "/trace/{name}/stop": {
      "put": {
        "description": "Stop trace by name",
        "parameters": [
          {
            "$ref": "#/components/parameters/trace.name"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/trace.trace"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Trace Name Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "trace"
        ]
      }
    },
    "/listeners/{id}/restart": {
      "post": {
        "description": "Restart listeners on all nodes.",
        "parameters": [
          {
            "$ref": "#/components/parameters/listeners.listener_id"
          }
        ],
        "responses": {
          "200": {
            "description": "Updated"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST",
                        "BAD_LISTENER_ID"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Error code to troubleshoot problems.",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "listeners"
        ]
      }
    },
    "/mqtt/retainer/message/{topic}": {
      "delete": {
        "description": "Delete matching messages.",
        "parameters": [
          {
            "description": "Topic.",
            "in": "path",
            "name": "topic",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": ""
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Unsupported backend.",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "retainer"
        ]
      },
      "get": {
        "description": "Lookup a message by a topic without wildcards.",
        "parameters": [
          {
            "description": "Topic.",
            "in": "path",
            "name": "topic",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Details of the message.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/retainer.message"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Unsupported backend.",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Viewed message doesn't exist.",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "retainer"
        ]
      }
    },
    "/rule_events": {
      "get": {
        "description": "List all events can be used in rules",
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx_rule_api_schema.rule_events"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "summary": "List Events",
        "tags": [
          "rules"
        ]
      }
    },
    "/clients/{clientid}/unsubscribe": {
      "post": {
        "description": "Unsubscribe",
        "parameters": [
          {
            "in": "path",
            "name": "clientid",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/emqx_mgmt_api_clients.unsubscribe"
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "Unsubscribe OK"
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "CLIENTID_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Client id not found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "clients"
        ]
      }
    },
    "/plugins/install": {
      "post": {
        "description": "Install a plugin(plugin-vsn.tar.gz).Follow [emqx-plugin-template](https://github.com/emqx/emqx-plugin-template) to develop plugin.",
        "parameters": [],
        "requestBody": {
          "content": {
            "multipart/form-data": {
              "encoding": {
                "plugin": {
                  "contentType": "application/gzip"
                }
              },
              "schema": {
                "properties": {
                  "plugin": {
                    "format": "binary",
                    "type": "string"
                  }
                },
                "type": "object"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "UNEXPECTED_ERROR",
                        "ALREADY_INSTALLED",
                        "BAD_PLUGIN_INFO"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Error code to troubleshoot problems.",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "plugins"
        ]
      }
    },
    "/configs/listeners": {
      "get": {
        "description": "Get the sub-configurations under *listeners*",
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/broker.listeners"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "config not found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "conf"
        ]
      },
      "put": {
        "description": "Update the sub-configurations under *listeners*",
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/broker.listeners"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/broker.listeners"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "UPDATE_FAILED"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Error code to troubleshoot problems.",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "conf"
        ]
      }
    },
    "/banned/{as}/{who}": {
      "delete": {
        "description": "Delete banned",
        "parameters": [
          {
            "description": "Banned type clientid, username, peerhost",
            "example": "username",
            "in": "path",
            "name": "as",
            "required": true,
            "schema": {
              "enum": [
                "clientid",
                "username",
                "peerhost"
              ],
              "type": "string"
            }
          },
          {
            "description": "Client info as banned type",
            "example": "Badass",
            "in": "path",
            "name": "who",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Delete banned success"
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Banned not found. May be the banned time has been exceeded",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "banned"
        ]
      }
    },
    "/configs_reset/{rootname}": {
      "post": {
        "description": "Reset the config entry specified by the query string parameter `conf_path`.</br>- For a config entry that has default value, this resets it to the default value;</br>- For a config entry that has no default value, an error 400 will be returned",
        "parameters": [
          {
            "example": "sysmon",
            "in": "path",
            "name": "rootname",
            "required": true,
            "schema": {
              "enum": [
                "listeners",
                "zones",
                "node",
                "cluster",
                "log",
                "broker",
                "sysmon",
                "alarm",
                "persistent_session_store",
                "trace",
                "dashboard"
              ],
              "type": "string"
            }
          },
          {
            "description": "The config path separated by '.' character",
            "example": "os.sysmem_high_watermark",
            "in": "query",
            "name": "conf_path",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Rest config successfully"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NO_DEFAULT_VALUE",
                        "REST_FAILED"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Error code to troubleshoot problems.",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "conf"
        ]
      }
    },
    "/mqtt/retainer": {
      "get": {
        "description": "View config",
        "parameters": [],
        "responses": {
          "200": {
            "description": "The config content",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/retainer.retainer"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Config not found.",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "retainer"
        ]
      },
      "put": {
        "description": "Update retainer config.",
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/retainer.retainer"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Update configs successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/retainer.retainer"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "UPDATE_FAILED"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Update config failed",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "retainer"
        ]
      }
    },
    "/listeners/{listener_id}/authentication/{id}/status": {
      "get": {
        "description": "Get authenticator status from listener authentication chain.",
        "parameters": [
          {
            "description": "Listener ID.",
            "example": "tcp:default",
            "in": "path",
            "name": "listener_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Authenticator ID.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "status_metrics": {
                    "summary": "Authn status metrics",
                    "value": {
                      "metrics": {
                        "failed": 0,
                        "nomatch": 0,
                        "rate": 0,
                        "rate_last5m": 0,
                        "rate_max": 0,
                        "success": 0,
                        "total": 0
                      },
                      "node_error": [],
                      "node_metrics": [
                        {
                          "metrics": {
                            "failed": 0,
                            "matched": 0,
                            "nomatch": 0,
                            "rate": 0,
                            "rate_last5m": 0,
                            "rate_max": 0,
                            "total": 0
                          },
                          "node": "emqx@127.0.0.1"
                        }
                      ],
                      "node_resource_metrics": [
                        {
                          "metrics": {
                            "failed": 0,
                            "matched": 0,
                            "rate": 0,
                            "rate_last5m": 0,
                            "rate_max": 0,
                            "success": 0
                          },
                          "node": "emqx@127.0.0.1"
                        }
                      ],
                      "node_status": [
                        {
                          "node": "emqx@127.0.0.1",
                          "status": "connected"
                        }
                      ],
                      "resource_metrics": {
                        "failed": 0,
                        "matched": 0,
                        "rate": 0,
                        "rate_last5m": 0,
                        "rate_max": 0,
                        "success": 0
                      },
                      "status": "connected"
                    }
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/emqx_authn_schema.metrics_status_fields"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad Request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "authentication",
          "authentication config(single listener)"
        ]
      }
    },
    "/authorization/cache": {
      "delete": {
        "description": "Clean all authorization cache in the cluster.",
        "parameters": [],
        "responses": {
          "204": {
            "description": "No Content"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad Request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "authorization"
        ]
      }
    },
    "/listeners/{listener_id}/authentication": {
      "get": {
        "description": "List authenticators for listener authentication.",
        "parameters": [
          {
            "description": "Listener ID.",
            "example": "tcp:default",
            "in": "path",
            "name": "listener_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": [
                  {
                    "algorithm": "hmac-based",
                    "mechanism": "jwt",
                    "secret": "mysecret",
                    "secret_base64_encoded": false,
                    "use_jwks": false,
                    "verify_claims": {
                      "username": "${username}"
                    }
                  },
                  {
                    "backend": "built_in_database",
                    "mechanism": "password_based",
                    "password_hash_algorithm": {
                      "name": "sha256",
                      "salt_position": "suffix"
                    },
                    "user_id_type": "username"
                  },
                  {
                    "backend": "http",
                    "body": {
                      "password": "${password}",
                      "username": "${username}"
                    },
                    "connect_timeout": 5000,
                    "enable_pipelining": 100,
                    "headers": {
                      "content-type": "application/json"
                    },
                    "mechanism": "password_based",
                    "method": "post",
                    "pool_size": 8,
                    "request_timeout": 5000,
                    "ssl": {
                      "enable": false
                    },
                    "url": "http://127.0.0.1:18083"
                  },
                  {
                    "backend": "mongodb",
                    "collection": "users",
                    "database": "example",
                    "filter": {
                      "username": "${username}"
                    },
                    "is_superuser_field": "is_superuser",
                    "mechanism": "password_based",
                    "password_hash_algorithm": {
                      "name": "sha256",
                      "salt_position": "suffix"
                    },
                    "password_hash_field": "password_hash",
                    "salt_field": "salt",
                    "server": "127.0.0.1:27017"
                  },
                  {
                    "backend": "redis",
                    "cmd": "HMGET ${username} password_hash salt",
                    "database": 0,
                    "mechanism": "password_based",
                    "password_hash_algorithm": {
                      "name": "sha256",
                      "salt_position": "suffix"
                    },
                    "redis_type": "single",
                    "server": "127.0.0.1:6379"
                  }
                ],
                "schema": {
                  "items": {
                    "oneOf": [
                      {
                        "$ref": "#/components/schemas/authn-scram-builtin_db.authentication"
                      },
                      {
                        "$ref": "#/components/schemas/authn-jwt.jwks"
                      },
                      {
                        "$ref": "#/components/schemas/authn-jwt.public-key"
                      },
                      {
                        "$ref": "#/components/schemas/authn-jwt.hmac-based"
                      },
                      {
                        "$ref": "#/components/schemas/authn-http.post"
                      },
                      {
                        "$ref": "#/components/schemas/authn-http.get"
                      },
                      {
                        "$ref": "#/components/schemas/authn-redis.sentinel"
                      },
                      {
                        "$ref": "#/components/schemas/authn-redis.cluster"
                      },
                      {
                        "$ref": "#/components/schemas/authn-redis.standalone"
                      },
                      {
                        "$ref": "#/components/schemas/authn-mongodb.sharded-cluster"
                      },
                      {
                        "$ref": "#/components/schemas/authn-mongodb.replica-set"
                      },
                      {
                        "$ref": "#/components/schemas/authn-mongodb.standalone"
                      },
                      {
                        "$ref": "#/components/schemas/authn-postgresql.authentication"
                      },
                      {
                        "$ref": "#/components/schemas/authn-mysql.authentication"
                      },
                      {
                        "$ref": "#/components/schemas/authn-builtin_db.authentication"
                      }
                    ]
                  },
                  "type": "array"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "authentication",
          "authentication config(single listener)"
        ]
      },
      "post": {
        "description": "Create authenticator for listener authentication.",
        "parameters": [
          {
            "description": "Listener ID.",
            "example": "tcp:default",
            "in": "path",
            "name": "listener_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "jwt": {
                  "summary": "JWT authentication",
                  "value": {
                    "algorithm": "hmac-based",
                    "mechanism": "jwt",
                    "secret": "mysecret",
                    "secret_base64_encoded": false,
                    "use_jwks": false,
                    "verify_claims": {
                      "username": "${username}"
                    }
                  }
                },
                "password_based:built_in_database": {
                  "summary": "Built-in password_based authentication",
                  "value": {
                    "backend": "built_in_database",
                    "mechanism": "password_based",
                    "password_hash_algorithm": {
                      "name": "sha256",
                      "salt_position": "suffix"
                    },
                    "user_id_type": "username"
                  }
                },
                "password_based:http": {
                  "summary": "password_based authentication through external HTTP API",
                  "value": {
                    "backend": "http",
                    "body": {
                      "password": "${password}",
                      "username": "${username}"
                    },
                    "connect_timeout": 5000,
                    "enable_pipelining": 100,
                    "headers": {
                      "content-type": "application/json"
                    },
                    "mechanism": "password_based",
                    "method": "post",
                    "pool_size": 8,
                    "request_timeout": 5000,
                    "ssl": {
                      "enable": false
                    },
                    "url": "http://127.0.0.1:18083"
                  }
                },
                "password_based:mongodb": {
                  "summary": "password_based authentication with MongoDB backend",
                  "value": {
                    "backend": "mongodb",
                    "collection": "users",
                    "database": "example",
                    "filter": {
                      "username": "${username}"
                    },
                    "is_superuser_field": "is_superuser",
                    "mechanism": "password_based",
                    "password_hash_algorithm": {
                      "name": "sha256",
                      "salt_position": "suffix"
                    },
                    "password_hash_field": "password_hash",
                    "salt_field": "salt",
                    "server": "127.0.0.1:27017"
                  }
                },
                "password_based:redis": {
                  "summary": "password_based authentication with Redis backend",
                  "value": {
                    "backend": "redis",
                    "cmd": "HMGET ${username} password_hash salt",
                    "database": 0,
                    "mechanism": "password_based",
                    "password_hash_algorithm": {
                      "name": "sha256",
                      "salt_position": "suffix"
                    },
                    "redis_type": "single",
                    "server": "127.0.0.1:6379"
                  }
                }
              },
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/authn-scram-builtin_db.authentication"
                  },
                  {
                    "$ref": "#/components/schemas/authn-jwt.jwks"
                  },
                  {
                    "$ref": "#/components/schemas/authn-jwt.public-key"
                  },
                  {
                    "$ref": "#/components/schemas/authn-jwt.hmac-based"
                  },
                  {
                    "$ref": "#/components/schemas/authn-http.post"
                  },
                  {
                    "$ref": "#/components/schemas/authn-http.get"
                  },
                  {
                    "$ref": "#/components/schemas/authn-redis.sentinel"
                  },
                  {
                    "$ref": "#/components/schemas/authn-redis.cluster"
                  },
                  {
                    "$ref": "#/components/schemas/authn-redis.standalone"
                  },
                  {
                    "$ref": "#/components/schemas/authn-mongodb.sharded-cluster"
                  },
                  {
                    "$ref": "#/components/schemas/authn-mongodb.replica-set"
                  },
                  {
                    "$ref": "#/components/schemas/authn-mongodb.standalone"
                  },
                  {
                    "$ref": "#/components/schemas/authn-postgresql.authentication"
                  },
                  {
                    "$ref": "#/components/schemas/authn-mysql.authentication"
                  },
                  {
                    "$ref": "#/components/schemas/authn-builtin_db.authentication"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "jwt": {
                    "summary": "JWT authentication",
                    "value": {
                      "algorithm": "hmac-based",
                      "mechanism": "jwt",
                      "secret": "mysecret",
                      "secret_base64_encoded": false,
                      "use_jwks": false,
                      "verify_claims": {
                        "username": "${username}"
                      }
                    }
                  },
                  "password_based:built_in_database": {
                    "summary": "Built-in password_based authentication",
                    "value": {
                      "backend": "built_in_database",
                      "mechanism": "password_based",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "user_id_type": "username"
                    }
                  },
                  "password_based:http": {
                    "summary": "password_based authentication through external HTTP API",
                    "value": {
                      "backend": "http",
                      "body": {
                        "password": "${password}",
                        "username": "${username}"
                      },
                      "connect_timeout": 5000,
                      "enable_pipelining": 100,
                      "headers": {
                        "content-type": "application/json"
                      },
                      "mechanism": "password_based",
                      "method": "post",
                      "pool_size": 8,
                      "request_timeout": 5000,
                      "ssl": {
                        "enable": false
                      },
                      "url": "http://127.0.0.1:18083"
                    }
                  },
                  "password_based:mongodb": {
                    "summary": "password_based authentication with MongoDB backend",
                    "value": {
                      "backend": "mongodb",
                      "collection": "users",
                      "database": "example",
                      "filter": {
                        "username": "${username}"
                      },
                      "is_superuser_field": "is_superuser",
                      "mechanism": "password_based",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "password_hash_field": "password_hash",
                      "salt_field": "salt",
                      "server": "127.0.0.1:27017"
                    }
                  },
                  "password_based:redis": {
                    "summary": "password_based authentication with Redis backend",
                    "value": {
                      "backend": "redis",
                      "cmd": "HMGET ${username} password_hash salt",
                      "database": 0,
                      "mechanism": "password_based",
                      "password_hash_algorithm": {
                        "name": "sha256",
                        "salt_position": "suffix"
                      },
                      "redis_type": "single",
                      "server": "127.0.0.1:6379"
                    }
                  }
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/authn-scram-builtin_db.authentication"
                    },
                    {
                      "$ref": "#/components/schemas/authn-jwt.jwks"
                    },
                    {
                      "$ref": "#/components/schemas/authn-jwt.public-key"
                    },
                    {
                      "$ref": "#/components/schemas/authn-jwt.hmac-based"
                    },
                    {
                      "$ref": "#/components/schemas/authn-http.post"
                    },
                    {
                      "$ref": "#/components/schemas/authn-http.get"
                    },
                    {
                      "$ref": "#/components/schemas/authn-redis.sentinel"
                    },
                    {
                      "$ref": "#/components/schemas/authn-redis.cluster"
                    },
                    {
                      "$ref": "#/components/schemas/authn-redis.standalone"
                    },
                    {
                      "$ref": "#/components/schemas/authn-mongodb.sharded-cluster"
                    },
                    {
                      "$ref": "#/components/schemas/authn-mongodb.replica-set"
                    },
                    {
                      "$ref": "#/components/schemas/authn-mongodb.standalone"
                    },
                    {
                      "$ref": "#/components/schemas/authn-postgresql.authentication"
                    },
                    {
                      "$ref": "#/components/schemas/authn-mysql.authentication"
                    },
                    {
                      "$ref": "#/components/schemas/authn-builtin_db.authentication"
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad Request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "409": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "ALREADY_EXISTS"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "ALREADY_EXISTS",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "authentication",
          "authentication config(single listener)"
        ]
      }
    },
    "/api_key/{name}": {
      "delete": {
        "description": "Delete the specific api_key",
        "parameters": [
          {
            "$ref": "#/components/parameters/api_key.name"
          }
        ],
        "responses": {
          "204": {
            "description": "Delete successfully"
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Error code to troubleshoot problems.",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "api_key"
        ]
      },
      "get": {
        "description": "Return the specific api_key",
        "parameters": [
          {
            "$ref": "#/components/parameters/api_key.name"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "name": {
                      "description": "Unique and format by [a-zA-Z0-9-_]",
                      "example": "EMQX-API-KEY-1",
                      "type": "string"
                    },
                    "api_key": {
                      "description": "TODO:uses HMAC-SHA256 for signing.",
                      "example": "a4697a5c75a769f6",
                      "type": "string"
                    },
                    "expired_at": {
                      "default": "infinity",
                      "description": "No longer valid datetime",
                      "example": "2021-12-05T02:01:34.186Z",
                      "oneOf": [
                        {
                          "oneOf": [
                            {
                              "description": "epoch-second",
                              "example": 1640995200,
                              "type": "integer"
                            },
                            {
                              "example": "2022-01-01T00:00:00.000Z",
                              "format": "date-time",
                              "type": "string"
                            }
                          ]
                        },
                        {
                          "enum": [
                            "infinity"
                          ],
                          "type": "string"
                        }
                      ]
                    },
                    "created_at": {
                      "description": "ApiKey create datetime",
                      "example": "2021-12-01T00:00:00.000Z",
                      "oneOf": [
                        {
                          "description": "epoch-second",
                          "example": 1640995200,
                          "type": "integer"
                        },
                        {
                          "example": "2022-01-01T00:00:00.000Z",
                          "format": "date-time",
                          "type": "string"
                        }
                      ]
                    },
                    "desc": {
                      "example": "Note",
                      "type": "string"
                    },
                    "enable": {
                      "description": "Enable/Disable",
                      "type": "boolean"
                    },
                    "expired": {
                      "description": "Expired",
                      "type": "boolean"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Error code to troubleshoot problems.",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "api_key"
        ]
      },
      "put": {
        "description": "Update the specific api_key",
        "parameters": [
          {
            "$ref": "#/components/parameters/api_key.name"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "expired_at": {
                    "default": "infinity",
                    "description": "No longer valid datetime",
                    "example": "2021-12-05T02:01:34.186Z",
                    "oneOf": [
                      {
                        "oneOf": [
                          {
                            "description": "epoch-second",
                            "example": 1640995200,
                            "type": "integer"
                          },
                          {
                            "example": "2022-01-01T00:00:00.000Z",
                            "format": "date-time",
                            "type": "string"
                          }
                        ]
                      },
                      {
                        "enum": [
                          "infinity"
                        ],
                        "type": "string"
                      }
                    ]
                  },
                  "desc": {
                    "example": "Note",
                    "type": "string"
                  },
                  "enable": {
                    "description": "Enable/Disable",
                    "type": "boolean"
                  },
                  "expired": {
                    "description": "Expired",
                    "type": "boolean"
                  }
                },
                "type": "object"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "name": {
                      "description": "Unique and format by [a-zA-Z0-9-_]",
                      "example": "EMQX-API-KEY-1",
                      "type": "string"
                    },
                    "api_key": {
                      "description": "TODO:uses HMAC-SHA256 for signing.",
                      "example": "a4697a5c75a769f6",
                      "type": "string"
                    },
                    "expired_at": {
                      "default": "infinity",
                      "description": "No longer valid datetime",
                      "example": "2021-12-05T02:01:34.186Z",
                      "oneOf": [
                        {
                          "oneOf": [
                            {
                              "description": "epoch-second",
                              "example": 1640995200,
                              "type": "integer"
                            },
                            {
                              "example": "2022-01-01T00:00:00.000Z",
                              "format": "date-time",
                              "type": "string"
                            }
                          ]
                        },
                        {
                          "enum": [
                            "infinity"
                          ],
                          "type": "string"
                        }
                      ]
                    },
                    "created_at": {
                      "description": "ApiKey create datetime",
                      "example": "2021-12-01T00:00:00.000Z",
                      "oneOf": [
                        {
                          "description": "epoch-second",
                          "example": 1640995200,
                          "type": "integer"
                        },
                        {
                          "example": "2022-01-01T00:00:00.000Z",
                          "format": "date-time",
                          "type": "string"
                        }
                      ]
                    },
                    "desc": {
                      "example": "Note",
                      "type": "string"
                    },
                    "enable": {
                      "description": "Enable/Disable",
                      "type": "boolean"
                    },
                    "expired": {
                      "description": "Expired",
                      "type": "boolean"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Error code to troubleshoot problems.",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "api_key"
        ]
      }
    },
    "/clients/{clientid}/subscriptions": {
      "get": {
        "description": "Get client subscriptions",
        "parameters": [
          {
            "in": "path",
            "name": "clientid",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/emqx_mgmt_api_subscriptions.subscription"
                  },
                  "type": "array"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "CLIENTID_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Client id not found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "clients"
        ]
      }
    },
    "/configs": {
      "get": {
        "description": "Get all the configurations of the specified node, including hot and non-hot updatable items.",
        "parameters": [
          {
            "description": "Node's name: If you do not fill in the fields, this node will be used by default.",
            "example": "emqx@127.0.0.1",
            "in": "query",
            "name": "node",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "listeners": {
                      "$ref": "#/components/schemas/broker.listeners"
                    },
                    "zones": {
                      "description": "A zone is a set of configs grouped by the zone <code>name</code>.</br>For flexible configuration mapping, the <code>name</code> can be set to a listener's <code>zone</code> config.</br>NOTE: A built-in zone named <code>default</code> is auto created and can not be deleted.</br>",
                      "properties": {
                        "$name": {
                          "$ref": "#/components/schemas/broker.zone"
                        }
                      },
                      "type": "object"
                    },
                    "node": {
                      "$ref": "#/components/schemas/emqx_conf_schema.node"
                    },
                    "cluster": {
                      "$ref": "#/components/schemas/emqx_conf_schema.cluster"
                    },
                    "log": {
                      "$ref": "#/components/schemas/emqx_conf_schema.log"
                    },
                    "broker": {
                      "description": "Message broker options.",
                      "$ref": "#/components/schemas/broker.broker"
                    },
                    "sysmon": {
                      "$ref": "#/components/schemas/broker.sysmon"
                    },
                    "alarm": {
                      "$ref": "#/components/schemas/broker.alarm"
                    },
                    "persistent_session_store": {
                      "$ref": "#/components/schemas/broker.persistent_session_store"
                    },
                    "trace": {
                      "$ref": "#/components/schemas/broker.trace"
                    },
                    "dashboard": {
                      "description": "Configuration for EMQX dashboard.",
                      "$ref": "#/components/schemas/dashboard.dashboard"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "conf"
        ]
      }
    },
    "/clients": {
      "get": {
        "description": "List clients",
        "parameters": [
          {
            "$ref": "#/components/parameters/public.page"
          },
          {
            "$ref": "#/components/parameters/public.limit"
          },
          {
            "description": "Node name",
            "example": "emqx@127.0.0.1",
            "in": "query",
            "name": "node",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "User name",
            "in": "query",
            "name": "username",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "zone",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Client's IP address",
            "example": "127.0.0.1",
            "in": "query",
            "name": "ip_address",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The current connection status of the client, the possible values are connected,idle,disconnected",
            "in": "query",
            "name": "conn_state",
            "required": false,
            "schema": {
              "enum": [
                "connected",
                "idle",
                "disconnected"
              ],
              "type": "string"
            }
          },
          {
            "description": "Whether the client uses a new session",
            "in": "query",
            "name": "clean_start",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "description": "Client protocol name, the possible values are MQTT,CoAP,LwM2M,MQTT-SN",
            "in": "query",
            "name": "proto_name",
            "required": false,
            "schema": {
              "enum": [
                "MQTT",
                "CoAP",
                "LwM2M",
                "MQTT-SN"
              ],
              "type": "string"
            }
          },
          {
            "description": "Client protocol version",
            "in": "query",
            "name": "proto_ver",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Fuzzy search `clientid` as substring",
            "in": "query",
            "name": "like_clientid",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Fuzzy search `username` as substring",
            "in": "query",
            "name": "like_username",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Search client session creation time by greater than or equal method, rfc3339 or timestamp(millisecond)",
            "in": "query",
            "name": "gte_created_at",
            "required": false,
            "schema": {
              "oneOf": [
                {
                  "description": "epoch-millisecond",
                  "example": 1640995200000,
                  "type": "integer"
                },
                {
                  "example": "2022-01-01T00:00:00.000Z",
                  "format": "date-time",
                  "type": "string"
                }
              ]
            }
          },
          {
            "description": "Search client session creation time by less than or equal method, rfc3339 or timestamp(millisecond)",
            "in": "query",
            "name": "lte_created_at",
            "required": false,
            "schema": {
              "oneOf": [
                {
                  "description": "epoch-millisecond",
                  "example": 1640995200000,
                  "type": "integer"
                },
                {
                  "example": "2022-01-01T00:00:00.000Z",
                  "format": "date-time",
                  "type": "string"
                }
              ]
            }
          },
          {
            "description": "Search client connection creation time by greater than or equal method, rfc3339 or timestamp(epoch millisecond)",
            "in": "query",
            "name": "gte_connected_at",
            "required": false,
            "schema": {
              "oneOf": [
                {
                  "description": "epoch-millisecond",
                  "example": 1640995200000,
                  "type": "integer"
                },
                {
                  "example": "2022-01-01T00:00:00.000Z",
                  "format": "date-time",
                  "type": "string"
                }
              ]
            }
          },
          {
            "description": "Search client connection creation time by less than or equal method, rfc3339 or timestamp(millisecond)",
            "in": "query",
            "name": "lte_connected_at",
            "required": false,
            "schema": {
              "oneOf": [
                {
                  "description": "epoch-millisecond",
                  "example": 1640995200000,
                  "type": "integer"
                },
                {
                  "example": "2022-01-01T00:00:00.000Z",
                  "format": "date-time",
                  "type": "string"
                }
              ]
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "data": {
                      "items": {
                        "$ref": "#/components/schemas/emqx_mgmt_api_clients.client"
                      },
                      "type": "array"
                    },
                    "meta": {
                      "$ref": "#/components/schemas/public.meta"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "INVALID_PARAMETER"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Invalid parameters",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "clients"
        ]
      }
    },
    "/gateway/{name}/listeners/{id}/authentication/import_users": {
      "post": {
        "description": "Import users into the gateway authentication",
        "parameters": [
          {
            "description": "Gateway Name",
            "example": "stomp",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Listener ID",
            "example": "stomp:tcp:def",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "multipart/form-data": {
              "schema": {
                "filename": "file"
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "Imported"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "gateway"
        ]
      }
    },
    "/listeners/{id}": {
      "delete": {
        "description": "Delete the specified listener on all nodes.",
        "parameters": [
          {
            "$ref": "#/components/parameters/listeners.listener_id"
          }
        ],
        "responses": {
          "204": {
            "description": "Listener deleted"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Error code to troubleshoot problems.",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "listeners"
        ]
      },
      "get": {
        "description": "List all running node's listeners for the specified id.",
        "parameters": [
          {
            "$ref": "#/components/parameters/listeners.listener_id"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": {
                  "acceptors": 16,
                  "access_rules": [
                    "allow all"
                  ],
                  "bind": "0.0.0.0:1884",
                  "current_connections": 10240,
                  "id": "tcp:demo",
                  "max_connections": 204800,
                  "mountpoint": "/",
                  "proxy_protocol": false,
                  "proxy_protocol_timeout": "3s",
                  "running": true,
                  "tcp_options": {
                    "active_n": 100,
                    "backlog": 1024,
                    "buffer": "4KB",
                    "high_watermark": "1MB",
                    "nodelay": false,
                    "reuseaddr": true,
                    "send_timeout": "15s",
                    "send_timeout_close": true
                  },
                  "type": "tcp",
                  "zone": "default"
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/listeners.quic_required_bind"
                    },
                    {
                      "$ref": "#/components/schemas/listeners.wss_required_bind"
                    },
                    {
                      "$ref": "#/components/schemas/listeners.ws_required_bind"
                    },
                    {
                      "$ref": "#/components/schemas/listeners.ssl_required_bind"
                    },
                    {
                      "$ref": "#/components/schemas/listeners.tcp_required_bind"
                    }
                  ]
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_LISTENER_ID",
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Listener id not found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "listeners"
        ]
      },
      "post": {
        "description": "Create the specified listener on all nodes.",
        "parameters": [
          {
            "$ref": "#/components/parameters/listeners.listener_id"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "example": {
                "acceptors": 16,
                "access_rules": [
                  "allow all"
                ],
                "bind": "0.0.0.0:1884",
                "current_connections": 10240,
                "id": "tcp:demo",
                "max_connections": 204800,
                "mountpoint": "/",
                "proxy_protocol": false,
                "proxy_protocol_timeout": "3s",
                "running": true,
                "tcp_options": {
                  "active_n": 100,
                  "backlog": 1024,
                  "buffer": "4KB",
                  "high_watermark": "1MB",
                  "nodelay": false,
                  "reuseaddr": true,
                  "send_timeout": "15s",
                  "send_timeout_close": true
                },
                "type": "tcp",
                "zone": "default"
              },
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/listeners.quic_required_bind"
                  },
                  {
                    "$ref": "#/components/schemas/listeners.wss_required_bind"
                  },
                  {
                    "$ref": "#/components/schemas/listeners.ws_required_bind"
                  },
                  {
                    "$ref": "#/components/schemas/listeners.ssl_required_bind"
                  },
                  {
                    "$ref": "#/components/schemas/listeners.tcp_required_bind"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": {
                  "acceptors": 16,
                  "access_rules": [
                    "allow all"
                  ],
                  "bind": "0.0.0.0:1884",
                  "current_connections": 10240,
                  "id": "tcp:demo",
                  "max_connections": 204800,
                  "mountpoint": "/",
                  "proxy_protocol": false,
                  "proxy_protocol_timeout": "3s",
                  "running": true,
                  "tcp_options": {
                    "active_n": 100,
                    "backlog": 1024,
                    "buffer": "4KB",
                    "high_watermark": "1MB",
                    "nodelay": false,
                    "reuseaddr": true,
                    "send_timeout": "15s",
                    "send_timeout_close": true
                  },
                  "type": "tcp",
                  "zone": "default"
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/listeners.quic_required_bind"
                    },
                    {
                      "$ref": "#/components/schemas/listeners.wss_required_bind"
                    },
                    {
                      "$ref": "#/components/schemas/listeners.ws_required_bind"
                    },
                    {
                      "$ref": "#/components/schemas/listeners.ssl_required_bind"
                    },
                    {
                      "$ref": "#/components/schemas/listeners.tcp_required_bind"
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_LISTENER_ID",
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Error code to troubleshoot problems.",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "listeners"
        ]
      },
      "put": {
        "description": "Update the specified listener on all nodes.",
        "parameters": [
          {
            "$ref": "#/components/parameters/listeners.listener_id"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "example": {
                "acceptors": 16,
                "access_rules": [
                  "allow all"
                ],
                "bind": "0.0.0.0:1884",
                "current_connections": 10240,
                "id": "tcp:demo",
                "max_connections": 204800,
                "mountpoint": "/",
                "proxy_protocol": false,
                "proxy_protocol_timeout": "3s",
                "running": true,
                "tcp_options": {
                  "active_n": 100,
                  "backlog": 1024,
                  "buffer": "4KB",
                  "high_watermark": "1MB",
                  "nodelay": false,
                  "reuseaddr": true,
                  "send_timeout": "15s",
                  "send_timeout_close": true
                },
                "type": "tcp",
                "zone": "default"
              },
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/listeners.quic_not_required_bind"
                  },
                  {
                    "$ref": "#/components/schemas/listeners.wss_not_required_bind"
                  },
                  {
                    "$ref": "#/components/schemas/listeners.ws_not_required_bind"
                  },
                  {
                    "$ref": "#/components/schemas/listeners.ssl_not_required_bind"
                  },
                  {
                    "$ref": "#/components/schemas/listeners.tcp_not_required_bind"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": {
                  "acceptors": 16,
                  "access_rules": [
                    "allow all"
                  ],
                  "bind": "0.0.0.0:1884",
                  "current_connections": 10240,
                  "id": "tcp:demo",
                  "max_connections": 204800,
                  "mountpoint": "/",
                  "proxy_protocol": false,
                  "proxy_protocol_timeout": "3s",
                  "running": true,
                  "tcp_options": {
                    "active_n": 100,
                    "backlog": 1024,
                    "buffer": "4KB",
                    "high_watermark": "1MB",
                    "nodelay": false,
                    "reuseaddr": true,
                    "send_timeout": "15s",
                    "send_timeout_close": true
                  },
                  "type": "tcp",
                  "zone": "default"
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/listeners.quic_required_bind"
                    },
                    {
                      "$ref": "#/components/schemas/listeners.wss_required_bind"
                    },
                    {
                      "$ref": "#/components/schemas/listeners.ws_required_bind"
                    },
                    {
                      "$ref": "#/components/schemas/listeners.ssl_required_bind"
                    },
                    {
                      "$ref": "#/components/schemas/listeners.tcp_required_bind"
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Error code to troubleshoot problems.",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_LISTENER_ID",
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Listener id not found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "listeners"
        ]
      }
    },
    "/users/{username}/change_pwd": {
      "put": {
        "description": "Change dashboard user password",
        "parameters": [
          {
            "description": "Dashboard Username",
            "example": "admin",
            "in": "path",
            "maxLength": 100,
            "name": "username",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "old_pwd": {
                    "description": "Old password",
                    "type": "string"
                  },
                  "new_pwd": {
                    "description": "New password",
                    "type": "string"
                  }
                },
                "type": "object"
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "Update user password successfully"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST",
                        "ERROR_PWD_NOT_MATCH"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Login failed. Bad username or password",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "USER_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Dashboard user not found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "dashboard"
        ]
      }
    },
    "/authorization/settings": {
      "get": {
        "description": "Get authorization settings",
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "required": [
                    "deny_action",
                    "no_match"
                  ],
                  "properties": {
                    "no_match": {
                      "default": "allow",
                      "description": "</br>Default access control action if the user or client matches no ACL rules,</br>or if no such user or client is found by the configurable authorization</br>sources such as built_in_database, an HTTP API, or a query against PostgreSQL.</br>Find more details in 'authorization.sources' config.</br>",
                      "enum": [
                        "allow",
                        "deny"
                      ],
                      "type": "string"
                    },
                    "deny_action": {
                      "default": "ignore",
                      "description": "</br>The action when the authorization check rejects an operation.</br>",
                      "enum": [
                        "ignore",
                        "disconnect"
                      ],
                      "type": "string"
                    },
                    "cache": {
                      "$ref": "#/components/schemas/broker.cache"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "authorization"
        ]
      },
      "put": {
        "description": "Update authorization settings",
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "required": [
                  "deny_action",
                  "no_match"
                ],
                "properties": {
                  "no_match": {
                    "default": "allow",
                    "description": "</br>Default access control action if the user or client matches no ACL rules,</br>or if no such user or client is found by the configurable authorization</br>sources such as built_in_database, an HTTP API, or a query against PostgreSQL.</br>Find more details in 'authorization.sources' config.</br>",
                    "enum": [
                      "allow",
                      "deny"
                    ],
                    "type": "string"
                  },
                  "deny_action": {
                    "default": "ignore",
                    "description": "</br>The action when the authorization check rejects an operation.</br>",
                    "enum": [
                      "ignore",
                      "disconnect"
                    ],
                    "type": "string"
                  },
                  "cache": {
                    "$ref": "#/components/schemas/broker.cache"
                  }
                },
                "type": "object"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "required": [
                    "deny_action",
                    "no_match"
                  ],
                  "properties": {
                    "no_match": {
                      "default": "allow",
                      "description": "</br>Default access control action if the user or client matches no ACL rules,</br>or if no such user or client is found by the configurable authorization</br>sources such as built_in_database, an HTTP API, or a query against PostgreSQL.</br>Find more details in 'authorization.sources' config.</br>",
                      "enum": [
                        "allow",
                        "deny"
                      ],
                      "type": "string"
                    },
                    "deny_action": {
                      "default": "ignore",
                      "description": "</br>The action when the authorization check rejects an operation.</br>",
                      "enum": [
                        "ignore",
                        "disconnect"
                      ],
                      "type": "string"
                    },
                    "cache": {
                      "$ref": "#/components/schemas/broker.cache"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad Request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "authorization"
        ]
      }
    },
    "/configs/log": {
      "get": {
        "description": "Get the sub-configurations under *log*",
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx_conf_schema.log"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "config not found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "conf"
        ]
      },
      "put": {
        "description": "Update the sub-configurations under *log*",
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/emqx_conf_schema.log"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx_conf_schema.log"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "UPDATE_FAILED"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Error code to troubleshoot problems.",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "conf"
        ]
      }
    },
    "/rules/{id}": {
      "delete": {
        "description": "Delete a rule by given Id from all nodes in the cluster",
        "parameters": [
          {
            "example": "my_rule_id",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Delete rule successfully"
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "summary": "Delete a Rule",
        "tags": [
          "rules"
        ]
      },
      "get": {
        "description": "Get a rule by given Id",
        "parameters": [
          {
            "example": "my_rule_id",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx_rule_api_schema.rule_info"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Rule not found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "summary": "Get a Rule",
        "tags": [
          "rules"
        ]
      },
      "put": {
        "description": "Update a rule by given Id to all nodes in the cluster",
        "parameters": [
          {
            "example": "my_rule_id",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/emqx_rule_api_schema.rule_creation"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx_rule_api_schema.rule_info"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Invalid Parameters",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "summary": "Update a Rule",
        "tags": [
          "rules"
        ]
      }
    },
    "/exhooks/{name}/hooks": {
      "get": {
        "description": "Get the hooks information of server",
        "parameters": [
          {
            "description": "The Exhook server name",
            "example": "default",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/exhook.list_hook_info"
                  },
                  "type": "array"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad Request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "exhooks"
        ]
      }
    },
    "/bridges": {
      "get": {
        "description": "List all created bridges",
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": [
                  {
                    "connector": "mqtt:my_mqtt_connector",
                    "direction": "egress",
                    "enable": true,
                    "local_topic": "emqx/#",
                    "metrics": {
                      "failed": 0,
                      "matched": 0,
                      "rate": 0,
                      "rate_last5m": 0,
                      "rate_max": 0,
                      "success": 0
                    },
                    "name": "my_egress_mqtt_bridge",
                    "node_metrics": [
                      {
                        "metrics": {
                          "failed": 0,
                          "matched": 0,
                          "rate": 0,
                          "rate_last5m": 0,
                          "rate_max": 0,
                          "success": 0
                        },
                        "node": "emqx@127.0.0.1"
                      }
                    ],
                    "payload": "${payload}",
                    "remote_qos": "${qos}",
                    "remote_topic": "from_emqx/${topic}",
                    "retain": false,
                    "type": "mqtt"
                  },
                  {
                    "connector": "mqtt:my_mqtt_connector",
                    "direction": "ingress",
                    "enable": true,
                    "local_qos": "${qos}",
                    "local_topic": "from_aws/${topic}",
                    "metrics": {
                      "failed": 0,
                      "matched": 0,
                      "rate": 0,
                      "rate_last5m": 0,
                      "rate_max": 0,
                      "success": 0
                    },
                    "name": "my_ingress_mqtt_bridge",
                    "node_metrics": [
                      {
                        "metrics": {
                          "failed": 0,
                          "matched": 0,
                          "rate": 0,
                          "rate_last5m": 0,
                          "rate_max": 0,
                          "success": 0
                        },
                        "node": "emqx@127.0.0.1"
                      }
                    ],
                    "payload": "${payload}",
                    "remote_qos": 1,
                    "remote_topic": "aws/#",
                    "retain": "${retain}",
                    "type": "mqtt"
                  },
                  {
                    "body": "${payload}",
                    "connect_timeout": "15s",
                    "enable": true,
                    "enable_pipelining": 100,
                    "local_topic": "emqx_webhook/#",
                    "max_retries": 3,
                    "method": "post",
                    "metrics": {
                      "failed": 0,
                      "matched": 0,
                      "rate": 0,
                      "rate_last5m": 0,
                      "rate_max": 0,
                      "success": 0
                    },
                    "name": "my_webhook",
                    "node_metrics": [
                      {
                        "metrics": {
                          "failed": 0,
                          "matched": 0,
                          "rate": 0,
                          "rate_last5m": 0,
                          "rate_max": 0,
                          "success": 0
                        },
                        "node": "emqx@127.0.0.1"
                      }
                    ],
                    "pool_size": 4,
                    "pool_type": "random",
                    "request_timeout": "15s",
                    "retry_interval": "10s",
                    "ssl": {
                      "enable": false
                    },
                    "type": "webhook",
                    "url": "http://localhost:9901/messages/${topic}"
                  }
                ],
                "schema": {
                  "items": {
                    "oneOf": [
                      {
                        "$ref": "#/components/schemas/emqx_bridge_mqtt_schema.get_egress"
                      },
                      {
                        "$ref": "#/components/schemas/emqx_bridge_mqtt_schema.get_ingress"
                      },
                      {
                        "$ref": "#/components/schemas/bridge.get"
                      }
                    ]
                  },
                  "type": "array"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "summary": "List Bridges",
        "tags": [
          "bridges"
        ]
      },
      "post": {
        "description": "Create a new bridge by type and name",
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "mqtt_egress": {
                  "summary": "MQTT Egress Bridge",
                  "value": {
                    "connector": "mqtt:my_mqtt_connector",
                    "direction": "egress",
                    "enable": true,
                    "local_topic": "emqx/#",
                    "name": "my_egress_mqtt_bridge",
                    "payload": "${payload}",
                    "remote_qos": "${qos}",
                    "remote_topic": "from_emqx/${topic}",
                    "retain": false,
                    "type": "mqtt"
                  }
                },
                "mqtt_ingress": {
                  "summary": "MQTT Ingress Bridge",
                  "value": {
                    "connector": "mqtt:my_mqtt_connector",
                    "direction": "ingress",
                    "enable": true,
                    "local_qos": "${qos}",
                    "local_topic": "from_aws/${topic}",
                    "name": "my_ingress_mqtt_bridge",
                    "payload": "${payload}",
                    "remote_qos": 1,
                    "remote_topic": "aws/#",
                    "retain": "${retain}",
                    "type": "mqtt"
                  }
                },
                "my_webhook": {
                  "summary": "WebHook",
                  "value": {
                    "body": "${payload}",
                    "connect_timeout": "15s",
                    "enable": true,
                    "enable_pipelining": 100,
                    "local_topic": "emqx_webhook/#",
                    "max_retries": 3,
                    "method": "post",
                    "name": "my_webhook",
                    "pool_size": 4,
                    "pool_type": "random",
                    "request_timeout": "15s",
                    "retry_interval": "10s",
                    "ssl": {
                      "enable": false
                    },
                    "type": "webhook",
                    "url": "http://localhost:9901/messages/${topic}"
                  }
                }
              },
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/emqx_bridge_mqtt_schema.post_egress"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_bridge_mqtt_schema.post_ingress"
                  },
                  {
                    "$ref": "#/components/schemas/bridge.post"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "mqtt_egress": {
                    "summary": "MQTT Egress Bridge",
                    "value": {
                      "connector": "mqtt:my_mqtt_connector",
                      "direction": "egress",
                      "enable": true,
                      "local_topic": "emqx/#",
                      "metrics": {
                        "failed": 0,
                        "matched": 0,
                        "rate": 0,
                        "rate_last5m": 0,
                        "rate_max": 0,
                        "success": 0
                      },
                      "name": "my_egress_mqtt_bridge",
                      "node_metrics": [
                        {
                          "metrics": {
                            "failed": 0,
                            "matched": 0,
                            "rate": 0,
                            "rate_last5m": 0,
                            "rate_max": 0,
                            "success": 0
                          },
                          "node": "emqx@127.0.0.1"
                        }
                      ],
                      "payload": "${payload}",
                      "remote_qos": "${qos}",
                      "remote_topic": "from_emqx/${topic}",
                      "retain": false,
                      "type": "mqtt"
                    }
                  },
                  "mqtt_ingress": {
                    "summary": "MQTT Ingress Bridge",
                    "value": {
                      "connector": "mqtt:my_mqtt_connector",
                      "direction": "ingress",
                      "enable": true,
                      "local_qos": "${qos}",
                      "local_topic": "from_aws/${topic}",
                      "metrics": {
                        "failed": 0,
                        "matched": 0,
                        "rate": 0,
                        "rate_last5m": 0,
                        "rate_max": 0,
                        "success": 0
                      },
                      "name": "my_ingress_mqtt_bridge",
                      "node_metrics": [
                        {
                          "metrics": {
                            "failed": 0,
                            "matched": 0,
                            "rate": 0,
                            "rate_last5m": 0,
                            "rate_max": 0,
                            "success": 0
                          },
                          "node": "emqx@127.0.0.1"
                        }
                      ],
                      "payload": "${payload}",
                      "remote_qos": 1,
                      "remote_topic": "aws/#",
                      "retain": "${retain}",
                      "type": "mqtt"
                    }
                  },
                  "my_webhook": {
                    "summary": "WebHook",
                    "value": {
                      "body": "${payload}",
                      "connect_timeout": "15s",
                      "enable": true,
                      "enable_pipelining": 100,
                      "local_topic": "emqx_webhook/#",
                      "max_retries": 3,
                      "method": "post",
                      "metrics": {
                        "failed": 0,
                        "matched": 0,
                        "rate": 0,
                        "rate_last5m": 0,
                        "rate_max": 0,
                        "success": 0
                      },
                      "name": "my_webhook",
                      "node_metrics": [
                        {
                          "metrics": {
                            "failed": 0,
                            "matched": 0,
                            "rate": 0,
                            "rate_last5m": 0,
                            "rate_max": 0,
                            "success": 0
                          },
                          "node": "emqx@127.0.0.1"
                        }
                      ],
                      "pool_size": 4,
                      "pool_type": "random",
                      "request_timeout": "15s",
                      "retry_interval": "10s",
                      "ssl": {
                        "enable": false
                      },
                      "type": "webhook",
                      "url": "http://localhost:9901/messages/${topic}"
                    }
                  }
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/emqx_bridge_mqtt_schema.get_egress"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_bridge_mqtt_schema.get_ingress"
                    },
                    {
                      "$ref": "#/components/schemas/bridge.get"
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "ALREADY_EXISTS"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bridge already exists",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "summary": "Create Bridge",
        "tags": [
          "bridges"
        ]
      }
    },
    "/authorization/sources/built_in_database/username/{username}": {
      "delete": {
        "description": "Delete one record for username",
        "parameters": [
          {
            "$ref": "#/components/parameters/emqx_authz_api_mnesia.username"
          }
        ],
        "responses": {
          "204": {
            "description": "Deleted"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad username",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Username Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "authorization"
        ]
      },
      "get": {
        "description": "Get record info for username",
        "parameters": [
          {
            "$ref": "#/components/parameters/emqx_authz_api_mnesia.username"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "password_based:built_in_database": {
                    "summary": "Username",
                    "value": {
                      "rules": [
                        {
                          "action": "publish",
                          "permission": "allow",
                          "topic": "test/toopic/1"
                        },
                        {
                          "action": "subscribe",
                          "permission": "allow",
                          "topic": "test/toopic/2"
                        },
                        {
                          "action": "all",
                          "permission": "deny",
                          "topic": "eq test/#"
                        }
                      ],
                      "username": "user1"
                    }
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/emqx_authz_api_mnesia.rules_for_username"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "authorization"
        ]
      },
      "put": {
        "description": "Set record for username",
        "parameters": [
          {
            "$ref": "#/components/parameters/emqx_authz_api_mnesia.username"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "password_based:built_in_database": {
                  "summary": "Username",
                  "value": {
                    "rules": [
                      {
                        "action": "publish",
                        "permission": "allow",
                        "topic": "test/toopic/1"
                      },
                      {
                        "action": "subscribe",
                        "permission": "allow",
                        "topic": "test/toopic/2"
                      },
                      {
                        "action": "all",
                        "permission": "deny",
                        "topic": "eq test/#"
                      }
                    ],
                    "username": "user1"
                  }
                }
              },
              "schema": {
                "$ref": "#/components/schemas/emqx_authz_api_mnesia.rules_for_username"
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "Updated"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad username or bad rule schema",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "authorization"
        ]
      }
    },
    "/gateway/{name}/listeners/{id}": {
      "delete": {
        "description": "Delete the gateway listener",
        "parameters": [
          {
            "description": "Gateway Name",
            "example": "",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Listener ID",
            "example": "",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Deleted"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "gateway"
        ]
      },
      "get": {
        "description": "Get the gateway listener configurations",
        "parameters": [
          {
            "description": "Gateway Name",
            "example": "",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Listener ID",
            "example": "",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "dtls_listener": {
                    "summary": "A simple dtls listener example",
                    "value": {
                      "acceptors": 16,
                      "access_rules": [
                        "allow all"
                      ],
                      "bind": "22213",
                      "dtls_options": {
                        "cacertfile": "/mnt/code/src/emqx/0/_build/emqx/rel/emqx/etc/certs/cacert.pem",
                        "certfile": "/mnt/code/src/emqx/0/_build/emqx/rel/emqx/etc/certs/cert.pem",
                        "fail_if_no_peer_cert": false,
                        "keyfile": "/mnt/code/src/emqx/0/_build/emqx/rel/emqx/etc/certs/key.pem",
                        "verify": "verify_none",
                        "versions": [
                          "dtlsv1.2",
                          "dtlsv1"
                        ]
                      },
                      "max_conn_rate": 1000,
                      "max_connections": 1024000,
                      "name": "dtls-def",
                      "type": "dtls",
                      "udp_options": {
                        "active_n": 100,
                        "backlog": 1024
                      }
                    }
                  },
                  "dtls_listener_with_psk_ciphers": {
                    "summary": "A dtls listener with PSK example",
                    "value": {
                      "acceptors": 16,
                      "bind": "22214",
                      "dtls_options": {
                        "cacertfile": "/mnt/code/src/emqx/0/_build/emqx/rel/emqx/etc/certs/cacert.pem",
                        "certfile": "/mnt/code/src/emqx/0/_build/emqx/rel/emqx/etc/certs/cert.pem",
                        "ciphers": "RSA-PSK-AES256-GCM-SHA384,RSA-PSK-AES256-CBC-SHA384,RSA-PSK-AES128-GCM-SHA256,RSA-PSK-AES128-CBC-SHA256,RSA-PSK-AES256-CBC-SHA,RSA-PSK-AES128-CBC-SHA",
                        "fail_if_no_peer_cert": false,
                        "keyfile": "/mnt/code/src/emqx/0/_build/emqx/rel/emqx/etc/certs/key.pem",
                        "user_lookup_fun": "emqx_tls_psk:lookup",
                        "verify": "verify_none",
                        "versions": [
                          "dtlsv1.2",
                          "dtlsv1"
                        ]
                      },
                      "max_conn_rate": 1000,
                      "max_connections": 1024000,
                      "name": "dtls-psk",
                      "type": "dtls"
                    }
                  },
                  "lisetner_with_authn": {
                    "summary": "A tcp listener with authentication example",
                    "value": {
                      "acceptors": 16,
                      "authentication": {
                        "backend": "built_in_database",
                        "mechanism": "password_based",
                        "password_hash_algorithm": {
                          "name": "sha256"
                        },
                        "user_id_type": "username"
                      },
                      "bind": "22215",
                      "max_conn_rate": 1000,
                      "max_connections": 1024000,
                      "name": "tcp-with-authn",
                      "type": "tcp"
                    }
                  },
                  "ssl_listener": {
                    "summary": "A simple ssl listener example",
                    "value": {
                      "acceptors": 16,
                      "access_rules": [
                        "allow all"
                      ],
                      "bind": "22211",
                      "max_conn_rate": 1000,
                      "max_connections": 1024000,
                      "name": "ssl-def",
                      "ssl_options": {
                        "cacertfile": "/mnt/code/src/emqx/0/_build/emqx/rel/emqx/etc/certs/cacert.pem",
                        "certfile": "/mnt/code/src/emqx/0/_build/emqx/rel/emqx/etc/certs/cert.pem",
                        "fail_if_no_peer_cert": false,
                        "keyfile": "/mnt/code/src/emqx/0/_build/emqx/rel/emqx/etc/certs/key.pem",
                        "verify": "verify_none",
                        "versions": [
                          "tlsv1.3",
                          "tlsv1.2",
                          "tlsv1.1",
                          "tlsv1"
                        ]
                      },
                      "tcp_options": {
                        "active_n": 100,
                        "backlog": 1024
                      },
                      "type": "ssl"
                    }
                  },
                  "tcp_listener": {
                    "summary": "A simple tcp listener example",
                    "value": {
                      "acceptors": 16,
                      "bind": "22210",
                      "max_conn_rate": 1000,
                      "max_connections": 1024000,
                      "name": "tcp-def",
                      "tcp_options": {
                        "active_n": 100,
                        "backlog": 1024,
                        "buffer": "10KB",
                        "high_watermark": "1MB",
                        "nodelay": false,
                        "recbuf": "10KB",
                        "reuseaddr": true,
                        "send_timeout": "15s",
                        "send_timeout_close": true,
                        "sndbuf": "10KB"
                      },
                      "type": "tcp"
                    }
                  },
                  "udp_listener": {
                    "summary": "A simple udp listener example",
                    "value": {
                      "bind": "22212",
                      "name": "udp-def",
                      "type": "udp",
                      "udp_options": {
                        "active_n": 100,
                        "buffer": "10KB",
                        "recbuf": "10KB",
                        "reuseaddr": true,
                        "sndbuf": "10KB"
                      }
                    }
                  }
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api.dtls_listener"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api.udp_listener"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api.ssl_listener"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api.tcp_listener"
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "gateway"
        ]
      },
      "put": {
        "description": "Update the gateway listener",
        "parameters": [
          {
            "description": "Gateway Name",
            "example": "",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Listener ID",
            "example": "",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "dtls_listener": {
                  "summary": "A simple dtls listener example",
                  "value": {
                    "acceptors": 16,
                    "access_rules": [
                      "allow all"
                    ],
                    "bind": "22213",
                    "dtls_options": {
                      "cacertfile": "/mnt/code/src/emqx/0/_build/emqx/rel/emqx/etc/certs/cacert.pem",
                      "certfile": "/mnt/code/src/emqx/0/_build/emqx/rel/emqx/etc/certs/cert.pem",
                      "fail_if_no_peer_cert": false,
                      "keyfile": "/mnt/code/src/emqx/0/_build/emqx/rel/emqx/etc/certs/key.pem",
                      "verify": "verify_none",
                      "versions": [
                        "dtlsv1.2",
                        "dtlsv1"
                      ]
                    },
                    "max_conn_rate": 1000,
                    "max_connections": 1024000,
                    "name": "dtls-def",
                    "type": "dtls",
                    "udp_options": {
                      "active_n": 100,
                      "backlog": 1024
                    }
                  }
                },
                "dtls_listener_with_psk_ciphers": {
                  "summary": "A dtls listener with PSK example",
                  "value": {
                    "acceptors": 16,
                    "bind": "22214",
                    "dtls_options": {
                      "cacertfile": "/mnt/code/src/emqx/0/_build/emqx/rel/emqx/etc/certs/cacert.pem",
                      "certfile": "/mnt/code/src/emqx/0/_build/emqx/rel/emqx/etc/certs/cert.pem",
                      "ciphers": "RSA-PSK-AES256-GCM-SHA384,RSA-PSK-AES256-CBC-SHA384,RSA-PSK-AES128-GCM-SHA256,RSA-PSK-AES128-CBC-SHA256,RSA-PSK-AES256-CBC-SHA,RSA-PSK-AES128-CBC-SHA",
                      "fail_if_no_peer_cert": false,
                      "keyfile": "/mnt/code/src/emqx/0/_build/emqx/rel/emqx/etc/certs/key.pem",
                      "user_lookup_fun": "emqx_tls_psk:lookup",
                      "verify": "verify_none",
                      "versions": [
                        "dtlsv1.2",
                        "dtlsv1"
                      ]
                    },
                    "max_conn_rate": 1000,
                    "max_connections": 1024000,
                    "name": "dtls-psk",
                    "type": "dtls"
                  }
                },
                "lisetner_with_authn": {
                  "summary": "A tcp listener with authentication example",
                  "value": {
                    "acceptors": 16,
                    "authentication": {
                      "backend": "built_in_database",
                      "mechanism": "password_based",
                      "password_hash_algorithm": {
                        "name": "sha256"
                      },
                      "user_id_type": "username"
                    },
                    "bind": "22215",
                    "max_conn_rate": 1000,
                    "max_connections": 1024000,
                    "name": "tcp-with-authn",
                    "type": "tcp"
                  }
                },
                "ssl_listener": {
                  "summary": "A simple ssl listener example",
                  "value": {
                    "acceptors": 16,
                    "access_rules": [
                      "allow all"
                    ],
                    "bind": "22211",
                    "max_conn_rate": 1000,
                    "max_connections": 1024000,
                    "name": "ssl-def",
                    "ssl_options": {
                      "cacertfile": "/mnt/code/src/emqx/0/_build/emqx/rel/emqx/etc/certs/cacert.pem",
                      "certfile": "/mnt/code/src/emqx/0/_build/emqx/rel/emqx/etc/certs/cert.pem",
                      "fail_if_no_peer_cert": false,
                      "keyfile": "/mnt/code/src/emqx/0/_build/emqx/rel/emqx/etc/certs/key.pem",
                      "verify": "verify_none",
                      "versions": [
                        "tlsv1.3",
                        "tlsv1.2",
                        "tlsv1.1",
                        "tlsv1"
                      ]
                    },
                    "tcp_options": {
                      "active_n": 100,
                      "backlog": 1024
                    },
                    "type": "ssl"
                  }
                },
                "tcp_listener": {
                  "summary": "A simple tcp listener example",
                  "value": {
                    "acceptors": 16,
                    "bind": "22210",
                    "max_conn_rate": 1000,
                    "max_connections": 1024000,
                    "name": "tcp-def",
                    "tcp_options": {
                      "active_n": 100,
                      "backlog": 1024,
                      "buffer": "10KB",
                      "high_watermark": "1MB",
                      "nodelay": false,
                      "recbuf": "10KB",
                      "reuseaddr": true,
                      "send_timeout": "15s",
                      "send_timeout_close": true,
                      "sndbuf": "10KB"
                    },
                    "type": "tcp"
                  }
                },
                "udp_listener": {
                  "summary": "A simple udp listener example",
                  "value": {
                    "bind": "22212",
                    "name": "udp-def",
                    "type": "udp",
                    "udp_options": {
                      "active_n": 100,
                      "buffer": "10KB",
                      "recbuf": "10KB",
                      "reuseaddr": true,
                      "sndbuf": "10KB"
                    }
                  }
                }
              },
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/emqx_gateway_api.dtls_listener"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_gateway_api.udp_listener"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_gateway_api.ssl_listener"
                  },
                  {
                    "$ref": "#/components/schemas/emqx_gateway_api.tcp_listener"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "dtls_listener": {
                    "summary": "A simple dtls listener example",
                    "value": {
                      "acceptors": 16,
                      "access_rules": [
                        "allow all"
                      ],
                      "bind": "22213",
                      "dtls_options": {
                        "cacertfile": "/mnt/code/src/emqx/0/_build/emqx/rel/emqx/etc/certs/cacert.pem",
                        "certfile": "/mnt/code/src/emqx/0/_build/emqx/rel/emqx/etc/certs/cert.pem",
                        "fail_if_no_peer_cert": false,
                        "keyfile": "/mnt/code/src/emqx/0/_build/emqx/rel/emqx/etc/certs/key.pem",
                        "verify": "verify_none",
                        "versions": [
                          "dtlsv1.2",
                          "dtlsv1"
                        ]
                      },
                      "max_conn_rate": 1000,
                      "max_connections": 1024000,
                      "name": "dtls-def",
                      "type": "dtls",
                      "udp_options": {
                        "active_n": 100,
                        "backlog": 1024
                      }
                    }
                  },
                  "dtls_listener_with_psk_ciphers": {
                    "summary": "A dtls listener with PSK example",
                    "value": {
                      "acceptors": 16,
                      "bind": "22214",
                      "dtls_options": {
                        "cacertfile": "/mnt/code/src/emqx/0/_build/emqx/rel/emqx/etc/certs/cacert.pem",
                        "certfile": "/mnt/code/src/emqx/0/_build/emqx/rel/emqx/etc/certs/cert.pem",
                        "ciphers": "RSA-PSK-AES256-GCM-SHA384,RSA-PSK-AES256-CBC-SHA384,RSA-PSK-AES128-GCM-SHA256,RSA-PSK-AES128-CBC-SHA256,RSA-PSK-AES256-CBC-SHA,RSA-PSK-AES128-CBC-SHA",
                        "fail_if_no_peer_cert": false,
                        "keyfile": "/mnt/code/src/emqx/0/_build/emqx/rel/emqx/etc/certs/key.pem",
                        "user_lookup_fun": "emqx_tls_psk:lookup",
                        "verify": "verify_none",
                        "versions": [
                          "dtlsv1.2",
                          "dtlsv1"
                        ]
                      },
                      "max_conn_rate": 1000,
                      "max_connections": 1024000,
                      "name": "dtls-psk",
                      "type": "dtls"
                    }
                  },
                  "lisetner_with_authn": {
                    "summary": "A tcp listener with authentication example",
                    "value": {
                      "acceptors": 16,
                      "authentication": {
                        "backend": "built_in_database",
                        "mechanism": "password_based",
                        "password_hash_algorithm": {
                          "name": "sha256"
                        },
                        "user_id_type": "username"
                      },
                      "bind": "22215",
                      "max_conn_rate": 1000,
                      "max_connections": 1024000,
                      "name": "tcp-with-authn",
                      "type": "tcp"
                    }
                  },
                  "ssl_listener": {
                    "summary": "A simple ssl listener example",
                    "value": {
                      "acceptors": 16,
                      "access_rules": [
                        "allow all"
                      ],
                      "bind": "22211",
                      "max_conn_rate": 1000,
                      "max_connections": 1024000,
                      "name": "ssl-def",
                      "ssl_options": {
                        "cacertfile": "/mnt/code/src/emqx/0/_build/emqx/rel/emqx/etc/certs/cacert.pem",
                        "certfile": "/mnt/code/src/emqx/0/_build/emqx/rel/emqx/etc/certs/cert.pem",
                        "fail_if_no_peer_cert": false,
                        "keyfile": "/mnt/code/src/emqx/0/_build/emqx/rel/emqx/etc/certs/key.pem",
                        "verify": "verify_none",
                        "versions": [
                          "tlsv1.3",
                          "tlsv1.2",
                          "tlsv1.1",
                          "tlsv1"
                        ]
                      },
                      "tcp_options": {
                        "active_n": 100,
                        "backlog": 1024
                      },
                      "type": "ssl"
                    }
                  },
                  "tcp_listener": {
                    "summary": "A simple tcp listener example",
                    "value": {
                      "acceptors": 16,
                      "bind": "22210",
                      "max_conn_rate": 1000,
                      "max_connections": 1024000,
                      "name": "tcp-def",
                      "tcp_options": {
                        "active_n": 100,
                        "backlog": 1024,
                        "buffer": "10KB",
                        "high_watermark": "1MB",
                        "nodelay": false,
                        "recbuf": "10KB",
                        "reuseaddr": true,
                        "send_timeout": "15s",
                        "send_timeout_close": true,
                        "sndbuf": "10KB"
                      },
                      "type": "tcp"
                    }
                  },
                  "udp_listener": {
                    "summary": "A simple udp listener example",
                    "value": {
                      "bind": "22212",
                      "name": "udp-def",
                      "type": "udp",
                      "udp_options": {
                        "active_n": 100,
                        "buffer": "10KB",
                        "recbuf": "10KB",
                        "reuseaddr": true,
                        "sndbuf": "10KB"
                      }
                    }
                  }
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api.dtls_listener"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api.udp_listener"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api.ssl_listener"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api.tcp_listener"
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "gateway"
        ]
      }
    },
    "/gateway/coap/clients/{clientid}/request": {
      "post": {
        "description": "Send a CoAP request message to the client",
        "parameters": [
          {
            "in": "path",
            "name": "clientid",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "token": {
                    "description": "Message token, can be empty",
                    "type": "string"
                  },
                  "method": {
                    "description": "Request method type",
                    "enum": [
                      "get",
                      "put",
                      "post",
                      "delete"
                    ],
                    "type": "string"
                  },
                  "timeout": {
                    "description": "Timespan for response",
                    "example": "32s",
                    "type": "string"
                  },
                  "content_type": {
                    "description": "Payload type",
                    "enum": [
                      "text/plain",
                      "application/json",
                      "application/octet-stream"
                    ],
                    "type": "string"
                  },
                  "payload": {
                    "description": "The content of the payload",
                    "type": "string"
                  }
                },
                "type": "object"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "id": {
                      "description": "Message ID",
                      "type": "integer"
                    },
                    "token": {
                      "description": "Message token, can be empty",
                      "type": "string"
                    },
                    "method": {
                      "description": "Response code",
                      "type": "string"
                    },
                    "payload": {
                      "description": "The content of the payload",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "CLIENT_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Client not found error",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "504": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "CLIENT_NOT_RESPONSE"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Waiting for client response timeout",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "gateway|coap"
        ]
      }
    },
    "/gateway/{name}/clients/{clientid}": {
      "delete": {
        "description": "Kick out the gateway client",
        "parameters": [
          {
            "description": "Client ID",
            "in": "path",
            "name": "clientid",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Gateway Name",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Kicked"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "gateway"
        ]
      },
      "get": {
        "description": "Get the gateway client information",
        "parameters": [
          {
            "description": "Client ID",
            "in": "path",
            "name": "clientid",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Gateway Name",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "general_client": {
                    "summary": "General Client Info",
                    "value": {
                      "mqueue_len": 0,
                      "send_oct": 61,
                      "ip_address": "127.0.0.1",
                      "recv_cnt": 1,
                      "connected_at": "2021-12-07T10:44:02.721+08:00",
                      "expiry_interval": 0,
                      "connected": true,
                      "disconnected_at": null,
                      "mqueue_dropped": 0,
                      "keepalive": 0,
                      "clean_start": true,
                      "created_at": "2021-12-07T10:44:02.721+08:00",
                      "send_msg": 0,
                      "reductions": 72022,
                      "subscriptions_max": "infinity",
                      "send_pkt": 1,
                      "inflight_max": "infinity",
                      "recv_msg": 0,
                      "mqueue_max": "infinity",
                      "inflight_cnt": 0,
                      "mailbox_len": 0,
                      "recv_oct": 56,
                      "clientid": "MzAyMzEzNTUwNzk1NDA1MzYyMzIwNzUxNjQwMTY1NzQ0NjE",
                      "recv_pkt": 1,
                      "proto_ver": "1.0",
                      "is_bridge": false,
                      "send_cnt": 1,
                      "proto_name": "STOMP",
                      "node": "emqx@127.0.0.1",
                      "username": "guest",
                      "heap_size": 4185,
                      "port": 50675,
                      "subscriptions_cnt": 0,
                      "awaiting_rel_cnt": 0,
                      "awaiting_rel_max": "infinity"
                    }
                  },
                  "lwm2m_client": {
                    "summary": "LwM2M Client Info",
                    "value": {
                      "mqueue_len": 0,
                      "send_oct": 61,
                      "ip_address": "127.0.0.1",
                      "recv_cnt": 1,
                      "connected_at": "2021-12-07T10:44:02.721+08:00",
                      "expiry_interval": 0,
                      "connected": true,
                      "disconnected_at": null,
                      "endpoint_name": "urn:imei:154928475237123",
                      "mqueue_dropped": 0,
                      "keepalive": 0,
                      "clean_start": true,
                      "created_at": "2021-12-07T10:44:02.721+08:00",
                      "send_msg": 0,
                      "reductions": 72022,
                      "subscriptions_max": "infinity",
                      "send_pkt": 1,
                      "inflight_max": "infinity",
                      "recv_msg": 0,
                      "lifetime": 86400,
                      "mqueue_max": "infinity",
                      "inflight_cnt": 0,
                      "mailbox_len": 0,
                      "recv_oct": 56,
                      "clientid": "MzAyMzEzNTUwNzk1NDA1MzYyMzIwNzUxNjQwMTY1NzQ0NjE",
                      "recv_pkt": 1,
                      "proto_ver": "1.0",
                      "is_bridge": false,
                      "send_cnt": 1,
                      "proto_name": "LwM2M",
                      "node": "emqx@127.0.0.1",
                      "username": "guest",
                      "heap_size": 4185,
                      "port": 50675,
                      "subscriptions_cnt": 0,
                      "awaiting_rel_cnt": 0,
                      "awaiting_rel_max": "infinity"
                    }
                  }
                },
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api_clients.exproto_client"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api_clients.lwm2m_client"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api_clients.coap_client"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api_clients.mqttsn_client"
                    },
                    {
                      "$ref": "#/components/schemas/emqx_gateway_api_clients.stomp_client"
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "gateway"
        ]
      }
    },
    "/listeners_status": {
      "get": {
        "description": "List all running node's listeners live status. group by listener type",
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": [
                  {
                    "enable": false,
                    "ids": [
                      "tcp:demo"
                    ],
                    "node_status": {
                      "emqx@127.0.0.1": {
                        "current_connections": 11,
                        "max_connections": 1024000
                      },
                      "emqx@127.0.0.2": {
                        "current_connections": 10,
                        "max_connections": 1024000
                      }
                    },
                    "status": {
                      "current_connections": 21,
                      "max_connections": 2048000
                    },
                    "type": "tcp"
                  },
                  {
                    "enable": false,
                    "ids": [
                      "ssl:default"
                    ],
                    "node_status": {
                      "emqx@127.0.0.1": {
                        "current_connections": 31,
                        "max_connections": "infinity"
                      },
                      "emqx@127.0.0.2": {
                        "current_connections": 40,
                        "max_connections": "infinity"
                      }
                    },
                    "status": {
                      "current_connections": 71,
                      "max_connections": "infinity"
                    },
                    "type": "ssl"
                  }
                ],
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/listeners.listener_type_status"
                  },
                  "type": "array"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "listeners"
        ]
      }
    },
    "/monitor": {
      "get": {
        "description": "List monitor data.",
        "parameters": [
          {
            "description": "The latest N seconds data. Like 300 for 5 min.",
            "example": 300,
            "in": "query",
            "name": "latest",
            "required": false,
            "schema": {
              "minimum": 1,
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/emqx_dashboard_monitor_api.sampler"
                  },
                  "type": "array"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_RPC"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad RPC",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "dashboard"
        ]
      }
    },
    "/gateway/{name}/listeners/{id}/authentication/users/{uid}": {
      "delete": {
        "description": "Delete the user for the gateway authentication",
        "parameters": [
          {
            "description": "Gateway Name",
            "example": "",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Listener ID",
            "example": "",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "User ID",
            "example": "",
            "in": "path",
            "name": "uid",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Deleted"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "gateway"
        ]
      },
      "get": {
        "description": "Get user info from the gateway authentication",
        "parameters": [
          {
            "description": "Gateway Name",
            "example": "",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Listener ID",
            "example": "",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "User ID",
            "example": "",
            "in": "path",
            "name": "uid",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": {
                  "regular_user": {
                    "summary": "Regular user",
                    "value": {
                      "user_id": "user1"
                    }
                  },
                  "super_user": {
                    "summary": "Superuser",
                    "value": {
                      "is_superuser": true,
                      "user_id": "user2"
                    }
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/emqx_authn_api.response_user"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "gateway"
        ]
      },
      "put": {
        "description": "Update the user info for the gateway authentication",
        "parameters": [
          {
            "description": "Gateway Name",
            "example": "",
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Listener ID",
            "example": "",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "User ID",
            "example": "",
            "in": "path",
            "name": "uid",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "regular_user": {
                  "summary": "Update regular user",
                  "value": {
                    "password": "newsecret"
                  }
                },
                "super_user": {
                  "summary": "Update user and promote to superuser",
                  "value": {
                    "is_superuser": true,
                    "password": "newsecret"
                  }
                }
              },
              "schema": {
                "$ref": "#/components/schemas/emqx_authn_api.request_user_update"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": {
                  "regular_user": {
                    "summary": "Regular user",
                    "value": {
                      "user_id": "user1"
                    }
                  },
                  "super_user": {
                    "summary": "Superuser",
                    "value": {
                      "is_superuser": true,
                      "user_id": "user2"
                    }
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/emqx_authn_api.response_user"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND",
                        "RESOURCE_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "gateway"
        ]
      }
    },
    "/logout": {
      "post": {
        "description": "Dashboard user logout",
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "username": {
                    "description": "Dashboard Username",
                    "example": "admin",
                    "maxLength": 100,
                    "type": "string"
                  }
                },
                "type": "object"
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "Dashboard logout successfully"
          },
          "401": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "WRONG_USERNAME_OR_PWD"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Login failed. Bad username or password",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "dashboard"
        ]
      }
    },
    "/listeners/{listener_id}/authentication/{id}/users": {
      "get": {
        "description": "List users in authenticator in listener authentication chain.",
        "parameters": [
          {
            "description": "Listener ID.",
            "example": "tcp:default",
            "in": "path",
            "name": "listener_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Authenticator ID.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "$ref": "#/components/parameters/public.page"
          },
          {
            "$ref": "#/components/parameters/public.limit"
          },
          {
            "description": "Is superuser",
            "in": "query",
            "name": "is_superuser",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "example": {
                  "data": [
                    {
                      "user_id": "user1"
                    },
                    {
                      "is_superuser": true,
                      "user_id": "user2"
                    }
                  ],
                  "meta": {
                    "count": 300,
                    "limit": 20,
                    "page": 0
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/emqx_authn_api.response_users"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "authentication",
          "authentication config(single listener)"
        ]
      },
      "post": {
        "description": "Create users for authenticator in listener authentication chain.",
        "parameters": [
          {
            "description": "Authenticator ID.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Listener ID.",
            "example": "tcp:default",
            "in": "path",
            "name": "listener_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "regular_user": {
                  "summary": "Regular user",
                  "value": {
                    "password": "secret",
                    "user_id": "user1"
                  }
                },
                "super_user": {
                  "summary": "Superuser",
                  "value": {
                    "is_superuser": true,
                    "password": "secret",
                    "user_id": "user2"
                  }
                }
              },
              "schema": {
                "$ref": "#/components/schemas/emqx_authn_api.request_user_create"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "examples": {
                  "regular_user": {
                    "summary": "Regular user",
                    "value": {
                      "user_id": "user1"
                    }
                  },
                  "super_user": {
                    "summary": "Superuser",
                    "value": {
                      "is_superuser": true,
                      "user_id": "user2"
                    }
                  }
                },
                "schema": {
                  "$ref": "#/components/schemas/emqx_authn_api.response_user"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad Request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "authentication",
          "authentication config(single listener)"
        ]
      }
    },
    "/listeners/{listener_id}/authentication/{id}/move": {
      "post": {
        "description": "Move authenticator in listener authentication chain.",
        "parameters": [
          {
            "description": "Listener ID.",
            "example": "tcp:default",
            "in": "path",
            "name": "listener_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Authenticator ID.",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "examples": {
                "move_before_password_based:built_in_database": {
                  "summary": "Move authenticator to the position preceding some other authenticator",
                  "value": {
                    "position": "before:password_based:built_in_database"
                  }
                },
                "move_to_front": {
                  "summary": "Move authenticator to the beginning of the chain",
                  "value": {
                    "position": "front"
                  }
                },
                "move_to_rear": {
                  "summary": "Move authenticator to the end of the chain",
                  "value": {
                    "position": "rear"
                  }
                }
              },
              "schema": {
                "$ref": "#/components/schemas/emqx_authn_api.request_move"
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "Authenticator moved"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Bad Request",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Not Found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "authentication",
          "authentication config(single listener)"
        ]
      }
    },
    "/rules/{id}/reset_metrics": {
      "put": {
        "description": "Reset a rule metrics",
        "parameters": [
          {
            "example": "my_rule_id",
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Reset Success"
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "BAD_REQUEST"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "RPC Call Failed",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "summary": "Reset a Rule Metrics",
        "tags": [
          "rules"
        ]
      }
    },
    "/clients/{clientid}/keepalive": {
      "put": {
        "description": "Set the online client keepalive by seconds",
        "parameters": [
          {
            "in": "path",
            "name": "clientid",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/emqx_mgmt_api_clients.keepalive"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/emqx_mgmt_api_clients.client"
                }
              }
            }
          },
          "404": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "code": {
                      "enum": [
                        "CLIENTID_NOT_FOUND"
                      ],
                      "type": "string"
                    },
                    "message": {
                      "description": "Client id not found",
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "bearerAuth": []
          }
        ],
        "tags": [
          "clients"
        ]
      }
    }
  },
  "servers": [
    {
      "url": "/api/v5"
    }
  ]
}
